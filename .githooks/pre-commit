#!/usr/bin/env python3
"""
Pre-commit hook to prevent leaking secrets.
Converted from Bash to Python for better readability.

Rules:
1) Block .env files except literal .env.example
2) Scan staged files for key assignments; block unless RHS empty or '<REDACTED>'
3) Summarize violations
"""

import subprocess
import sys
import os
import re

# Configurable exclusions
EXCLUDED_DIRS = ["node_modules"]
EXCLUDED_PATTERNS = [
    ".githooks/*", "*.jpg", "*.jpeg", "*.png", "*.gif", "*.bmp", "*.tiff",
    "*.mp4", "*.avi", "*.mov", "*.webm", "*.mkv", "playwright-report/index.html"
]

# Keys to scan for in assignments (case-insensitive regex with word boundaries)
KEYS = r"\b(?:GEMINI_API_KEY|OPENAI_API_KEY|RESEND_API_KEY|SUPABASE_SERVICE_ROLE_KEY|STRIPE_SECRET_KEY|VITE_GOOGLE_MAPS_API_KEY|VITE_SUPABASE_ANON_KEY|API_KEY|SECRET|TOKEN|PASSWORD)\b"

# Whitelisted RHS patterns that indicate legitimate references (not secret exposure)
WHITELIST_EXACT = ["<REDACTED>", "'<REDACTED>'"]
WHITELIST_PREFIXES = [
    "process.env.", "os.environ", "import.meta.env.",  # Environment variables
    "${{ secrets.", "${{ vars.",                      # GitHub Actions
    "config.", "settings.", "env.",                   # Config objects
    "getEnv(", "process.env.get(",                    # Function calls
]
WHITELIST_CONTAINS = [
    "!!", "?.", "session?.", "auth.",                 # JavaScript expressions
    "`",                                              # Template literals
    "import.meta", "process.env",                     # Module references
    "[", "]", "(", ")", ";", "args[", "params.",      # Variable access, function calls
]

def is_variable_name(value):
    """Check if a value looks like a variable name or property access (not a hardcoded secret)."""
    # Allow simple variable names or object property access (e.g., obj.prop, obj.prop.subprop)
    return bool(re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*$', value))

def get_staged_files():
    """Get list of staged files NUL-safe (handles filenames with spaces/newlines)."""
    try:
        result = subprocess.run(
            ["git", "diff", "--cached", "--name-only", "-z"],
            capture_output=True, text=True, check=True
        )
        # Split on null bytes, filter out empty strings
        return [f for f in result.stdout.split('\0') if f.strip()]
    except subprocess.CalledProcessError:
        return []

def is_excluded(filepath):
    """Check if file is in excluded directories or matches excluded patterns."""
    # Check excluded directories
    for excluded_dir in EXCLUDED_DIRS:
        if filepath.startswith(f"{excluded_dir}/"):
            return True

    # Check excluded patterns (simple glob matching)
    for pattern in EXCLUDED_PATTERNS:
        # Convert glob to regex
        regex_pattern = pattern.replace(".", r"\.").replace("*", ".*")
        if re.match(f"^{regex_pattern}$", filepath):
            return True

    return False

def extract_rhs_value(line):
    """Extract RHS of assignment using regex (matches the sed logic from Bash version)."""
    # This regex matches: key = value, with word boundaries around keys
    # sed -nE "s/.*($KEYS)\s*[:=]\s*['\"]?([^'\"\s]*)['\"]?.*/\2/p"
    keys_pattern = r"\b(?:GEMINI_API_KEY|OPENAI_API_KEY|RESEND_API_KEY|SUPABASE_SERVICE_ROLE_KEY|STRIPE_SECRET_KEY|VITE_GOOGLE_MAPS_API_KEY|VITE_SUPABASE_ANON_KEY|API_KEY|SECRET|TOKEN|PASSWORD)\b"
    pattern = rf".*({keys_pattern})\s*[:=]\s*['\"]?([^'\"\s,]*)['\"]?"
    match = re.search(pattern, line, re.IGNORECASE)
    if match:
        rhs = match.group(2)
        # Strip trailing punctuation that might be included
        rhs = rhs.rstrip(',;')
        return rhs
    return ""

def scan_file_for_secrets(filepath):
    """Scan staged content for key assignments and return violations."""
    violations = []

    try:
        # Get staged file content (equivalent to git show :"$FILE")
        result = subprocess.run(
            ["git", "show", f":{filepath}"],
            capture_output=True, text=True, check=True
        )
    except subprocess.CalledProcessError:
        # Skip if file doesn't exist in staging (deleted, binary, etc.)
        return violations

    lines = result.stdout.splitlines(keepends=False)

    # Process each line (equivalent to the pipeline: git show | nl | grep | while read)
    for lineno, line in enumerate(lines, 1):
        # Check if line contains any of the keys (case-insensitive)
        if re.search(KEYS, line, re.IGNORECASE):
            # Extract RHS value
            rhs = extract_rhs_value(line)

            # Skip if no assignment found or RHS is whitelisted
            if not rhs or rhs in WHITELIST_EXACT or any(rhs.startswith(prefix) for prefix in WHITELIST_PREFIXES) or any(pattern in rhs for pattern in WHITELIST_CONTAINS) or is_variable_name(rhs):
                continue

            # Record violation
            violations.append(f"VIOLATION: {filepath}:{lineno} -> {line}")

    return violations

def main():
    """Main hook logic."""
    # Get staged files
    staged_files = get_staged_files()

    # If no staged files, exit early
    if not staged_files:
        sys.exit(0)

    exit_code = 0
    violations = []

    # Process each staged file
    for filepath in staged_files:
        if not filepath:
            continue

        # Check exclusions
        if is_excluded(filepath):
            continue

        # Rule 1: Block .env files except .env.example
        if filepath.endswith('.env') and filepath != '.env.example':
            violations.append(f"BLOCKED .env file: {filepath}")
            exit_code = 1
            continue

        # Rule 2: Scan for secrets in staged content
        file_violations = scan_file_for_secrets(filepath)
        if file_violations:
            violations.extend(file_violations)
            exit_code = 1

    # Rule 3: Summarize and exit
    if exit_code != 0:
        print("COMMIT BLOCKED: Violations found.")
        for violation in violations:
            print(violation)
        print("Fix by removing secrets or using '<REDACTED>'.")
        sys.exit(1)

    sys.exit(0)

if __name__ == "__main__":
    main()