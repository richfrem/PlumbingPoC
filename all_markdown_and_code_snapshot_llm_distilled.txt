# All Markdown Files Snapshot (LLM-Distilled)

Generated On: 2025-10-21T17:52:29.390Z

# Mnemonic Weight (Token Count): ~154,115 tokens

# Directory Structure (relative to project root)
  ./.githooks/
  ./.githooks/pre-commit.sh
  ./.github/
  ./.github/copilot-instructions.md
  ./.netlify/
  ./.pre-commit-config.yaml
  ./INTERNAL_DEV_README.md
  ./PROMPTS/
  ./README.md
  ./adrs/
  ./agents/
  ./docs/
  ./environments/
  ./netlify.toml
  ./package.json
  ./packages/
  ./packages/backend/
  ./packages/backend/api/
  ./packages/backend/api/README.md
  ./packages/backend/api/agents/
  ./packages/backend/api/config/
  ./packages/backend/api/config/azure/
  ./packages/backend/api/config/supabase/
  ./packages/backend/api/config/supabase/database.js
  ./packages/backend/api/config/supabase/index.js
  ./packages/backend/api/controllers/
  ./packages/backend/api/controllers/followUpController.js
  ./packages/backend/api/controllers/invoiceController.js
  ./packages/backend/api/controllers/requestController.js
  ./packages/backend/api/controllers/triageController.js
  ./packages/backend/api/controllers/userController.js
  ./packages/backend/api/middleware/
  ./packages/backend/api/middleware/authMiddleware.js
  ./packages/backend/api/middleware/validationMiddleware.js
  ./packages/backend/api/routes/
  ./packages/backend/api/routes/agentRoutes.js
  ./packages/backend/api/routes/followUpRoutes.js
  ./packages/backend/api/routes/invoiceRoutes.js
  ./packages/backend/api/routes/requestRoutes.js
  ./packages/backend/api/routes/triageRoutes.js
  ./packages/backend/api/routes/userRoutes.js
  ./packages/backend/api/server.js
  ./packages/backend/api/services/
  ./packages/backend/api/services/email/
  ./packages/backend/api/services/email/resend/
  ./packages/backend/api/services/email/resend/client.js
  ./packages/backend/api/services/email/resend/index.js
  ./packages/backend/api/services/sms/
  ./packages/backend/api/services/sms/twilio/
  ./packages/backend/api/services/sms/twilio/client.js
  ./packages/backend/api/services/sms/twilio/index.js
  ./packages/backend/api/validation/
  ./packages/backend/api/validation/schemas.js
  ./packages/backend/netlify/
  ./packages/backend/netlify/functions/
  ./packages/backend/netlify/functions/README.md
  ./packages/backend/netlify/functions/api.mjs
  ./packages/backend/netlify/functions/quote-agent.mjs
  ./packages/backend/netlify/functions/send-sms.mjs
  ./packages/backend/netlify/functions/triage-agent.mjs
  ./packages/backend/package.json
  ./packages/backend/src/
  ./packages/backend/src/lib/
  ./packages/backend/src/lib/logger.js
  ./packages/backend/start.js
  ./packages/frontend/
  ./packages/frontend/build-scripts/
  ./packages/frontend/config/
  ./packages/frontend/config/azure/
  ./packages/frontend/config/netlify/
  ./packages/frontend/config/netlify/vite.config.js
  ./packages/frontend/package.json
  ./packages/frontend/public/
  ./packages/frontend/src/
  ./packages/frontend/src/components/
  ./packages/frontend/src/components/examples/
  ./packages/frontend/src/components/examples/RealtimeDemo.tsx
  ./packages/frontend/src/features/
  ./packages/frontend/src/features/admin/
  ./packages/frontend/src/features/admin/components/
  ./packages/frontend/src/features/admin/components/MapView.tsx
  ./packages/frontend/src/features/auth/
  ./packages/frontend/src/features/auth/AuthContext.tsx
  ./packages/frontend/src/features/auth/components/
  ./packages/frontend/src/features/auth/components/AuthModal.tsx
  ./packages/frontend/src/features/auth/components/UserMenu.tsx
  ./packages/frontend/src/features/landing/
  ./packages/frontend/src/features/landing/components/
  ./packages/frontend/src/features/landing/components/AboutSection.tsx
  ./packages/frontend/src/features/landing/components/ContactSection.tsx
  ./packages/frontend/src/features/landing/components/ReviewsSection.tsx
  ./packages/frontend/src/features/landing/components/ServicesSection.tsx
  ./packages/frontend/src/features/profile/
  ./packages/frontend/src/features/profile/components/
  ./packages/frontend/src/features/profile/components/ProfileModal.tsx
  ./packages/frontend/src/features/requests/
  ./packages/frontend/src/features/requests/components/
  ./packages/frontend/src/features/requests/components/AITriageSummary.tsx
  ./packages/frontend/src/features/requests/components/AttachmentSection.tsx
  ./packages/frontend/src/features/requests/components/CommunicationLog.tsx
  ./packages/frontend/src/features/requests/components/CompleteJobModal.tsx
  ./packages/frontend/src/features/requests/components/CustomerInfoSection.tsx
  ./packages/frontend/src/features/requests/components/Dashboard.tsx
  ./packages/frontend/src/features/requests/components/InvoiceFormModal.tsx
  ./packages/frontend/src/features/requests/components/ModalFooter.tsx
  ./packages/frontend/src/features/requests/components/ModalHeader.tsx
  ./packages/frontend/src/features/requests/components/MyRequests.tsx
  ./packages/frontend/src/features/requests/components/PipelineView.tsx
  ./packages/frontend/src/features/requests/components/QuoteAgentModal.tsx
  ./packages/frontend/src/features/requests/components/QuoteFormModal.tsx
  ./packages/frontend/src/features/requests/components/QuoteList.tsx
  ./packages/frontend/src/features/requests/components/RequestActions.tsx
  ./packages/frontend/src/features/requests/components/RequestDetailModal.tsx
  ./packages/frontend/src/features/requests/components/RequestProblemDetails.tsx
  ./packages/frontend/src/features/requests/components/ScheduleJobSection.tsx
  ./packages/frontend/src/features/requests/pages/
  ./packages/frontend/src/features/requests/pages/RequestView.tsx
  ./packages/frontend/src/features/requests/types/
  ./packages/frontend/src/features/requests/types/index.ts
  ./packages/frontend/src/features/services/
  ./packages/frontend/src/features/services/ServiceDetailPage.tsx
  ./packages/frontend/src/hooks/
  ./packages/frontend/src/hooks/index.ts
  ./packages/frontend/src/hooks/useRequestMutations.ts
  ./packages/frontend/src/hooks/useSpecializedQueries.ts
  ./packages/frontend/src/hooks/useSupabaseRealtimeV3.ts
  ./packages/frontend/src/hooks/useTableQuery.ts
  ./packages/frontend/src/lib/
  ./packages/frontend/src/lib/apiClient.ts
  ./packages/frontend/src/lib/logger.ts
  ./packages/frontend/src/lib/serviceDefinitions.ts
  ./packages/frontend/src/lib/statusColors.json
  ./packages/frontend/src/lib/statusColors.ts
  ./packages/frontend/src/lib/supabaseClient.ts
  ./packages/frontend/src/main.tsx
  ./packages/frontend/tsconfig.json
  ./packages/frontend/vite.config.js
  ./scripts/
  ./scripts/setup-git-hooks.sh
  ./shutdown.sh
  ./startup.sh
  ./supabase/
  ./supabase/.temp/
  ./supabase/DeployingGeocodeInSupabase.md
  ./supabase/HowToGenerateSupabaseSchema.md
  ./supabase/SUPABASE_DATABASE_AND_AUTH_SETUP.md
  ./supabase/functions/
  ./supabase/functions/geocode/
  ./supabase/functions/geocode/index.ts
  ./supabase/schema.sql
  ./tests/
  ./vitest.config.ts
  ./vitest.temp.config.ts

--- START OF FILE ./.githooks/pre-commit.sh ---

#!/usr/bin/env bash
# DEPRECATED: Replaced with Python version (pre-commit) for better readability
# Pre-commit hook to prevent leaking secrets.
# Rules:
# 1) Block .env files except literal .env.example
# 2) Scan staged files for key assignments; block unless RHS empty or '<REDACTED>'
# 3) Summarize violations

# Bash strict mode: exit on error, treat unset variables as errors, propagate pipeline failures
# -e exit immediately with an non-zero status
# -u treat unset variables as an error
# -o pipefail the return value of a pipeline is the status of the last command to exit with a non-zero status
set -euo pipefail
# Set Internal Field Separator to newline and tab only (safer word splitting)
IFS=$'\n\t'

# Configurable exclusions
EXCLUDED_DIRS=("node_modules")
EXCLUDED_PATTERNS=(".githooks/*" "*.jpg" "*.jpeg" "*.png" "*.gif" "*.bmp" "*.tiff" "*.mp4" "*.avi" "*.mov" "*.webm" "*.mkv" "playwright-report/index.html")

# Keys to scan for in assignments (case-insensitive regex)
KEYS="GEMINI_API_KEY|OPENAI_API_KEY|RESEND_API_KEY|SUPABASE_SERVICE_ROLE_KEY|STRIPE_SECRET_KEY|VITE_GOOGLE_MAPS_API_KEY|VITE_SUPABASE_ANON_KEY|API_KEY|SECRET|TOKEN|PASSWORD"
# Whitelisted RHS values that are allowed (e.g., redacted placeholders)
WHITELIST="<REDACTED>|'<REDACTED>'"

# Collect staged files NUL-safe (handles filenames with spaces/newlines)
# define an array to hold full list of staged files by git diff
STAGED=()
# Default internal field separator -- IFS (space, tab, newline) e.g. "hello world" treated as two words
# but in this case with file names, we want to treat the entire filename as a single word so no separator
# no IFS provided so a file name like "my file.txt" is treated as a single word
# read -r = raw mode, also allows backslashes in filenames
# -d '' = read until null byte (NUL), not newline.  d stands for null \0 delimiter?
#       -d delim The first character of delim is used to terminate the input line,  rather than newline.
while IFS= read -r -d '' f
do
    STAGED+=("$f")
done < <(git diff --cached --name-only -z)  
#gets list of staged files, separated by null bytes. names only -z stands for null byte

# If no staged files, exit early (nothing to check)
if [ ${#STAGED[@]} -eq 0 ]; then exit 0; fi

EXIT_CODE=0

# Array to hold violation messages
VIOLATIONS=()

# Loop through each staged file array
for FILE in "${STAGED[@]}"; do
  [ -n "$FILE" ] || continue  # Skip empty filenames

  # Check if file is in excluded directories
  for dir in "${EXCLUDED_DIRS[@]}"; do
    if [[ "$FILE" == $dir/* ]]; then continue 2; fi  # Skip this file
  done

  # Check if file matches excluded patterns
  for pat in "${EXCLUDED_PATTERNS[@]}"; do
    if [[ "$FILE" == $pat ]]; then continue 2; fi  # Skip this file
  done

  # Rule 1: block .env files except .env.example
  if [[ "$FILE" == *.env* && "$FILE" != ".env.example" ]]; then
    VIOLATIONS+=("BLOCKED .env file: $FILE")
    EXIT_CODE=1
    continue
  fi

  # Skip if not a staged blob (deleted/dir/submodule)
  if ! git show :"$FILE" >/dev/null 2>&1; then continue; fi

  # Rule 2: scan staged content for key assignments
  # Read each input line: lineno gets the line number, rest gets the line content (split on ':' from nl command)
  # For each line in the staged file that contains a secret key, extract the assigned 
  #value and check if it's allowed.  
  # Plain language: For each staged file, process lines with secret keys; if RHS value isn't whitelisted, record violation
  while IFS=: read -r lineno rest; do
    line="$rest"
    # Extract RHS of assignment using sed regex
    rhs=$(printf '%s\n' "$line" | sed -nE "s/.*($KEYS)\s*[:=]\s*['\"]?([^'\"\s]*)['\"]?.*/\2/p")
    [ -z "$rhs" ] && continue  # No assignment found
    if [[ "$WHITELIST" == *"$rhs"* ]]; then continue; fi  # Whitelisted value
    VIOLATIONS+=("VIOLATION: $FILE:$lineno -> $line")
    EXIT_CODE=1
  # Process substitution: feed the output of the pipeline (numbered lines containing key matches) 
  # into the while loop's stdin, where 'read -r lineno rest' splits each line on ':' into lineno and rest variables
  # < <(pipeline): process substitution - executes the pipeline in a subshell and redirects its stdout as input to the while loop
  # nl = numbered lines -ba = number all lines (including blank) 
  # -w1 = width 1 (min digits) 
  # -s: = separate number and line with colon
  # grep -Eni = grep with -E extended regex, -n show line numbers 
  done < <(git show :"$FILE" 2>/dev/null | nl -ba -w1 -s: | grep -Eni "$KEYS" || true) # while loop for each line with a key match
done #for loop over files

# Rule 3: summarize and exit
if [ $EXIT_CODE -ne 0 ]; then
  echo "COMMIT BLOCKED: Violations found."
  for v in "${VIOLATIONS[@]}"; 
  do
    echo "$v"
  done
  echo "Fix by removing secrets or using '<REDACTED>'."
  exit 1
fi

exit 0
--- END OF FILE ---

--- START OF FILE ./.github/copilot-instructions.md ---

## PlumbingPOC - AI-Powered Client Management Platform

**Project Type:** Fullstack SaaS Application
**Tech Stack:** React/TypeScript + Node.js/Express + Supabase + OpenAI
**Architecture:** Monorepo with separate frontend/backend packages

## CRITICAL COMMUNICATION RULES

**ALWAYS confirm user intent before making code changes.** Never implement solutions without explicit approval. Ask clarifying questions and wait for confirmation before proceeding with any code modifications.

**ALWAYS follow documented architectural decisions in the `adrs/` folder.** If no ADR exists for a decision, ask the user for guidance before proceeding. Create a new ADR if a new architectural decision is made.

**WHY:** Prevents frustration and ensures collaborative development. Users need time to review, ask questions, and provide feedback on proposed changes.

**HOW TO:**
1. **Ask clarifying questions** to understand requirements fully
2. **Confirm assumptions** about implementation details
3. Present your understanding of the request
4. Ask for confirmation: "Does this match what you want?"
5. Wait for explicit approval before implementing
6. If unsure, ask: "Should I proceed with this approach?"

## DEVELOPMENT WORKFLOW

### Before Starting Work:
- Check existing ADRs in `adrs/` folder for relevant decisions
- Review `TASKS.md` for current project status
- Understand the monorepo structure (`packages/frontend/`, `packages/backend/`)

### Code Quality Standards:
- Follow TypeScript strict mode
- Use ESLint and Prettier configurations
- Write comprehensive tests for new features
- Update documentation for architectural changes

### Testing Requirements:
- E2E tests in `tests/e2e/` using Playwright
- Unit tests using Vitest
- All tests must pass before merging

### Deployment Process:
- Follow `docs/NETLIFY_DEPLOYMENT.md` for frontend deployment
- Backend deploys via Netlify Functions
- Database changes require Supabase migrations

## ARCHITECTURAL CONSTRAINTS

- **Frontend:** React with TypeScript, Vite build system
- **Backend:** Node.js/Express with ESM modules (ADR-014)
- **Database:** Supabase (PostgreSQL)
- **Styling:** Tailwind CSS + MUI components
- **State Management:** TanStack Query for server state
- **Authentication:** Supabase Auth with custom contexts

## COMMUNICATION PREFERENCES

- Keep responses concise and technical
- Use markdown formatting for code and file references
- Reference specific files with clickable links: [`filename.ext`](relative/path.ext:line)
- Ask for clarification when requirements are ambiguous
- Confirm understanding before implementing complex changes

--- END OF FILE ---

--- START OF FILE ./.pre-commit-config.yaml ---

repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: trailing-whitespace
        exclude: ^all_markdown_and_code_snapshot_llm_distilled\.txt$
      - id: end-of-file-fixer
        exclude: ^all_markdown_and_code_snapshot_llm_distilled\.txt$
      - id: check-yaml
      - id: check-added-large-files

  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.5.0
    hooks:
      - id: detect-secrets
        args: ['--baseline', '.secrets.baseline']
        exclude: ^(package-lock\.json|\.secrets\.baseline|all_markdown_and_code_snapshot_llm_distilled\.txt)$

  - repo: local
    hooks:
      - id: block-env-files
        name: Block .env files (except .env.example)
        entry: python3
        language: system
        files: ^\.env$
        exclude: ^\.env\.example$
        args:
          - -c
          - |
            import sys
            filename = sys.argv[1]
            if filename != '.env.example':
                print(f"ERROR: Attempting to commit {filename} file!")
                print("Use .env.example for templates and keep secrets in .env.local")
                sys.exit(1)

      - id: custom-secrets-scan
        name: Custom secrets scanner (legacy Python hook)
        entry: python3
        language: system
        files: .*
        pass_filenames: false
        args:
          - .githooks/pre-commit

--- END OF FILE ---

--- START OF FILE ./INTERNAL_DEV_README.md ---

# PlumbingPOC: AI-Powered Client Management & Quoting Platform

**PlumbingPOC** is an end-to-end, fullstack client management and quoting platform built for local trades businesses. It transforms the initial point of contact from a simple form into an intelligent, AI-driven conversation powered by **OpenAI's Agent Toolkit**, and extends into a full client portal for managing the entire job lifecycle.

Beyond intelligent lead qualification, it provides a secure command center for business owners to manage job statuses, create quotes, and communicate directly with clients in real-time. The platform features a responsive Vite + React frontend, a scalable MVC-patterned Node.js/Express backend, and deep integrations with OpenAI's Agents API and Supabase for its core functionality.

## Features

-   **Modern Frontend:** A fully responsive web app built with Vite, React (TypeScript/TSX), Material-UI, and custom styled components, architected with a professional, feature-based structure.
-   **YAML-Driven AI Agents:** Configurable, intelligent agents defined in YAML files for quote intake and request triage, powered by OpenAI's function calling and structured outputs.
-   **Intelligent Quote Agent:** A guided, conversational modal that dynamically generates contextual questions based on customer responses, ensuring perfect lead qualification with minimal friction.
-   **AI-Powered Triage Agent:** Analyzes all customer Q&A data, problem descriptions, and service details to provide priority scores, profitability assessments, and business intelligence for incoming requests.
-   **Scalable MVC Backend:** A robust Express/Node API architected for maintainability, featuring separate layers for routing, controllers, middleware, and validation.
-   **Serverless Agent Functions:** Netlify Functions for quote-agent and triage-agent provide scalable, stateless execution of AI workflows.
-   **Secure Database & Auth:** Full integration with Supabase for user profiles, requests, quotes, notes, file storage, and secure authentication (Email/Password, Google, and Azure/Microsoft).
-   **Comprehensive Admin Dashboard:** A "Command Center" for business owners to view, manage, and act on all incoming quote requests in a professional, interactive UI.
-   **Interactive Job Management:** Update the status of any job (`new`, `quoted`, `scheduled`, `completed`) directly from the dashboard.
-   **Real-time Communication Log:** A live chat interface allowing admins and customers to communicate directly within a job's context, with messages appearing instantly for both parties.
-   **Contextual UX Design:** Chat interfaces with contextual icons (emergency alerts, property, calendar, etc.) and smooth interactive button states for enhanced user experience.

## Project Structure

The repository follows a modern monorepo architecture with separate packages for frontend and backend services, organized for clarity and professional development standards.

```
.
‚îú‚îÄ‚îÄ agents/               # YAML-driven AI agent definitions
‚îÇ   ‚îú‚îÄ‚îÄ quote-agent.yaml  # Conversational quote intake workflow
‚îÇ   ‚îî‚îÄ‚îÄ triage-agent.yaml # Intelligent request analysis workflow
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ frontend/         # React/Vite application
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/          # React components and logic (TSX)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ features/ # Feature-based architecture
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ profile/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requests/ # Components, hooks, and types co-located
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ QuoteAgentModal.tsx       # YAML-driven quote intake UI
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ RequestDetailModal.tsx      # Admin job management
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ AITriageSummary.tsx         # Triage display
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib/      # Shared libraries (Supabase client, API client)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ public/       # Static assets (images, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.html    # Main HTML template
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vite.config.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ package.json  # Frontend dependencies
‚îÇ   ‚îî‚îÄ‚îÄ backend/          # Node.js/Express API
‚îÇ       ‚îú‚îÄ‚îÄ api/          # Express server and routes
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ agents/   # AI agent runners (legacy - being phased out)
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ triageAgentRunner.js # Triage agent logic
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ server.js
‚îÇ       ‚îú‚îÄ‚îÄ netlify/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ functions/ # Serverless agent functions (primary)
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ api.mjs           # Main API wrapper
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ quote-agent.mjs   # Quote agent endpoint (self-contained)
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ triage-agent.mjs  # Triage agent endpoint
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ send-sms.mjs      # SMS notifications
‚îÇ       ‚îî‚îÄ‚îÄ package.json  # Backend dependencies
‚îú‚îÄ‚îÄ PROMPTS/              # Prompt engineering & agent logic documentation
‚îú‚îÄ‚îÄ supabase/
‚îÇ   ‚îî‚îÄ‚îÄ SUPABASE_DATABASE_AND_AUTH_SETUP.md # Full setup guide
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ NETLIFY_DEPLOYMENT.md         # Deployment guide
‚îÇ   ‚îî‚îÄ‚îÄ NETLIFY_TROUBLESHOOTING.md    # Common deployment issues
‚îú‚îÄ‚îÄ netlify.toml          # Netlify configuration with function settings
‚îú‚îÄ‚îÄ package.json          # Root workspace configuration
‚îî‚îÄ‚îÄ ...
```

---

## Local Development & Setup

### 1. Prerequisites

-   Node.js (v20 or higher recommended)
-   npm (or yarn/pnpm)
-   A Supabase account (free tier is sufficient)
-   An OpenAI API key

### 2. Initial Setup

1.  **Clone the repository:**
    ```sh
    git clone [your-repo-url]
    cd PlumbingPOC
    ```

2.  **Configure Supabase:**
    Follow the detailed instructions in `supabase/SUPABASE_DATABASE_AND_AUTH_SETUP.md`. This guide contains the master SQL script to create all tables, set up the real-time publications, and apply the necessary Row Level Security (RLS) policies.

3.  **Set Up Environment Variables:**
    From the project root, create a copy of `.env.example` named `.env`, and fill in your Supabase and OpenAI API keys.

4.  **Install Dependencies:**
    ```sh
    npm install
    ```
    This will install dependencies for all packages in the workspace.

### 3. Running the Application

Both the backend API and the frontend server must be running simultaneously.

#### Recommended Method: Startup Script

From the project root directory, run the convenience script:
```sh
./startup.sh
```
This script will start both services in the background and provide you with the URLs.

#### Manual Method

1.  **Start the Backend API Server:**
    From the project root directory:
    ```sh
    npm run dev:backend
    ```

2.  **Start the Frontend Vite Server:**
    In a second terminal, from the project root directory:
    ```sh
    npm run dev:frontend
    ```

3.  **Access the App:**
    Open your browser and navigate to the frontend URL provided by Vite (usually http://localhost:5173).

---

## AI Agent Architecture

PlumbingPOC leverages **YAML-driven AI agents** powered by OpenAI's function calling and structured outputs to create intelligent, conversational workflows.

### Agent Design Pattern

Each agent follows a consistent pattern:

1. **YAML Configuration** (`agents/*.yaml`) - Defines the workflow nodes, prompts, tools, and guardrails
2. **Agent Runner** (`packages/backend/api/agents/*Runner.js`) - Implements the business logic and OpenAI integration
3. **Netlify Function** (`packages/backend/netlify/functions/*.mjs`) - Provides serverless execution endpoint
4. **Frontend Integration** - React components consume the agent via API calls

### Quote Agent (`quote-agent.yaml`)

**Purpose:** Conversational quote intake with dynamic question generation

**Key Features:**
- Multi-node workflow (emergency_check ‚Üí service_selection ‚Üí dynamic_questions ‚Üí review_summary)
- Context-aware question generation based on service type and previous answers
- Structured output validation ensuring complete data collection
- Session management for stateful conversations
- Automatic summary generation for customer review

**Technologies:**
- OpenAI GPT-4o with function calling
- YAML-based workflow definition
- Serverless execution via Netlify Functions
- Real-time UI updates with contextual icons (üö® emergency, üè† property, üìÖ calendar)

### Triage Agent (`triage-agent.yaml`)

**Purpose:** Intelligent analysis of quote requests for business prioritization

**Key Features:**
- Analyzes complete Q&A summaries from customer intake
- Calculates job complexity based on service type and location
- Assesses urgency using emergency status, timeline, and problem severity
- Provides priority scores (1-10) with detailed explanations
- Evaluates profitability potential considering job complexity and upsell opportunities

**Business Intelligence Tools:**
- `calculateJobComplexity()` - Service category and location-based scoring
- `assessCustomerUrgency()` - Timeline and severity analysis
- Structured JSON output with explanations for each score

**Output:**
```json
{
  "triage_summary": "2-3 sentence summary",
  "priority_score": 8,
  "priority_explanation": "Why this priority",
  "profitability_score": 7,
  "profitability_explanation": "Why this profitability",
  "complexity_score": 6,
  "urgency_score": 9
}
```

### Benefits of YAML-Driven Agents

‚úÖ **Maintainability** - Workflow changes don't require code modifications
‚úÖ **Testability** - Agents can be tested independently with mock data
‚úÖ **Scalability** - New agents can be added following the same pattern
‚úÖ **Transparency** - Business logic is visible in human-readable YAML
‚úÖ **Version Control** - Workflow changes are tracked in git

---

## Application Flows

### 1. The AI-Powered Intake Flow (YAML-Driven Agent)
This diagram illustrates the intelligent, agent-driven lead qualification process using the OpenAI Agent Toolkit.

```mermaid
sequenceDiagram
    participant User
    participant Frontend (ChatKit UI)
    participant Quote Agent Runner
    participant OpenAI API (GPT-4o)
    participant Supabase

    User->>Frontend (ChatKit UI): Signs in or registers
    Frontend (ChatKit UI)->>Supabase: Authenticates user, gets session
    Supabase-->>Frontend (ChatKit UI): Returns user session & profile

    User->>Frontend (ChatKit UI): Clicks "Request a Quote"

    Note over Frontend (ChatKit UI),Quote Agent Runner: Agent initialization with YAML config
    Frontend (ChatKit UI)->>Quote Agent Runner: POST /quote-agent (initialize session)
    activate Quote Agent Runner
    Quote Agent Runner->>Quote Agent Runner: Load quote-agent.yaml workflow definition
    Quote Agent Runner->>OpenAI API (GPT-4o): Request initial question based on service type
    OpenAI API (GPT-4o)-->>Quote Agent Runner: Returns structured question with options
    Quote Agent Runner-->>Frontend (ChatKit UI): First question (emergency check)
    deactivate Quote Agent Runner

    Frontend (ChatKit UI)->>User: Displays question with interactive pill buttons
    User-->>Frontend (ChatKit UI): Clicks response button

    loop Dynamic Conversation Flow (controlled by YAML nodes)
        Frontend (ChatKit UI)->>Quote Agent Runner: POST /quote-agent (with conversation history)
        activate Quote Agent Runner
        Quote Agent Runner->>Quote Agent Runner: Navigate YAML workflow nodes
        Quote Agent Runner->>OpenAI API (GPT-4o): Analyze responses & determine next question
        activate OpenAI API (GPT-4o)
        OpenAI API (GPT-4o)-->>Quote Agent Runner: Returns next question or completion signal
        deactivate OpenAI API (GPT-4o)
        Quote Agent Runner-->>Frontend (ChatKit UI): Next question with contextual icon
        deactivate Quote Agent Runner

        Frontend (ChatKit UI)->>User: Displays question with contextual UI (üö®/üè†/üìÖ)
        User-->>Frontend (ChatKit UI): Provides answer
    end

    Note over Quote Agent Runner: Agent reaches review_summary stage
    Quote Agent Runner->>Frontend (ChatKit UI): Returns summary payload with all answers
    Frontend (ChatKit UI)->>User: Displays comprehensive review summary

    User->>Frontend (ChatKit UI): Confirms and submits the final request
    Frontend (ChatKit UI)->>Supabase: POST /api/requests/submit (with structured data)
    activate Supabase
    Supabase->>Supabase: Inserts request with answers array, service address, geocoding

    opt User uploaded attachments
        Frontend (ChatKit UI)->>Supabase: Upload files to Storage bucket
        Supabase->>Supabase: Insert records into 'quote_attachments'
    end

    Supabase-->>Frontend (ChatKit UI): Returns success with request ID
    deactivate Supabase
    Frontend (ChatKit UI)->>User: Displays "Thank you" confirmation
```

### 2. The Client & Admin Management Flow

This diagram shows how admins and clients interact with a request after it has been submitted.

```mermaid
sequenceDiagram
    participant Admin
    participant Customer
    participant Frontend
    participant Backend API
    participant Supabase

    Admin->>Frontend: Logs in and navigates to Dashboard
    Frontend->>Backend API: GET /api/requests (fetch all data)
    Backend API->>Supabase: SELECT * from requests with joins
    Supabase-->>Backend API: Returns all request data
    Backend API-->>Frontend: Sends data to dashboard
    Frontend->>Admin: Displays list of active requests

    Admin->>Frontend: Clicks on a request to open details modal
    Admin->>Frontend: Adds a new note in the modal
    Frontend->>Backend API: POST /api/requests/:id/notes (with note text)
    activate Backend API
    Backend API->>Supabase: INSERT new row into 'request_notes'
    Supabase-->>Backend API: Confirms note saved
    Backend API-->>Frontend: Returns new note data
    deactivate Backend API
    Frontend->>Admin: UI updates instantly with the new note (via Realtime)

    Customer->>Frontend: Logs in and views their request
    Frontend->>Backend API: GET /api/requests/:id (fetch single request)
    Backend API->>Supabase: SELECT request data for this user
    Supabase-->>Backend API: Returns request, including admin's note
    Backend API-->>Frontend: Sends data to client view
    Frontend->>Customer: Displays the conversation log (with new note)
```

### 3. The AI-Powered Triage Process (YAML-Driven Agent)

This shows the intelligent backend process for automatically analyzing a new request using the Triage Agent.

```mermaid
sequenceDiagram
    participant Admin
    participant Frontend
    participant Triage Agent Runner
    participant Supabase
    participant OpenAI API (GPT-4o)

    Admin->>Frontend: Clicks "AI Triage" button in Job Docket
    Frontend->>Triage Agent Runner: POST /triage/:requestId (triggers analysis)
    activate Triage Agent Runner

    Triage Agent Runner->>Triage Agent Runner: Load triage-agent.yaml workflow
    Triage Agent Runner->>Supabase: Fetch complete request details
    activate Supabase
    Supabase-->>Triage Agent Runner: Returns request data with all Q&A answers
    deactivate Supabase

    Note over Triage Agent Runner: Calculate preliminary scores
    Triage Agent Runner->>Triage Agent Runner: calculateJobComplexity(service, location)
    Triage Agent Runner->>Triage Agent Runner: assessCustomerUrgency(emergency, timeline)
    Triage Agent Runner->>Triage Agent Runner: formatAnswersForAnalysis(Q&A array)

    Triage Agent Runner->>OpenAI API (GPT-4o): Send comprehensive prompt with:<br/>- Service category<br/>- Emergency status<br/>- Formatted Q&A summaries<br/>- Problem description<br/>- Preliminary scores
    activate OpenAI API (GPT-4o)

    Note over OpenAI API (GPT-4o): Structured function calling
    OpenAI API (GPT-4o)->>OpenAI API (GPT-4o): Analyze all data points<br/>Call: provide_triage_assessment()

    OpenAI API (GPT-4o)-->>Triage Agent Runner: Returns structured JSON:<br/>{<br/>  triage_summary,<br/>  priority_score (1-10),<br/>  priority_explanation,<br/>  profitability_score (1-10),<br/>  profitability_explanation<br/>}
    deactivate OpenAI API (GPT-4o)

    Triage Agent Runner->>Supabase: UPDATE requests SET triage fields
    activate Supabase
    Supabase-->>Triage Agent Runner: Confirms update
    deactivate Supabase

    Triage Agent Runner-->>Frontend: Returns complete analysis results
    deactivate Triage Agent Runner

    Frontend->>Admin: Displays AI Triage Summary card with:<br/>- Priority badge (1-10)<br/>- Profitability indicator<br/>- Summary text<br/>- Explanations
```

### 4. Real-time Publish/Subscribe Synchronization

This diagram illustrates how a message sent by one user appears instantly for another, using the Pub/Sub pattern.

```mermaid
sequenceDiagram
    participant Admin's Browser (Client A)
    participant Customer's Browser (Client B)
    participant Supabase Realtime Server
    participant Postgres Database

    Note over Admin's Browser (Client A), Customer's Browser (Client B): Pre-condition: Both users are viewing the same Job Docket.
    Note over Admin's Browser (Client A), Customer's Browser (Client B): The `useRequests` hook has already subscribed both clients to the channel.

    Admin's Browser (Client A)->>+Postgres Database: 1. User sends message (API call -> INSERT new note)
    Postgres Database-->>-Admin's Browser (Client A): API Response (OK)

    Postgres Database->>+Supabase Realtime Server: 2. [Publication] A change was detected in the `request_notes` table.

    Note over Supabase Realtime Server: Routing Logic!
    Supabase Realtime Server->>Supabase Realtime Server: 3. Check subscribers for the relevant channel. Found: Client A, Client B.

    Supabase Realtime Server->>+Admin's Browser (Client A): 4. [WebSocket Push] Broadcast new data payload
    Admin's Browser (Client A)->>Admin's Browser (Client A): 5. `useRequests` hook re-fetches data & UI refreshes
    deactivate Admin's Browser (Client A)

    Supabase Realtime Server->>+Customer's Browser (Client B): 4. [WebSocket Push] Broadcast new data payload
    Customer's Browser (Client B)->>Customer's Browser (Client B): 5. `useRequests` hook re-fetches data & UI refreshes
    deactivate Customer's Browser (Client B)

    deactivate Supabase Realtime Server
```# Test commit to trigger Netlify deployment
# Force deployment trigger - Thu Oct  9 07:47:11 PDT 2025
# Trigger deploy

--- END OF FILE ---

--- START OF FILE ./README.md ---

# Copilot for Trades ‚Äî AI-Powered OS for Local Service Businesses

**Copilot for Trades** is an AI-enabled web app I built to automate the unglamorous, time-consuming parts of running a local trade business (plumbing, electrical, HVAC, etc.). It turns a simple website form into a **conversational intake**, centralizes **job & quote management**, auto-generates **invoices**, and supports **SMS notifications** ‚Äî all in one place.

> üßë‚Äçüíª **Built by:** *Richard Fremmerlid* ‚Äî IT professional & AI systems builder based in Victoria, BC.
> üåê Live demo: https://copilotfortrades.com/
> üìπ 5-minute walkthrough: https://www.loom.com/share/1ead7162412140bea1f46988af675adf

---

## ‚ú® Highlights

- **üß† Conversational Lead Intake** ‚Äî An AI assistant collects the right details (and photos) to qualify leads without phone tag.
- **üìã Command Center Dashboard** ‚Äî Track every request from first contact ‚Üí quote ‚Üí scheduled ‚Üí completed ‚Üí **paid**.
- **üìç Map-Based View** ‚Äî See all active jobs on a map to plan efficient routes.
- **üí¨ Realtime Notes & Updates** ‚Äî Admin ‚Üî customer messages update instantly.
- **üßæ Invoice Automation** ‚Äî Create invoices (and mark them paid) directly from the job flow; optional online payments.
- **üì≤ SMS Alerts** ‚Äî Get a text the moment a new lead arrives (be first to respond = win more jobs).

> This is a working prototype designed for local trades ‚Äî but the architecture fits any service business that needs quoting, scheduling, and billing.

---

## üì∏ Application Showcase

### üß© Customer Quote Request Flow

Below are screenshots demonstrating how customers interact with the AI-powered quote assistant.

| Step | Description | Screenshot |
|------|--------------|-------------|
| 1Ô∏è‚É£ | AI assistant greeting & emergency prompt | ![](docs/screenshots/customer_intake_start.png) |
| 2Ô∏è‚É£ | Property and ownership questions | ![](docs/screenshots/customer_intake_question1.png) |
| 3Ô∏è‚É£ | Access and drainage problem details | ![](docs/screenshots/customer_intake_question2.png) |
| 4Ô∏è‚É£ | Review and confirmation summary | ![](docs/screenshots/customer_intake_summary.png) |
| 5Ô∏è‚É£ | Service location and contact confirmation | ![](docs/screenshots/customer_intake_confirmation.png) |

---

### üß∞ Admin Command Center

The following screenshots highlight the internal workflow for trades professionals managing jobs, quotes, and communications.

| Step | Description | Screenshot |
|------|--------------|-------------|
| 1Ô∏è‚É£ | Dashboard overview (job pipeline) | ![](docs/screenshots/dashboard_overview.png) |
| 2Ô∏è‚É£ | Populated dashboard with multiple active jobs | ![](docs/screenshots/dashboard_filled_pipeline.png) |
| 3Ô∏è‚É£ | Job Docket ‚Äî reported problem details | ![](docs/screenshots/job_docket_reported_problem.png) |
| 4Ô∏è‚É£ | AI triage summary (urgency and job classification) | ![](docs/screenshots/triage_summary_card.png) |
| 5Ô∏è‚É£ | Profitability and required expertise analysis | ![](docs/screenshots/triage_profitability_card.png) |
| 6Ô∏è‚É£ | Communication log (contractor notes) | ![](docs/screenshots/job_docket_message.png) |
| 7Ô∏è‚É£ | Create new quote (labor & materials input) | ![](docs/screenshots/quote_create_form.png) |
| 8Ô∏è‚É£ | Saved quote summary with taxes and expiry | ![](docs/screenshots/quote_saved_summary.png) |
| 9Ô∏è‚É£ | Map view ‚Äî route optimization and job clustering | ![](docs/screenshots/map_view.png) |
| üîü | SMS alert received via Twilio (instant notification) | ![](docs/screenshots/sms_received_by_admin.png) |

---

### üèÅ Notes
- Ensure images render correctly in GitHub preview.
- Use absolute paths starting with `docs/screenshots/` (no `./` prefix).
- Add a horizontal divider before this section for clarity (`---`).
- Do **not** alter any other existing README content.

---

## üß≠ Architecture at a Glance

- **Frontend:** React + Vite (TypeScript)
- **Backend:** Node.js / Express (server routes & API)
- **Serverless:** Netlify Functions for agent endpoints
- **Database & Realtime:** Supabase (auth, tables, storage, realtime)
- **AI:** OpenAI Models (conversational intake, triage, structured outputs)
- **Agents:** YAML-defined workflows (quote intake & triage) interpreted by lightweight runners



Frontend (React) ‚Üí API (Express) ‚Üí Netlify Functions (Agents)
‚Üë ‚Üì ‚Üì
Supabase Auth ‚Üê Supabase DB/Realtime ‚Üê AI (OpenAI)


- YAML-driven agents keep workflows **transparent and editable** without code changes.
- Realtime updates propagate UI changes instantly (new notes, status changes, etc.).

> ‚öôÔ∏è Want the deep dive? See: [INTERNAL_DEV_README.md](./INTERNAL_DEV_README.md) for setup, environment variables, and deployment notes.

---

## üöÄ Quick Start (Local)

> Minimal steps; full setup (Supabase, env) lives in **INTERNAL_DEV_README.md**.

```bash
git clone https://github.com/<your-username>/copilot-for-trades.git
cd copilot-for-trades
npm install
# start backend & frontend dev servers (see package.json scripts)
npm run dev


Configure your .env for Supabase & OpenAI (details in INTERNAL_DEV_README.md).

Open the frontend URL (usually http://localhost:5173).

üß© Why I Built This

I wanted to see if modern AI + realtime web tech could remove the admin drag that local trades shoulder every day. The result is a working system that captures leads conversationally, keeps owners on top of every job, and gets invoices out (and paid) faster.

I‚Äôm sharing this publicly to:

Help others learn from (and build on) a real, end-to-end AI application.

Invite thoughtful collaboration and adaptation to other service industries.

Document the practical lessons from applying AI to small-business workflows.

üìÑ License & Contact

License: MIT ¬© 2025 Richard Fremmerlid

Contact: richard.fremmerlid@gmail.com

Location: Victoria, BC

Need a managed/hosted version or a custom adaptation for another service industry? Reach out.

---

## üìú License

This project is licensed under the **Creative Commons Attribution 4.0 International License (CC BY 4.0)**.
You are free to use, modify, and distribute this project ‚Äî even commercially ‚Äî as long as proper credit is given.

**Attribution requirement:**
"Created by [Richard Fremmerlid](https://github.com/richardfremmerlid) ‚Äî Copilot for Trades (https://copilotfortrades.com)"

¬© 2025 Richard Fremmerlid
[View full license ‚Üí](https://creativecommons.org/licenses/by/4.0/)


---

# What screenshots to create (exact shots & filenames)

Create these as **PNG**, 1440√ó900 (or your native display width), in **dark or light** theme ‚Äî just be consistent. Blur/redact any personal info. Save into `docs/screenshots/` with the exact filenames below.

1) **Dashboard overview**
   - File: `dashboard_overview.png`
   - What: Main admin dashboard showing multiple requests across statuses (New, Quoted, Scheduled, Completed, Paid). Include a visible count or badges if available.

2) **Quote agent modal (intake)**
   - File: `quote_agent_modal.png`
   - What: The conversational intake UI mid-flow (a question with options or a photo upload prompt). Make the ‚ÄúAI is helping‚Äù feel obvious.

3) **AI triage summary card**
   - File: `triage_summary_card.png`
   - What: Show the triage scores (priority/profitability) and the summarized explanation for a request.

4) **Job docket modal / request detail**
   - File: `job_docket_modal.png`
   - What: The detailed view for a single request (history, notes, attachments, status controls).

5) **Map view (active jobs)**
   - File: `map_view.png`
   - What: The interactive map with multiple pins around your region. Include at least one selected pin with its info tooltip (if available).

6) **Invoice flow**
   - File: `invoice_flow.png`
   - What: The invoice creation/edit screen OR the invoice preview, plus the ‚ÄúMark Paid‚Äù action (if present).

7) **SMS notification example**
   - File: `sms_notification.png`
   - What: A screenshot of an actual/placeholder SMS alert on a phone simulator or web preview (‚ÄúNew lead received‚Ä¶‚Äù).

8) **Customer intake flow (public site)**
   - File: `customer_intake_flow.png`
   - What: The public-facing quote request page (before login) or the first step of the intake conversation from a customer‚Äôs view.

> Pro tips
> - Use seed/demo data that looks realistic (‚ÄúLeaking faucet in Fernwood‚Äù, ‚ÄúHot water tank replacement‚Äù).
> - Make sure timestamps, badges, or progress indicators are visible ‚Äî they communicate ‚Äúlive system‚Äù instantly.
> - Keep browser UI minimal (hide bookmarks bar; full-window the app).
> - If possible, keep a consistent primary color/brand through all screenshots for cohesion.

---

# Optional: Kilo Code AI prompts (to speed up)

- **Rename & split READMEs**
  > ‚ÄúRename README.md to INTERNAL_DEV_README.md. Create a new root README.md using the public template I provide. Ensure all internal setup sections remain only in INTERNAL_DEV_README.md and link to it from README.md.‚Äù

- **Insert screenshot gallery**
  > ‚ÄúCreate `docs/screenshots/` if missing and add markdown gallery in README.md under a ‚Äòüì∏ App Snapshots‚Äô section. Use the exact filenames: dashboard_overview.png, quote_agent_modal.png, triage_summary_card.png, job_docket_modal.png, map_view.png, invoice_flow.png, sms_notification.png, customer_intake_flow.png.‚Äù

- **Author metadata**
  > ‚ÄúAdd my author name ‚ÄòRichard Fremmerlid‚Äô to README.md footer and set the license to MIT with the current year.‚Äù

---

If you want, I can also generate a tiny `docs/ARCHITECTURE.md` to link from the README (1-page diagram + bullets) ‚Äî just say the word and I‚Äôll draft it.

--- END OF FILE ---

--- START OF FILE ./netlify.toml ---

# netlify.toml (v3 - Root Configuration)

[build]
  base = "." # Repository root
  command = "npm install --include=dev && npx vitest run --exclude **/*.local.test.ts && npm --workspace=@plumbingpoc/frontend run build"
  publish = "packages/frontend/dist/"
  functions = "packages/backend/netlify/functions/" # Updated functions directory
  environment = { NPM_FLAGS = "--legacy-peer-deps" }
  SECRETS_SCAN_ENABLED = false  # pragma: allowlist secret
  SECRETS_SCAN_OMIT_PATHS = [
    "README.md",
    "all_markdown_and_code_snapshot_llm_distilled.txt",
    "packages/frontend/dist/assets/*.js"
  ]


[[redirects]]
  from = "/api/*"
  to = "/.netlify/functions/api/:splat"
  status = 200

# ===================================================================
# THE DEFINITIVE FIX: Function Bundler Configuration
# ===================================================================
# This tells Netlify's bundler how to handle our backend functions.
# Note the correct TOML syntax: [functions."function-name"]
[functions]

  # Configuration for the main API function
  [functions.api]
    # Tell the bundler to NOT bundle these specific packages.
    # Instead, Netlify will include them in the function's node_modules
    # so they can be required/imported at runtime, just like in local dev.
    external_node_modules = [
      "express",
      "cors",
      "serverless-http",
      "dotenv",
      "supabase",
      "@supabase/supabase-js",
      "yaml",
      "openai"
    ]
    # Include the YAML config files for quote and triage agents
    included_files = [
      "agents/quote-agent.yaml",
      "agents/triage-agent.yaml"
    ]
    timeout = 60  # Increased timeout for AI operations like triage

  # Configuration for the SMS function
  [functions.send-sms]
    external_node_modules = ["twilio"]

  # Configuration for the quote agent function
  [functions."quote-agent"]
    external_node_modules = [
      "yaml",
      "openai"
    ]
    included_files = [
      "agents/quote-agent.yaml"
    ]

  # Configuration for the triage agent function
  [functions."triage-agent"]
    external_node_modules = [
      "yaml",
      "openai"
    ]
    included_files = [
      "agents/triage-agent.yaml"
    ]
    timeout = 60  # Increased from default 10 seconds to 60 seconds

# Removed [secrets] section and all secrets scanning related settings

--- END OF FILE ---

--- START OF FILE ./package.json ---

{
  "name": "plumbingpoc-root",
  "version": "1.0.0",
  "license": "CC-BY-4.0",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev": "npm-run-all --parallel dev:frontend dev:backend",
    "dev:frontend": "npm run dev --workspace=@plumbingpoc/frontend",
    "dev:backend": "npm run start --workspace=@plumbingpoc/backend",
    "build": "npm install && npm --workspace=@plumbingpoc/frontend run build",
    "start:api": "npm run start --workspace=@plumbingpoc/backend",
    "test": "vitest",
    "test:ci": "vitest run",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@emotion/react": "^11.11.4",
    "@emotion/styled": "^11.11.5",
    "@google/generative-ai": "^0.15.0",
    "@mui/material": "^5.16.1",
    "@mui/system": "^5.16.1",
    "@mui/x-data-grid": "^7.17.0",
    "@supabase/supabase-js": "^2.44.4",
    "@tanstack/react-query": "^5.51.11",
    "@vis.gl/react-google-maps": "^1.1.0",
    "axios": "^1.7.2",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "lucide-react": "^0.411.0",
    "multer": "^1.4.5-lts.2",
    "openai": "^4.52.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-dropzone": "^14.2.3",
    "react-helmet-async": "^2.0.5",
    "resend": "^3.5.0",
    "serverless-http": "^3.2.0",
    "twilio": "^5.2.2",
    "yaml": "^2.8.1",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@playwright/test": "^1.45.2",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.4.8",
    "@testing-library/react": "^16.0.0",
    "@types/node": "^20.14.12",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "jsdom": "^24.1.1",
    "npm-run-all": "^4.1.5",
    "playwright": "^1.45.2",
    "supertest": "^7.0.0",
    "typescript": "^5.5.4",
    "vite": "^5.3.4",
    "vitest": "^2.0.4"
  }
}

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/README.md ---


# PlumbingPOC API Server

This document outlines the architecture and conventions for the PlumbingPOC API server, built with Node.js and Express using an MVC-inspired pattern.

## Core Architecture: MVC Pattern

**Model:** Supabase handles all database interactions, data shaping, and enforces data integrity through its schema and Row Level Security (RLS) policies.

**View:** For a REST API, the "View" is the JSON data sent to the client. Controllers assemble and send these responses.

**Controller:** Contains the core business logic. Controllers receive requests from routes, interact with the Model (Supabase), and send a response back through the View (JSON).

---

## Directory Structure

```text
api/
‚îú‚îÄ‚îÄ controllers/           # Business logic (MVC: Controller)
‚îÇ   ‚îî‚îÄ‚îÄ requestController.js
‚îú‚îÄ‚îÄ middleware/            # Reusable functions before controllers
‚îÇ   ‚îú‚îÄ‚îÄ authMiddleware.js
‚îÇ   ‚îî‚îÄ‚îÄ validationMiddleware.js
‚îú‚îÄ‚îÄ routes/                # Maps URLs to controllers
‚îÇ   ‚îî‚îÄ‚îÄ requestRoutes.js
‚îú‚îÄ‚îÄ validation/            # Data contracts (schemas)
‚îÇ   ‚îî‚îÄ‚îÄ schemas.js
‚îî‚îÄ‚îÄ server.js              # Main application entry point
```

## File Responsibilities

### `server.js`

- Initializes the Express app
- Configures core middleware (CORS, body-parser)
- Loads and delegates all API routes to the `routes/` directory
- Defines a global error handler
- Starts the server

### `/routes`

Defines endpoints (e.g., `/submit`, `/:requestId/notes`), specifies HTTP methods (GET, POST), and chains middleware before passing the request to the controller.

**Example from `requestRoutes.js`:**

```javascript
// Create a formal quote for a request (admin only)
router.post(
    '/:requestId/quotes', // The Path
    authenticate,         // Middleware 1: Is the user logged in?
    isAdmin,              // Middleware 2: Does the user have admin role?
    validate(createQuoteSchema), // Middleware 3: Is the request body valid?
    createQuoteForRequest // The Controller function to run
);
```

### `/controllers`

Self-contained business logic for specific tasks (e.g., submitting a quote, adding a note). Receives `req` and `res` after middleware.

### `/middleware`

Reusable functions between route and controller.
- `authMiddleware.js`: Handles authentication (`authenticate`) and role-based authorization (`isAdmin`).
- `validationMiddleware.js`: Generic `validate` function checks incoming request data against a schema.

### `/validation`

Defines "data contracts" using zod. Each schema in `schemas.js` clearly defines the expected shape and types for endpoint request bodies, params, or queries.

## Request Lifecycle

1. **Client Request:** React app sends a POST request to `/api/requests/:id/notes`.
2. **server.js:** Request hits `server.js`, passes through CORS and JSON body parser.
3. **routes/requestRoutes.js:** Router matches path/method, applies `authenticate` middleware and `addNote` controller.
4. **middleware/authMiddleware.js:** `authenticate` checks for valid JWT, attaches `req.user` and calls `next()`. If invalid, sends 401 Unauthorized and stops flow.
5. **controllers/requestController.js:** `addRequestNote` runs, interacts with Supabase, sends JSON response (e.g., `res.status(201).json(...)`).
6. **Client Receives Response:** React app receives JSON data or error message.

This clean separation makes the system robust and predictable.

## API Testing and Troubleshooting with cURL and JWT

When developing or debugging API endpoints that require authentication, `cURL` is an invaluable tool. Here's how to use it effectively with JWT tokens:

### 1. Getting Your JWT Token from the Browser

To interact with authenticated endpoints, you'll need a valid JWT token. You can obtain this from your browser's developer tools after a successful login:

1. Open your browser's developer tools (usually F12 or Cmd+Option+I).
2. Go to the 'Network' tab.
3. Perform an action in your application that triggers an authenticated API request (e.g., logging in, fetching user data).
4. Find the relevant API request in the Network tab.
5. In the request details, look for the 'Headers' section.
6. Locate the `Authorization` header. The value will typically be in the format `Bearer <YOUR_JWT_TOKEN>`. Copy the `<YOUR_JWT_TOKEN>` part.

### 2. Constructing and Executing the cURL Command

Once you have your token, you can construct a `cURL` command to test authenticated endpoints. Remember to replace placeholders with your actual data.

```bash
curl -X <HTTP_METHOD> \
     http://localhost:3000/api/<YOUR_ENDPOINT> \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer <YOUR_JWT_TOKEN>" \
     -d '{"key": "value"}' # Only for POST/PUT requests with a body
```

**Important:** When executing in your terminal, ensure the entire `cURL` command is on a **single line** to avoid shell parsing errors.

### 3. Troubleshooting JWT Tokens with jwt.io

If you encounter "Unauthorized: Invalid token" errors, your JWT might be expired or malformed. `jwt.io` is an excellent online tool for inspecting JWTs:

1. Go to [jwt.io](https://jwt.io/).
2. Paste your full JWT token into the 'Encoded' section on the left.
3. **Expected Result:** You will likely see a message like "a-string-secret-at-least-256-bits-long" in the "Signature Verified" section. This is normal and expected, as `jwt.io` does not have access to your Supabase project's secret key to verify the token's signature. The important part is to inspect the payload.
4. The 'Payload' section on the right will decode the token, showing its claims (data).
5. **Check the `exp` (expiration) claim:** This is a Unix timestamp. If the current time is past this timestamp, your token has expired, and you'll need to generate a new one.
6. **Inspect other claims:** Ensure that claims like `role` (e.g., `admin`) and `email` match your expectations for the user.

## Mermaid diagrams


### relationship diagram
```mermaid
graph TD
    subgraph "API Server"
        A[server.js] --> B{/api/requests/*};

        subgraph "Routes"
            B --> C[requestRoutes.js];
        end

        subgraph "Middleware"
            D[authMiddleware.js];
            E[validationMiddleware.js];
        end

        subgraph "Validation"
            F[schemas.js];
        end

        subgraph "Controllers"
            G[requestController.js];
        end

        C -- "Defines Path & Chains Middleware" --> D;
        C -- " " --> E;
        E -- "Uses" --> F;
        C -- "Calls" --> G;
    end

    H((Supabase));
    G -- "Interacts with (Model)" --> H;

    I([Client]);
    I -- "HTTP Request" --> A;
    G -- "JSON Response (View)" --> I;

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style D fill:#9f9,stroke:#333,stroke-width:2px
    style E fill:#9f9,stroke:#333,stroke-width:2px
    style F fill:#f99,stroke:#333,stroke-width:2px
    style G fill:#ff9,stroke:#333,stroke-width:2px
```

### Sequence Diagram Admin Creates a Quote (The Original Diagram)
```mermaid
sequenceDiagram
    participant Client
    participant server.js
    participant requestRoutes.js
    participant authMiddleware.js
    participant validationMiddleware.js
    participant requestController.js
    participant Supabase

    Client->>server.js: POST /api/requests/:id/quotes (with data & token)
    activate server.js

    server.js->>requestRoutes.js: Route request
    activate requestRoutes.js

    requestRoutes.js->>authMiddleware.js: 1. call authenticate()
    activate authMiddleware.js
    authMiddleware.js->>Supabase: supabase.auth.getUser(token)
    Supabase-->>authMiddleware.js: Returns user object
    authMiddleware.js-->>requestRoutes.js: next()
    deactivate authMiddleware.js

    requestRoutes.js->>authMiddleware.js: 2. call isAdmin()
    activate authMiddleware.js
    authMiddleware.js->>Supabase: Check user_profiles.role
    Supabase-->>authMiddleware.js: Returns { role: 'admin' }
    authMiddleware.js-->>requestRoutes.js: next()
    deactivate authMiddleware.js

    requestRoutes.js->>validationMiddleware.js: 3. call validate(schema)
    activate validationMiddleware.js
    validationMiddleware.js-->>requestRoutes.js: next() (Data is valid)
    deactivate validationMiddleware.js

    requestRoutes.js->>requestController.js: 4. call createQuoteForRequest()
    activate requestController.js

    requestController.js->>Supabase: INSERT into quotes table
    activate Supabase
    Supabase-->>requestController.js: Confirms insert
    deactivate Supabase

    requestController.js->>Supabase: UPDATE requests table status
    activate Supabase
    Supabase-->>requestController.js: Confirms update
    deactivate Supabase

    requestController.js-->>server.js: Sends JSON response
    deactivate requestController.js
    deactivate requestRoutes.js

    server.js-->>Client: 201 Created (with quote data)
    deactivate server.js
```
### Sequence diagram AI Generates Follow-up Questions
```mermaid
sequenceDiagram
    participant Client
    participant server.js
    participant requestRoutes.js
    participant authMiddleware.js
    participant validationMiddleware.js
    participant requestController.js
    participant OpenAI_API as "OpenAI API (GPT-4)"

    Client->>server.js: POST /api/requests/gpt-follow-up (with answers & token)
    activate server.js

    server.js->>requestRoutes.js: Route request
    activate requestRoutes.js

    requestRoutes.js->>authMiddleware.js: 1. call authenticate()
    activate authMiddleware.js
    authMiddleware.js-->>requestRoutes.js: next() (User is valid)
    deactivate authMiddleware.js

    requestRoutes.js->>validationMiddleware.js: 2. call validate(schema)
    activate validationMiddleware.js
    validationMiddleware.js-->>requestRoutes.js: next() (Data is valid)
    deactivate validationMiddleware.js

    requestRoutes.js->>requestController.js: 3. call getGptFollowUp()
    activate requestController.js

    requestController.js->>OpenAI_API: axios.post to /v1/chat/completions
    activate OpenAI_API
    OpenAI_API-->>requestController.js: Returns follow-up questions
    deactivate OpenAI_API

    requestController.js-->>server.js: Sends JSON response { additionalQuestions: [...] }
    deactivate requestController.js
    deactivate requestRoutes.js

    server.js-->>Client: 200 OK (with questions array)
    deactivate server.js
```

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/config/supabase/database.js ---

// packages/backend/api/config/supabase/database.js
import { createClient } from '@supabase/supabase-js';
import path from 'path';
import dotenv from 'dotenv';

// In Netlify/production the environment variables are injected by the platform.
// For local development we try to load a .env file from the repository root.
// Avoid using `import.meta.url` here because some bundlers or runtime
// environments (Netlify Lambda) may not expose it in the bundled lambda,
// which causes fileURLToPath(undefined) runtime errors.
try {
  // Only attempt to load .env when the key env vars are missing (local dev)
  if (!process.env.SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
    // Try multiple likely .env locations so starting from different cwd works
    const candidatePaths = [
      path.resolve(process.cwd(), '.env'),
      path.resolve(process.cwd(), '..', '.env'),
      path.resolve(process.cwd(), '..', '..', '.env'),
    ];

    let loaded = false;
    for (const p of candidatePaths) {
      try {
        dotenv.config({ path: p });
        if (process.env.SUPABASE_URL || process.env.SUPABASE_SERVICE_ROLE_KEY) {
          loaded = true;
          break;
        }
      } catch (e) {
        // ignore and try next
      }
    }

    if (!loaded) {
      try {
        dotenv.config();
      } catch (e) {
        // eslint-disable-next-line no-console
        console.warn('Could not load .env using default dotenv behaviour');
      }
    }
  }
} catch (err) {
  // If anything goes wrong, continue and let the missing env vars be handled later.
  // eslint-disable-next-line no-console
  console.warn('Could not load .env from candidate paths:', err && err.message);
}

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseKey) {
  throw new Error("Supabase URL or Service Role Key is missing. Check Netlify environment variables.");
}

const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/config/supabase/index.js ---

// packages/backend/api/config/supabase/index.js

export { default as database } from './database.js';

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/controllers/followUpController.js ---

// packages/backend/api/controllers/followUpController.js

import { database as supabase } from '../config/supabase/index.js';
import { sendFollowUpEmail } from '../services/email/resend/index.js';

const sendFollowUpEmails = async (req, res) => {
  try {
    // 1. Fetch all requests with 'quoted' status
    const { data: requests, error: requestsError } = await supabase
      .from('requests')
      .select('*, user_profiles(*)')
      .eq('status', 'quoted');

    if (requestsError) throw requestsError;

    // 2. Filter requests that need a follow-up
    const requestsToFollowUp = requests.filter(request => {
      if (!request.last_follow_up_sent_at) {
        return true; // Send if never sent before
      }

      const threeDaysAgo = new Date();
      threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

      const lastSent = new Date(request.last_follow_up_sent_at);

      return lastSent < threeDaysAgo;
    });

    // 3. Send follow-up emails
    for (const request of requestsToFollowUp) {
      await sendFollowUpEmail(request);

      // 4. Update the last_follow_up_sent_at timestamp
      await supabase
        .from('requests')
        .update({ last_follow_up_sent_at: new Date() })
        .eq('id', request.id);
    }

    res.status(200).json({ message: `Follow-up emails sent to ${requestsToFollowUp.length} customers.` });
  } catch (error) {
    console.error('Error sending follow-up emails:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  }
};

export { sendFollowUpEmails };

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/controllers/invoiceController.js ---

// packages/backend/api/controllers/invoiceController.js

import { database as supabase } from '../config/supabase/index.js';
import { logger } from '../../src/lib/logger.js';

/**
 * Create a new invoice for a completed request
 */
export async function createInvoice(req, res) {
  try {
    const { requestId } = req.params;
    const { line_items, subtotal, tax_amount, total, due_date, notes, payment_method } = req.body;

    logger.log('üìÑ Creating invoice for request:', requestId);

    // Verify request exists and is completed
    const { data: request, error: requestError } = await supabase
      .from('requests')
      .select('id, status, user_id, invoice_id')
      .eq('id', requestId)
      .single();

    if (requestError || !request) {
      return res.status(404).json({ error: 'Request not found' });
    }

    if (request.status !== 'completed') {
      return res.status(400).json({ error: 'Can only create invoice for completed requests' });
    }

    if (request.invoice_id) {
      return res.status(400).json({ error: 'Invoice already exists for this request' });
    }

    // Create the invoice
    const { data: invoice, error: invoiceError } = await supabase
      .from('invoices')
      .insert({
        request_id: requestId,
        user_id: request.user_id,
        line_items: line_items,
        subtotal: subtotal,
        tax_amount: tax_amount,
        total: total,
        due_date: due_date,
        notes: notes,
        status: 'sent', // Invoices start as 'sent' (not draft)
        payment_method: payment_method || null
      })
      .select()
      .single();

    if (invoiceError) {
      console.error('‚ùå Error creating invoice:', invoiceError);
      return res.status(500).json({ error: 'Failed to create invoice' });
    }

    // Update request with invoice_id and change status to 'invoiced'
    const { error: updateError } = await supabase
      .from('requests')
      .update({
        invoice_id: invoice.id,
        status: 'invoiced'
      })
      .eq('id', requestId);

    if (updateError) {
      console.error('‚ùå Error updating request with invoice_id:', updateError);
      // Rollback: delete the invoice
      await supabase.from('invoices').delete().eq('id', invoice.id);
      return res.status(500).json({ error: 'Failed to link invoice to request' });
    }

    logger.log('‚úÖ Invoice created successfully:', invoice.id);
    res.status(201).json(invoice);

  } catch (error) {
    console.error('‚ùå Error in createInvoice:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Get a specific invoice
 */
export async function getInvoice(req, res) {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    // Check if user is admin (same pattern as getRequestById)
    const { data: userProfile } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('user_id', userId)
      .single();

    const isAdmin = userProfile?.role === 'admin';

    // Build query - use explicit FK join like requests do
    let query = supabase
      .from('invoices')
      .select('*');

    const { data: invoices, error } = await query.eq('id', id);

    if (error || !invoices || invoices.length === 0) {
      console.error('‚ùå Error fetching invoice:', error);
      return res.status(404).json({ error: 'Invoice not found' });
    }

    const invoice = invoices[0];

    // Fetch related request data separately (more reliable than join)
    if (invoice.request_id) {
      const { data: request } = await supabase
        .from('requests')
        .select('customer_name, service_address, user_id')
        .eq('id', invoice.request_id)
        .single();

      if (request) {
        invoice.requests = request;

        // Check permissions: admin or customer who owns the request
        if (!isAdmin && request.user_id !== userId) {
          return res.status(403).json({ error: 'Forbidden' });
        }
      }
    }

    res.json(invoice);

  } catch (error) {
    console.error('‚ùå Error in getInvoice:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Update an invoice (only if not paid)
 */
export async function updateInvoice(req, res) {
  try {
    const { id } = req.params;
    const { line_items, subtotal, tax_amount, total, due_date, notes, payment_method } = req.body;

    // Check current invoice status
    const { data: currentInvoice, error: fetchError } = await supabase
      .from('invoices')
      .select('status')
      .eq('id', id)
      .single();

    if (fetchError || !currentInvoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    if (currentInvoice.status === 'paid') {
      return res.status(400).json({ error: 'Cannot modify a paid invoice' });
    }

    // Update the invoice
    const { data: invoice, error: updateError } = await supabase
      .from('invoices')
      .update({
        line_items: line_items,
        subtotal: subtotal,
        tax_amount: tax_amount,
        total: total,
        due_date: due_date,
        notes: notes,
        payment_method: payment_method || null,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) {
      console.error('‚ùå Error updating invoice:', updateError);
      return res.status(500).json({ error: 'Failed to update invoice' });
    }

    logger.log('‚úÖ Invoice updated successfully:', id);
    res.json(invoice);

  } catch (error) {
    console.error('‚ùå Error in updateInvoice:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * Mark an invoice as paid
 */
export async function markInvoiceAsPaid(req, res) {
  try {
    const { id } = req.params;
    const { payment_method } = req.body;

    if (!payment_method) {
      return res.status(400).json({ error: 'Payment method is required' });
    }

    // Get current invoice and request
    const { data: invoice, error: fetchError } = await supabase
      .from('invoices')
      .select('*, requests(id)')
      .eq('id', id)
      .single();

    if (fetchError || !invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    if (invoice.status === 'paid') {
      return res.status(400).json({ error: 'Invoice is already paid' });
    }

    // Update invoice to paid
    const { data: updatedInvoice, error: updateError } = await supabase
      .from('invoices')
      .update({
        status: 'paid',
        paid_at: new Date().toISOString(),
        payment_method: payment_method,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();

    if (updateError) {
      console.error('‚ùå Error marking invoice as paid:', updateError);
      return res.status(500).json({ error: 'Failed to mark invoice as paid' });
    }

    // Update request status to 'paid'
    const { error: requestUpdateError } = await supabase
      .from('requests')
      .update({ status: 'paid' })
      .eq('id', invoice.request_id);

    if (requestUpdateError) {
      console.error('‚ùå Error updating request status to paid:', requestUpdateError);
    }

    logger.log('‚úÖ Invoice marked as paid:', id);
    res.json(updatedInvoice);

  } catch (error) {
    console.error('‚ùå Error in markInvoiceAsPaid:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

/**
 * List invoices (admin sees all, customers see their own)
 */
export async function listInvoices(req, res) {
  try {
    const userId = req.user.id;
    const isAdmin = req.user.role === 'admin';

    let query = supabase
      .from('invoices')
      .select('*, requests(customer_name, problem_category)')
      .order('created_at', { ascending: false });

    if (!isAdmin) {
      query = query.eq('user_id', userId);
    }

    const { data: invoices, error } = await query;

    if (error) {
      console.error('‚ùå Error fetching invoices:', error);
      return res.status(500).json({ error: 'Failed to fetch invoices' });
    }

    res.json(invoices);

  } catch (error) {
    console.error('‚ùå Error in listInvoices:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/controllers/requestController.js ---

// packages/backend/api/controllers/requestController.js
import path from 'path';
import axios from 'axios';
import { database as supabase } from '../config/supabase/index.js';
import { sendRequestSubmittedEmail, sendStatusUpdateEmail, sendQuoteAddedEmail } from '../services/email/resend/index.js';
import { sendNewRequestNotification, sendQuoteAcceptedNotification } from '../services/sms/twilio/index.js';
import { logger } from '../../src/lib/logger.js';

/**
 * Handles fetching all requests for admin dashboard or user's own requests.
 */
const getAllRequests = async (req, res, next) => {
  try {
    const userId = req.user.id;
    logger.log(`üîç GetAllRequests: Processing request for user ${userId}`);

    // Check if user is admin
    const { data: userProfile, error: profileError } = await supabase
      .from('user_profiles')
      .select('role, email')
      .eq('user_id', userId)
      .single();

    if (profileError) {
      console.warn(`‚ö†Ô∏è GetAllRequests: Profile lookup failed for user ${userId}:`, profileError.message);
      // If profile doesn't exist, treat as non-admin (only show own requests)
      logger.log(`‚ÑπÔ∏è GetAllRequests: Treating user ${userId} as non-admin due to missing profile`);
    }

    const isAdmin = userProfile?.role === 'admin';
    logger.log(`üîç GetAllRequests: User ${userId} is ${isAdmin ? 'admin' : 'non-admin'} (email: ${userProfile?.email || 'unknown'})`);

    let query = supabase
      .from('requests')
      .select(`*, user_profiles(name, email, phone), quote_attachments(*), quotes(*), request_notes(*)`)
      .order('created_at', { ascending: false });

    // If not admin, only show their own requests
    if (!isAdmin) {
      logger.log(`üîç GetAllRequests: Filtering to show only user ${userId}'s own requests`);
      query = query.eq('user_id', userId);
    } else {
      logger.log(`üîç GetAllRequests: Admin user - showing all requests`);
    }

    const { data: requests, error } = await query;

    if (error) {
      console.error('‚ùå Get All Requests Error:', error);
      return res.status(500).json({ error: 'Failed to fetch requests.' });
    }

    logger.log(`‚úÖ Fetched ${requests?.length || 0} requests for ${isAdmin ? 'admin' : 'user'} ${userId}`);
    res.json(requests || []);
  } catch (err) {
    console.error('‚ùå Get All Requests Exception:', err);
    next(err);
  }
};

/**
 * Handles fetching a request by ID, including user profile info and all related tables.
 */
const getRequestById = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    // Check if user is admin
    const { data: userProfile } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('user_id', userId)
      .single();

    const isAdmin = userProfile?.role === 'admin';

    let query = supabase
      .from('requests')
      .select(`*, user_profiles!requests_user_id_fkey(*), quote_attachments(*), quotes(*), request_notes(*)`);

    // If not admin, only show their own requests
    if (!isAdmin) {
      query = query.eq('user_id', userId);
    }

    // Get the specific request
    const { data: request, error } = await query
      .eq('id', id)
      .single();

    if (error || !request) {
      return res.status(404).json({ error: 'Request not found.' });
    }

    request.user_profiles = request.user_profiles || null;
    res.json(request);
  } catch (err) {
    next(err);
  }
};

/**
 * Handles getting AI follow-up questions from GPT using a robust JSON contract.
 */
const getGptFollowUp = async (req, res, next) => {
  try {
    const { clarifyingAnswers, category, problem_description } = req.body;
    const isOtherCategory = category === 'other';
    const ambiguousKeywords = ['weird', 'strange', 'not sure', 'something else', 'intermittent', 'help'];
    const hasAmbiguousKeywords = problem_description && ambiguousKeywords.some(keyword => problem_description.toLowerCase().includes(keyword));

    // Efficiency Check: If the request is for a standard category and lacks ambiguous keywords,
    // we can skip the AI call entirely, saving cost and latency.
    if (!isOtherCategory && !hasAmbiguousKeywords) {
      logger.log('[API EFFICIENCY] Skipping GPT-4 call for standard, clear request.');
      // Adhere to the contract even when skipping the call.
      return res.json({ requiresFollowUp: false, questions: [] });
    }

    // New, more robust prompt
const prompt = `
  You are an expert plumbing quote agent. Your task is to determine if more information is needed from a customer based on their answers.

  Analyze the conversation below for a "${category}" request:
  ${clarifyingAnswers.map((item) => `Q: ${item.question}\nA: ${item.answer}`).join('\n\n')}

  Based *only* on the information provided, decide if you have enough detail to provide a preliminary quote.
  - If the user's answers are clear and sufficient, no follow-up is needed.
  - If there is ambiguity or missing critical information (e.g., location of a leak, type of fixture), you must ask clarifying questions.

  Respond with a JSON object in the following format:
  {
    "requiresFollowUp": boolean,
    "questions": ["question 1", "question 2", ...]
  }

  If no questions are needed, "questions" should be an empty array.
`;

    // The API call is now more robust.
    const model = process.env.VITE_CHAT_GPT_QUOTE_AGENT_MODEL; // A model that reliably supports JSON mode
    const isGpt5Model = model?.startsWith('gpt-5');
    const isGpt4oModel = model?.startsWith('gpt-4o');

    let apiUrl, requestData;

    if (isGpt5Model) {
      // Use Responses API for GPT-5 models
      apiUrl = 'https://api.openai.com/v1/responses';
      requestData = {
        model: model,
        input: prompt,
        reasoning: { effort: "minimal" },
        text: { verbosity: "low" },
        max_output_tokens: 250,
        response_format: { type: 'json_object' }
      };
    } else {
      // Use Chat Completions API for older models
      apiUrl = 'https://api.openai.com/v1/chat/completions';
      requestData = {
        model: model,
        messages: [{ role: 'user', content: prompt }],
        response_format: { type: 'json_object' }
      };

      // Set max tokens parameter based on model type
      if (isGpt4oModel) {
        requestData.max_completion_tokens = 250;
      } else {
        requestData.max_tokens = 250;
      }

      // Add temperature for non-GPT-5 models
      requestData.temperature = 0.2;
    }

    const gptResponse = await axios.post(apiUrl,
      requestData,
      {
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        }
      }
    );

    // Extract content based on API type
    const replyContent = isGpt5Model
      ? gptResponse.data.output_text
      : gptResponse.data.choices[0].message.content;    // The parsing logic is now simple, safe, and reliable.
    try {
      const parsedJson = JSON.parse(replyContent);
      const additionalQuestions = (parsedJson.requiresFollowUp && Array.isArray(parsedJson.questions))
        ? parsedJson.questions
        : [];

      res.json({ additionalQuestions }); // The frontend expects `additionalQuestions` key

    } catch (parseError) {
      console.error("CRITICAL: Failed to parse JSON response from OpenAI:", replyContent, parseError);
      // Fail gracefully: If parsing fails, assume no questions and proceed.
      res.json({ additionalQuestions: [] });
    }

  } catch (err) {
    next(err);
  }
};

/**
 * Handles the final submission of a new quote request.
 */
const submitQuoteRequest = async (req, res, next) => {
  try {
    const {
      clarifyingAnswers,
      contactInfo,
      category,
      isEmergency,
      property_type,
      is_homeowner,
      problem_description,
      preferred_timing,
      additional_notes,
      service_address,
      latitude,
      longitude,
      geocoded_address
    } = req.body;


    const requestData = {
      user_id: req.user.id,
      customer_name: contactInfo.name || null,
      service_address: service_address || `${contactInfo.address || ''}, ${contactInfo.city || ''}, ${contactInfo.province || ''} ${contactInfo.postal_code || ''}`.trim() || null,
      contact_info: contactInfo.email || contactInfo.phone || null,
      problem_category: category,
      is_emergency: isEmergency === true,
      property_type: property_type || null,
      is_homeowner: is_homeowner === 'Yes',
      problem_description: problem_description || null,
      preferred_timing: preferred_timing || null,
      additional_notes: additional_notes || null,
      answers: clarifyingAnswers,
      status: 'new',
      latitude: latitude || null,
      longitude: longitude || null,
      geocoded_address: geocoded_address || null,
    };


    const { data, error } = await supabase.from('requests').insert(requestData).select().single();
    if (error) throw error;

    // Ensure we include the user's profile (name/email) so the email helper can resolve recipient
    const { data: userProfile } = await supabase
      .from('user_profiles')
      .select('name, email')
      .eq('user_id', req.user.id)
      .single();

    const requestWithProfile = { ...data, user_profiles: userProfile || null };

    // Log that we're about to attempt sending the request-submitted email.
    // Include minimal identifying info so we can trace the flow in logs.
    logger.log('üìß EMAIL DEBUG: Attempting to call sendRequestSubmittedEmail', {
      requestId: requestWithProfile.id,
      recipient: requestWithProfile.user_profiles?.email || null,
      userId: req.user.id
    });

    // Fire-and-forget the email send so failures don't block the API response.
    // Any errors are logged but won't fail the request submission.
    sendRequestSubmittedEmail(requestWithProfile)
      .then((result) => {
        if (result && result.error) {
          console.error('‚ùå EMAIL ERROR: sendRequestSubmittedEmail returned error for request', requestWithProfile.id, result.error);
        } else {
          logger.log('‚úÖ EMAIL INFO: sendRequestSubmittedEmail completed for request', requestWithProfile.id);
        }
      })
      .catch((emailErr) => {
        console.error('‚ùå EMAIL EXCEPTION: sendRequestSubmittedEmail threw for request', requestWithProfile.id, emailErr);
      });

    logger.log('üì± SMS DEBUG: About to call sendNewRequestNotification');
    try {
      sendNewRequestNotification(data);
      logger.log('üì± SMS DEBUG: sendNewRequestNotification called successfully');
    } catch (smsError) {
      console.error('üì± SMS DEBUG: sendNewRequestNotification failed:', smsError);
    }

    res.status(201).json({ message: 'Quote request submitted successfully.', request: data });
  } catch (err) {
    next(err);
  }
};

/**
 * Handles uploading file attachments and linking them to a request and/or a quote.
 */
const uploadAttachment = async (req, res, next) => {
  try {
    const { request_id, quote_id } = req.body;
    const files = req.files;

    if (!files || files.length === 0) {
      return res.status(400).json({ error: 'No files uploaded.' });
    }
    if (!request_id) {
      return res.status(400).json({ error: 'request_id is required.' });
    }

    const { data: requestOwner, error: ownerError } = await supabase
      .from('requests')
      .select('user_id')
      .eq('id', request_id)
      .single();

    if (ownerError) {
        return res.status(404).json({ error: 'Request not found.' });
    }

    const { data: profile } = await supabase.from('user_profiles').select('role').eq('user_id', req.user.id).single();

    if (profile?.role !== 'admin' && requestOwner.user_id !== req.user.id) {
        return res.status(403).json({ error: 'Forbidden: You do not have permission to upload files for this request.' });
    }

    const uploadPromises = files.map(async (file) => {
      const sanitizedFileName = file.originalname.replace(/\s/g, '_');
      const pathSegments = ['public', request_id];
      if (quote_id) {
        pathSegments.push(quote_id);
      }
      pathSegments.push(sanitizedFileName);
      const filePath = pathSegments.join('/');

      const { error: uploadError } = await supabase.storage
        .from('PlumbingPoCBucket')
        .upload(filePath, file.buffer, { contentType: file.mimetype, upsert: true });

      if (uploadError) {
        console.error('Supabase upload error:', uploadError);
        throw uploadError;
      }

      return {
        request_id,
        quote_id: quote_id || null,
        file_name: file.originalname,
        mime_type: file.mimetype,
        file_url: filePath
      };
    });

    const attachmentRecords = await Promise.all(uploadPromises);

    const { data: insertedAttachments, error: insertError } = await supabase
      .from('quote_attachments')
      .insert(attachmentRecords)
      .select();

    if (insertError) throw insertError;

    res.status(200).json({ message: 'Attachments uploaded successfully.', attachments: insertedAttachments });

  } catch (err) {
    next(err);
  }
};

/**
 * Handles retrieving a file from Supabase storage.
 */
const getStorageObject = async (req, res, next) => {
  try {
    const objectPath = req.params[0];
    const { data, error } = await supabase.storage.from('PlumbingPoCBucket').download(objectPath);

    if (error) {
      console.error('Supabase storage download error:', error.message);
      return res.status(403).json({ error: 'Forbidden: You do not have permission to access this file.' });
    }

    const fileName = path.basename(objectPath);
    res.setHeader('Content-Type', data.type || 'application/octet-stream');
    res.setHeader('Content-Disposition', `inline; filename="${fileName}"`);
    const buffer = Buffer.from(await data.arrayBuffer());
    res.send(buffer);
  } catch (err) {
    next(err);
  }
};

/**
 * Handles adding a note to a request from either a customer or admin.
 */
const addRequestNote = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { note } = req.body;
    const { user } = req;

    const { data: profile, error: profileError } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (profileError) throw profileError;

    const noteData = {
      request_id: id,
      user_id: user.id,
      note,
      author_role: profile.role === 'admin' ? 'admin' : 'customer',
    };

    const { data, error } = await supabase.from('request_notes').insert(noteData).select().single();
    if (error) throw error;

    res.status(201).json(data);
  } catch (err) {
    next(err);
  }
};

/**
 * Handles an admin creating a formal quote for a request.
 */
const createQuoteForRequest = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { quote_amount, details } = req.body;

    const { data: requestData, error: requestError } = await supabase
      .from('requests')
      // Fetch the request including the user profile so we can email the customer
      .select('*, user_profiles(*)')
      .eq('id', id)
      .single();
    if (requestError) throw requestError;

    const quoteData = {
      request_id: id,
      user_id: requestData.user_id,
      quote_amount,
      details,
      status: 'sent',
    };

    const { data: newQuote, error } = await supabase.from('quotes').insert(quoteData).select().single();
    if (error) throw error;

    await supabase.from('requests').update({ status: 'quoted' }).eq('id', id);

    // Ensure requestData includes user_profiles (some queries returned a slim object)
    const requestForEmail = requestData.user_profiles ? requestData : (await (async () => {
      const { data: fullRequest } = await supabase
        .from('requests')
        .select('*, user_profiles(*)')
        .eq('id', id)
        .single();
      return fullRequest || requestData;
    })());

    await sendQuoteAddedEmail(requestForEmail, newQuote);

    res.status(201).json(newQuote);
  } catch (err) {
    next(err);
  }
};

/**
 * Handles an admin updating an existing quote for a request.
 */
const updateQuote = async (req, res, next) => {
  try {
    const { id, quoteId } = req.params;
    const { quote_amount, details } = req.body;

    // First get the current quote to log its status
    const { data: currentQuote } = await supabase
      .from('quotes')
      .select('status')
      .eq('id', quoteId)
      .single();

    logger.log('updateQuote: Updating quote', { quoteId, currentStatus: currentQuote?.status });

    // Update quote details first
    const { data: updatedQuote, error } = await supabase
      .from('quotes')
      .update({
        quote_amount,
        details,
      })
      .eq('id', quoteId)
      .eq('request_id', id)
      .select()
      .single();

    if (error) {
      console.error('updateQuote: Error updating quote details', error);
      throw error;
    }
    if (!updatedQuote) return res.status(404).json({ error: 'Quote not found or does not belong to this request.' });

    // Then update the status separately
    logger.log('updateQuote: About to update quote status to sent');
    const { data: statusData, error: statusError } = await supabase
      .from('quotes')
      .update({ status: 'sent' })
      .eq('id', quoteId)
      .select('status')
      .single();

    if (statusError) {
      console.error('updateQuote: Error updating quote status', statusError);
      console.error('updateQuote: Status error details:', JSON.stringify(statusError, null, 2));
      // Don't throw here, the main update succeeded
    } else {
      logger.log('updateQuote: Quote status updated successfully', { newStatus: statusData?.status });
    }

    logger.log('updateQuote: Quote updated successfully', { quoteId, amount: updatedQuote.quote_amount });

    // Only revert status to 'quoted' if it was previously 'accepted'
    // This ensures that updating a quote reverts accepted quotes back to quoted status
    // since the new terms haven't been approved yet
    const { data: requestData, error: requestError } = await supabase
      .from('requests')
      .select('status')
      .eq('id', id)
      .single();

    if (requestError) throw requestError;

    if (requestData.status === 'accepted') {
      await supabase.from('requests').update({ status: 'quoted' }).eq('id', id);
    }

    res.status(200).json(updatedQuote);
  } catch (err) {
    console.error('updateQuote: Error in updateQuote controller:', err);
    next(err);
  }
};

/**
 * Handles accepting a specific quote using an atomic database function.
 * This is the corrected and robust implementation.
 */
const acceptQuote = async (req, res, next) => {
  try {
    const { id, quoteId } = req.params;
    const userId = req.user.id;

    logger.log('acceptQuote: Starting atomic quote acceptance', { requestId: id, quoteId, userId });

    // 1. Verify user has permission (ownership check for non-admins)
    const { data: userProfile } = await supabase.from('user_profiles').select('role').eq('user_id', userId).single();
    if (!userProfile) return res.status(403).json({ error: 'Profile not found.' });

    if (userProfile.role !== 'admin') {
      const { data: requestOwner, error: ownerError } = await supabase.from('requests').select('user_id').eq('id', id).single();
      if (ownerError || !requestOwner) return res.status(404).json({ error: 'Request not found.' });
      if (requestOwner.user_id !== userId) return res.status(403).json({ error: 'Permission denied.' });
    }
    logger.log(`acceptQuote: Permission verified for user ${userId} (role: ${userProfile.role})`);

    // 2. Perform the atomic updates directly
    logger.log('acceptQuote: Performing atomic quote acceptance updates...');

    // Update the selected quote to 'accepted'
    const { error: acceptError } = await supabase
      .from('quotes')
      .update({ status: 'accepted' })
      .eq('id', quoteId)
      .eq('request_id', id);

    if (acceptError) {
      console.error('acceptQuote: Failed to accept quote', acceptError);
      throw acceptError;
    }

    // Update all other quotes for this request to 'rejected'
    const { error: rejectError } = await supabase
      .from('quotes')
      .update({ status: 'rejected' })
      .eq('request_id', id)
      .neq('id', quoteId);

    if (rejectError) {
      console.error('acceptQuote: Failed to reject other quotes', rejectError);
      throw rejectError;
    }

    // Update the request status to 'accepted'
    const { error: requestError } = await supabase
      .from('requests')
      .update({ status: 'accepted' })
      .eq('id', id);

    if (requestError) {
      console.error('acceptQuote: Failed to update request status', requestError);
      throw requestError;
    }

    logger.log('acceptQuote: All updates completed successfully.');

    // 3. Fetch data needed for notifications
    const { data: notificationRequestData, error: notificationRequestError } = await supabase
      .from('requests').select('*, user_profiles(name)').eq('id', id).single();

    const { data: quoteData, error: quoteError } = await supabase
      .from('quotes').select('quote_amount').eq('id', quoteId).single();

    // 4. Send notifications
    if (notificationRequestError || quoteError) {
      console.error("Could not fetch data for notifications, but quote was accepted.", { notificationRequestError, quoteError });
    } else if (notificationRequestData && quoteData) {
      await sendStatusUpdateEmail(notificationRequestData);
      sendQuoteAcceptedNotification(notificationRequestData, quoteData);
    }

    // 5. Send success response
    res.status(200).json({ message: 'Quote accepted successfully.' });

  } catch (err) {
    console.error('acceptQuote: An error occurred in the controller', err);
    next(err);
  }
};

/**
 * Handles marking a request as viewed by the user.
 */
const markRequestAsViewed = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;

    // Atomically update the status to 'viewed' ONLY IF it is currently 'quoted'.
    // This prevents overwriting other statuses. We also ensure the user owns the request.
    const { data, error } = await supabase
      .from('requests')
      .update({ status: 'viewed' })
      .eq('id', id)
      .eq('user_id', userId)
      .eq('status', 'quoted') // This is the critical condition
      .select()
      .single();

    if (error && error.code !== 'PGRST116') { // Ignore 'no rows returned' error
      throw error;
    }

    // It's not an error if nothing was updated (e.g., status was already 'viewed').
    res.status(200).json({ message: 'Request marked as viewed where applicable.' });
  } catch (err) {
    next(err);
  }
};

/**
 * Handles updating a request (general update for address, etc.).
 */
const updateRequest = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    // Only allow updating specific fields for security
    const allowedFields = ['service_address', 'latitude', 'longitude', 'geocoded_address'];
    const filteredUpdateData = {};

    for (const field of allowedFields) {
      if (updateData[field] !== undefined) {
        filteredUpdateData[field] = updateData[field];
      }
    }

    if (Object.keys(filteredUpdateData).length === 0) {
      return res.status(400).json({ error: 'No valid fields to update.' });
    }

    const { data, error } = await supabase
      .from('requests')
      .update(filteredUpdateData)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    if (!data) return res.status(404).json({ error: 'Request not found.' });

    res.status(200).json(data);
  } catch (err) {
    next(err);
  }
};

/**
 * Handles cleanup of test data (admin only, highly secured)
 * Only deletes records matching specific test patterns
 */
const cleanupTestData = async (req, res, next) => {
  try {
    // SECURITY: Only admins can access this endpoint
    const userId = req.user.id;
    const { data: userProfile } = await supabase
      .from('user_profiles')
      .select('role, email')
      .eq('user_id', userId)
      .single();

    if (userProfile?.role !== 'admin') {
      return res.status(403).json({
        error: 'Admin access required for cleanup operations.',
        user: userProfile?.email
      });
    }

    // SECURITY: Dry-run by default for safety
    const { dryRun = true, confirmDelete = false } = req.body;
    const isDryRun = dryRun === true || dryRun === 'true';

    // SECURITY: Require explicit confirmation for actual deletion
    if (!isDryRun && !confirmDelete) {
      return res.status(400).json({
        error: 'Must set confirmDelete=true in request body for actual deletion'
      });
    }

    // SECURITY: Only allow in non-production or with test header
    const isProduction = process.env.NODE_ENV === 'production';
    const hasTestHeader = req.headers['x-test-mode'] === 'true';

    if (isProduction && !hasTestHeader) {
      return res.status(403).json({
        error: 'Cleanup operations disabled in production environment without test header'
      });
    }

    // Define VERY SPECIFIC test data patterns (not wildcards)
    const testPatterns = {
      addresses: [
        '%Test St%',
        '%V1V1V1%',
        '%Admin Test%',
        '%Test Address%'
      ],
      // Could add more patterns as needed
    };

    const results = {
      dryRun: isDryRun,
      adminUser: userProfile.email,
      environment: process.env.NODE_ENV,
      identified: [],
      deleted: {
        requests: 0,
        quotes: 0,
        attachments: 0,
        notes: 0
      }
    };

    // Find test requests by address patterns
    for (const addressPattern of testPatterns.addresses) {
      const { data: testRequests, error } = await supabase
        .from('requests')
        .select('id, service_address, customer_name, created_at')
        .ilike('service_address', addressPattern);

      if (error) {
        console.error('Error finding test requests by address:', error);
        continue;
      }

      if (testRequests && testRequests.length > 0) {
        results.identified.push(...testRequests.map(r => ({
          id: r.id,
          address: r.service_address,
          name: r.customer_name,
          created: r.created_at
        })));

        if (!isDryRun) {
          // Delete associated data first (cascade delete for safety)
          for (const request of testRequests) {
            // Delete quotes
            const { data: quotes } = await supabase
              .from('quotes')
              .delete()
              .eq('request_id', request.id)
              .select();
            if (quotes) results.deleted.quotes += quotes.length;

            // Delete attachments
            const { data: attachments } = await supabase
              .from('quote_attachments')
              .delete()
              .eq('request_id', request.id)
              .select();
            if (attachments) results.deleted.attachments += attachments.length;

            // Delete notes
            const { data: notes } = await supabase
              .from('request_notes')
              .delete()
              .eq('request_id', request.id)
              .select();
            if (notes) results.deleted.notes += notes.length;
          }

          // Finally delete the requests
          const { data: deletedRequests, error: deleteError } = await supabase
            .from('requests')
            .delete()
            .ilike('service_address', addressPattern)
            .select();

          if (deleteError) {
            console.error('Error deleting test requests:', deleteError);
            return res.status(500).json({ error: 'Failed to delete test requests' });
          }

          if (deletedRequests) {
            results.deleted.requests += deletedRequests.length;
          }
        }
      }
    }

    // AUDIT LOGGING: Log all cleanup operations
    logger.log(`üßπ TEST DATA CLEANUP ${isDryRun ? 'DRY RUN' : 'EXECUTED'}:`, {
      admin: userProfile.email,
      environment: process.env.NODE_ENV,
      identified: results.identified.length,
      deleted: results.deleted,
      patterns: testPatterns
    });

    const message = isDryRun
      ? `Found ${results.identified.length} test records (dry run - no deletion)`
      : `Successfully deleted ${results.deleted.requests} test records and ${results.deleted.quotes + results.deleted.attachments + results.deleted.notes} related items`;

    res.json({
      success: true,
      message,
      ...results
    });

  } catch (err) {
    console.error('‚ùå Test data cleanup error:', err);
    next(err);
  }
};

/**
 * Handles an admin deleting a draft quote (only if not accepted).
 */
const deleteQuote = async (req, res, next) => {
  try {
    const { id, quoteId } = req.params;

    // First check if the quote exists and is not accepted
    const { data: quote, error: fetchError } = await supabase
      .from('quotes')
      .select('status')
      .eq('id', quoteId)
      .eq('request_id', id)
      .single();

    if (fetchError) throw fetchError;
    if (!quote) return res.status(404).json({ error: 'Quote not found.' });

    // Only allow deletion if the quote is not accepted
    if (quote.status === 'accepted') {
      return res.status(400).json({ error: 'Cannot delete an accepted quote. Cancel the request instead.' });
    }

    // Delete the quote
    const { error: deleteError } = await supabase
      .from('quotes')
      .delete()
      .eq('id', quoteId)
      .eq('request_id', id);

    if (deleteError) throw deleteError;

    res.status(200).json({ message: 'Quote deleted successfully.' });
  } catch (err) {
    next(err);
  }
};

/**
 * Handles an admin updating the status of a request.
 */
const updateRequestStatus = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { status, scheduled_start_date } = req.body;

    logger.log('updateRequestStatus called:', { id, status, scheduled_start_date });

    const updatePayload = { status };
    if (scheduled_start_date) {
        updatePayload.scheduled_start_date = new Date(scheduled_start_date).toISOString();
    }

    logger.log('updatePayload:', updatePayload);

    // Return the updated request including user_profiles so notification helpers can find the recipient
    const { data, error } = await supabase
      .from('requests')
      .update(updatePayload)
      .eq('id', id)
      .select('*, user_profiles(*)')
      .single();

    if (error) {
      console.error('Supabase update error:', error);
      throw error;
    }
    if (!data) return res.status(404).json({ error: 'Request not found.' });

    await sendStatusUpdateEmail(data);

    res.status(200).json(data);
  } catch (err) {
    console.error('updateRequestStatus error:', err);
    next(err);
  }
};

export {
  getGptFollowUp,
  submitQuoteRequest,
  uploadAttachment,
  getStorageObject,
  addRequestNote,
  createQuoteForRequest,
  getAllRequests,
  getRequestById,
  updateRequest,
  updateQuote,
  deleteQuote,
  acceptQuote,
  updateRequestStatus,
  markRequestAsViewed,
  cleanupTestData,
};

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/controllers/triageController.js ---

// packages/backend/api/controllers/triageController.js

import { database as supabase } from '../config/supabase/index.js';
import { logger } from '../../src/lib/logger.js';

// Call the triage-agent as a separate Netlify function for proper logging
async function runTriageAnalysis(requestData) {
  const isNetlify = process.env.NETLIFY == true; // Netlify sets this to boolean true

  if (isNetlify) {
    // In production, call the triage-agent as a separate function
    const response = await fetch('/.netlify/functions/triage-agent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestData),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Triage analysis failed');
    }

    return await response.json();
  } else {
    // In local development, import and call directly
    const { handler } = await import('../../netlify/functions/triage-agent.mjs');

    // Create a mock Netlify event
    const event = {
      httpMethod: 'POST',
      body: JSON.stringify(requestData)
    };

    const result = await handler(event, {});
    const analysis = JSON.parse(result.body);

    if (result.statusCode !== 200) {
      throw new Error(analysis.error || 'Triage analysis failed');
    }

    return analysis;
  }
}

const triageRequest = async (req, res) => {
  const {requestId} = req.params;

  try {
    // 1. Fetch the request details
    const {data: request, error: requestError} = await supabase
      .from('requests')
      .select('*')
      .eq('id', requestId)
      .single();

    if (requestError) throw requestError;

    logger.log('[TriageController] Running AI triage analysis for request:', requestId);

    // 2. Use the intelligent triage agent
    const analysis = await runTriageAnalysis(request);

    // 3. Update the request in the database
    const {error: updateError} = await supabase
      .from('requests')
      .update({
        triage_summary: analysis.triage_summary,
        priority_score: analysis.priority_score,
        priority_explanation: analysis.priority_explanation,
        profitability_score: analysis.profitability_score,
        profitability_explanation: analysis.profitability_explanation,
        required_expertise: analysis.required_expertise
      })
      .eq('id', requestId);

    if (updateError) throw updateError;

    logger.log('[TriageController] Triage analysis completed:', {
      requestId,
      priority: analysis.priority_score,
      profitability: analysis.profitability_score
    });

    res.status(200).json({
      message: 'Triage complete.',
      ...analysis
    });
  } catch (error) {
    console.error('[TriageController] Error during triage:', error);
    res.status(500).json({
      message: 'Internal Server Error',
      error: error.message
    });
  }
};

const updateRequestTriage = async (requestId, triageData) => {
  try {
    const {error: updateError} = await supabase
      .from('requests')
      .update({
        triage_summary: triageData.triage_summary,
        priority_score: triageData.priority_score,
        priority_explanation: triageData.priority_explanation,
        profitability_score: triageData.profitability_score,
        profitability_explanation: triageData.profitability_explanation,
        required_expertise: triageData.required_expertise
      })
      .eq('id', requestId);

    if (updateError) throw updateError;

    return { success: true };
  } catch (error) {
    console.error('Error updating triage:', error);
    throw error;
  }
};

export { triageRequest, updateRequestTriage };

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/controllers/userController.js ---

// packages/backend/api/controllers/userController.js

import { database as supabase } from '../config/supabase/index.js';

/**
 * Handles fetching the profile for the currently authenticated user.
 */
const getUserProfile = async (req, res, next) => {
  try {
    const { user } = req; // From the `authenticate` middleware
    const { data, error } = await supabase
      .from('user_profiles')
      .select('*')
      .eq('user_id', user.id)
      .single();

    if (error) {
      return res.status(400).json({ error: error.message });
    }
    if (!data) {
      return res.status(404).json({ error: 'Profile not found for the current user.' });
    }
    res.status(200).json(data);
  } catch (err) {
    next(err);
  }
};

/**
 * Handles updating the profile for the currently authenticated user.
 */
const updateUserProfile = async (req, res, next) => {
  try {
    const { user } = req; // From the `authenticate` middleware
    const profileData = req.body;

    // Ensure the user can only update their own profile
    const { data, error } = await supabase
      .from('user_profiles')
      .update(profileData)
      .eq('user_id', user.id)
      .select()
      .single();

    if (error) {
      // If RLS prevents the update, Supabase might return an error
      // or simply an empty data array. We handle both.
      if (error.code === 'PGRST204') { // No content, RLS might have blocked it
        return res.status(404).json({ error: 'Profile not found or permission denied.' });
      }
      throw error;
    }

    if (!data) {
      return res.status(404).json({ error: 'Profile not found for the current user.' });
    }

    res.status(200).json(data);
  } catch (err) {
    next(err);
  }
};

/**
 * Handles creating the profile for the currently authenticated user.
 */
const createUserProfile = async (req, res, next) => {
  try {
    const { user } = req; // From the `authenticate` middleware
    const profileData = req.body;
    // Attach user_id to profileData
    profileData.user_id = user.id;

    // Insert new profile
    const { data, error } = await supabase
      .from('user_profiles')
      .insert([profileData])
      .select()
      .single();

    if (error) {
      return res.status(400).json({ error: error.message });
    }
    res.status(201).json(data);
  } catch (err) {
    next(err);
  }
};

export {
  updateUserProfile,
  createUserProfile,
  getUserProfile,
};

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/middleware/authMiddleware.js ---

// packages/backend/api/middleware/authMiddleware.js
import { createClient } from '@supabase/supabase-js';
import { database as supabase } from '../config/supabase/index.js';

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Supabase URL or Anon Key is missing. Check environment variables.");
}

const supabaseAuth = createClient(supabaseUrl, supabaseAnonKey);

/**
 * Middleware to verify a user's JWT token from the Authorization header.
 * Attaches the authenticated user object to the request.
 */
const authenticate = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized: Missing JWT token.' });
  }
  const token = authHeader.split(' ')[1];

  try {
    // This function uses the supabaseAuth client (initialized with SUPABASE_ANON_KEY)
    // for token validation. This is the correct and secure way to validate user tokens.
    const { data: { user }, error } = await supabaseAuth.auth.getUser(token);
    if (error || !user) {
      throw new Error('Unauthorized: Invalid token.');
    }
    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ error: error.message });
  }
};

/**
 * Middleware to ensure the authenticated user has the 'admin' role.
 * Must be used AFTER the authenticate middleware.
 */
const isAdmin = async (req, res, next) => {
  // Ensure we have a user from the previous `authenticate` middleware
  if (!req.user) {
    return res.status(401).json({ error: 'Authentication required.' });
  }

  try {
    // This function uses the main supabase client (initialized with SUPABASE_SERVICE_ROLE_KEY)
    // to fetch the user's profile and check their role. This might be intended to bypass RLS
    // if necessary for role checking, as it has elevated privileges.
    const { data: profile, error } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('user_id', req.user.id)
      .single();

    if (error) {
        // This could happen if the profile doesn't exist yet, which is a valid state.
        // We treat it as non-admin.
        console.warn(`Could not fetch profile for user ${req.user.id}:`, error.message);
        return res.status(403).json({ error: 'Forbidden: Admin access required.' });
    }

    if (!profile || profile.role !== 'admin') {
      return res.status(403).json({ error: 'Forbidden: Admin access required.' });
    }

    // User is an admin, proceed to the next handler
    next();
  } catch (error) {
      next(error); // Pass unexpected errors to the global handler
  }
};

export {
  authenticate,
  isAdmin,
};

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/middleware/validationMiddleware.js ---

// /middleware/validationMiddleware.js
/*
This file creates a generic, reusable middleware function.
Instead of writing validation logic inside every controller,
we use this function to check an incoming request against a
zod schema. If the data is bad, it stops the request and sends
a helpful error. If the data is good, it passes the request on to the controller.
*/
/**
 * A generic middleware factory for validating requests against a Zod schema.
 * @param {object} schema - The Zod schema to validate against.
 * @returns {function} An Express middleware function.
 */
const validate = (schema) => (req, res, next) => {
  try {
    // Zod's parse method will throw an error if validation fails.
    schema.parse({
      body: req.body,
      query: req.query,
      params: req.params,
    });
    // If we reach here, validation was successful.
    next();
  } catch (error) {
    // Zod errors are rich with detail, which we can send to the client.
    res.status(400).json({
      error: 'Validation failed',
      details: error.errors, // This provides an array of specific field errors
    });
  }
};

export { validate };

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/routes/agentRoutes.js ---

// packages/backend/api/routes/agentRoutes.js
// Routes for OpenAI Agent Toolkit integration

import express from 'express';
import { submitQuoteRequest } from '../controllers/requestController.js';
import { updateRequestTriage } from '../controllers/triageController.js';
import { logger } from '../../src/lib/logger.js';

const router = express.Router();

// Temporary local development proxy - calls Netlify function directly
// TODO: Remove this when using Netlify Dev for local development
router.post('/quote/run', async (req, res) => {
  try {
    // Dynamically import the Netlify function handler
    const { handler } = await import('../../netlify/functions/quote-agent.mjs');

    // Transform Express request to Netlify function event format
    const event = {
      httpMethod: 'POST',
      body: JSON.stringify(req.body),
      headers: req.headers
    };

    // Call the handler
    const result = await handler(event, {});

    // Send response
    res.status(result.statusCode).json(JSON.parse(result.body));
  } catch (error) {
    console.error('Quote agent proxy error:', error);
    res.status(500).json({ error: 'Agent execution failed', details: error.message });
  }
});

// Agent action: Submit quote request
router.post('/submit-quote', async (req, res) => {
  try {
    logger.log('Agent submitting quote request:', req.body);

    // Transform agent data to match our API format
    const requestData = {
      clarifyingAnswers: req.body.clarifyingAnswers || [],
      contactInfo: req.body.contactInfo || {},
      category: req.body.category || '',
      isEmergency: req.body.isEmergency || false,
      problem_description: req.body.problem_description || '',
      preferred_timing: req.body.preferred_timing || '',
      property_type: req.body.property_type || '',
      is_homeowner: req.body.is_homeowner || false,
      service_address: req.body.service_address || '',
      latitude: req.body.latitude || null,
      longitude: req.body.longitude || null,
      geocoded_address: req.body.geocoded_address || null
    };

    // Use existing controller logic
    const result = await submitQuoteRequest(req.body.userId, requestData);

    res.json({
      success: true,
      requestId: result.request?.id,
      message: 'Quote request submitted successfully'
    });
  } catch (error) {
    console.error('Agent quote submission error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to submit quote request'
    });
  }
});

// Agent action: Update request triage
router.post('/update-triage/:requestId', async (req, res) => {
  try {
    logger.log('Agent updating triage for request:', req.params.requestId, req.body);

    const triageData = {
      triage_summary: req.body.triage_summary,
      priority_score: req.body.priority_score,
      priority_explanation: req.body.priority_explanation,
      profitability_score: req.body.profitability_score,
      profitability_explanation: req.body.profitability_explanation
    };

    await updateRequestTriage(req.params.requestId, triageData);

    res.json({
      success: true,
      message: 'Triage updated successfully'
    });
  } catch (error) {
    console.error('Agent triage update error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update triage'
    });
  }
});

// Agent action: Fetch request details
router.get('/request/:requestId', async (req, res) => {
  try {
    // This would use existing request fetching logic
    // For now, return mock data for agent testing
    res.json({
      id: req.params.requestId,
      problem_category: 'leak_repair',
      answers: [
        { question: 'Where is the leak?', answer: 'Under the kitchen sink' },
        { question: 'Is water actively leaking?', answer: 'Yes' }
      ],
      is_emergency: false,
      created_at: new Date().toISOString()
    });
  } catch (error) {
    console.error('Agent request fetch error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch request'
    });
  }
});

// Agent tool: Assess leak severity
router.post('/tools/assess-leak-severity', async (req, res) => {
  try {
    const { leak_description, drip_rate } = req.body;

    const severity = drip_rate?.includes('steady stream') ? 'high' :
                   drip_rate?.includes('drip') ? 'medium' : 'low';

    res.json({
      severity,
      urgency: severity === 'high' ? 'immediate' : severity === 'medium' ? 'within 24 hours' : 'schedule soon',
      estimated_cost_range: severity === 'high' ? '$200-500' : severity === 'medium' ? '$100-300' : '$50-150'
    });
  } catch (error) {
    console.error('Leak assessment tool error:', error);
    res.status(500).json({ error: 'Tool execution failed' });
  }
});

// Agent tool: Check emergency status
router.post('/tools/check-emergency-status', async (req, res) => {
  try {
    const { leak_location, water_flow, property_type } = req.body;

    const isEmergency = water_flow.includes('actively') ||
                      leak_location.includes('ceiling') ||
                      leak_location.includes('wall');

    res.json({
      is_emergency: isEmergency,
      recommended_response_time: isEmergency ? 'within 2 hours' : 'schedule appointment',
      reason: isEmergency ? 'Risk of significant water damage' : 'Can be scheduled normally'
    });
  } catch (error) {
    console.error('Emergency check tool error:', error);
    res.status(500).json({ error: 'Tool execution failed' });
  }
});

// Agent tool: Analyze water heater issues
router.post('/tools/analyze-water-heater-issue', async (req, res) => {
  try {
    const { symptoms, system_age, system_type } = req.body;

    const age = system_age || 0;
    const shouldReplace = age > 10 || symptoms.includes('no hot water') || symptoms.includes('leaking');

    res.json({
      recommended_action: shouldReplace ? 'replacement' : 'repair',
      estimated_cost: shouldReplace ? '$800-2500' : '$200-800',
      reasoning: shouldReplace ?
        'Age and symptoms suggest replacement is more cost-effective' :
        'Issue appears repairable for now'
    });
  } catch (error) {
    console.error('Water heater analysis tool error:', error);
    res.status(500).json({ error: 'Tool execution failed' });
  }
});

export default router;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/routes/followUpRoutes.js ---

// packages/backend/api/routes/followUpRoutes.js
//
// FOLLOW-UP ROUTES - Automated Customer Communication
//
// This file defines routes for automated follow-up email campaigns to customers
// with outstanding quotes, helping improve response rates and conversion.
//
// ARCHITECTURE:
// - Single POST endpoint to trigger follow-up campaigns
// - Admin-only access for controlled execution
// - Processes all requests in 'quoted' status
// - Sends personalized emails via Resend service
//
// DEPLOYMENT:
// - In development: runs as Express server at http://localhost:3000/api/follow-up/*
// - In production: deployed as Netlify Function via /.netlify/functions/api/*
// - Mounted at '/api/follow-up' in server.js
//
// EMAIL CAMPAIGN LOGIC:
// - Finds all requests with status='quoted' (customer has quote but hasn't responded)
// - Sends follow-up emails with quote details and call-to-action
// - Tracks email delivery and engagement
// - Updates request records with follow-up timestamps
//
// INTEGRATIONS:
// - Resend API for email delivery (RESEND_API_KEY required)
// - Email templates defined in packages/backend/api/services/email/resend/client.js
// - SMS notifications may be sent alongside emails
//
// SECURITY:
// - Requires admin authentication
// - Should be rate-limited to prevent spam
// - Email content is templated and safe

import express from 'express';
import { sendFollowUpEmails } from '../controllers/followUpController.js';
import { authenticate, isAdmin } from '../middleware/authMiddleware.js';

const router = express.Router();

// @route   POST /api/follow-up/send
// @desc    Send follow-up emails to customers with quoted requests
// @access  Admin
router.post('/send', authenticate, isAdmin, sendFollowUpEmails);

export default router;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/routes/invoiceRoutes.js ---

// packages/backend/api/routes/invoiceRoutes.js

import { Router } from 'express';
import { authenticate, isAdmin } from '../middleware/authMiddleware.js';
import {
  createInvoice,
  getInvoice,
  updateInvoice,
  markInvoiceAsPaid,
  listInvoices
} from '../controllers/invoiceController.js';

const router = Router();

/**
 * @route   POST /api/requests/:requestId/invoices
 * @desc    Create a new invoice for a completed request
 * @access  Admin only
 */
router.post('/requests/:requestId/invoices', authenticate, isAdmin, createInvoice);

/**
 * @route   GET /api/invoices/:id
 * @desc    Get a specific invoice
 * @access  Admin or customer who owns the request
 */
router.get('/invoices/:id', authenticate, getInvoice);

/**
 * @route   PATCH /api/invoices/:id
 * @desc    Update an invoice (only if status is not 'paid')
 * @access  Admin only
 */
router.patch('/invoices/:id', authenticate, isAdmin, updateInvoice);

/**
 * @route   POST /api/invoices/:id/mark-paid
 * @desc    Mark an invoice as paid
 * @access  Admin only
 */
router.post('/invoices/:id/mark-paid', authenticate, isAdmin, markInvoiceAsPaid);

/**
 * @route   GET /api/invoices
 * @desc    List all invoices (admin sees all, customers see their own)
 * @access  Authenticated users
 */
router.get('/invoices', authenticate, listInvoices);

export default router;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/routes/requestRoutes.js ---

// packages/backend/api/routes/requestRoutes.js
//
// REQUEST ROUTES - Express Router for Plumbing Quote Request Management
//
// This file defines all HTTP routes for the plumbing quote request system.
// Routes are organized into logical sections and mounted at '/api/requests' in server.js.
//
// ARCHITECTURE:
// - Express Router handles route definitions and middleware
// - Routes are grouped by functionality (quote intake, admin operations, etc.)
// - Middleware: authentication, admin checks, input validation
// - Controllers handle business logic, this file only defines endpoints
//
// DEPLOYMENT:
// - In development: runs as Express server at http://localhost:3000/api/requests/*
// - In production: deployed as Netlify Function, routes via /.netlify/functions/api/*
// - Netlify redirects /api/* to the function with path parameters
//
// MIDDLEWARE CHAIN:
// 1. authenticate - verifies JWT token and attaches user to req.user
// 2. isAdmin - checks if user has admin role (for admin-only routes)
// 3. validate(schema) - validates request body against Joi schema
// 4. controller - handles the actual business logic
//
// SECURITY:
// - All routes require authentication
// - Admin routes have additional isAdmin middleware
// - Input validation prevents malformed requests
// - File uploads use memory storage (no disk writes in serverless)

import express from 'express';
import multer from 'multer';
import {
  getGptFollowUp,
  submitQuoteRequest,
  uploadAttachment,
  getStorageObject,
  addRequestNote,
  createQuoteForRequest,
  getAllRequests,
  getRequestById,
  updateRequest,
  updateQuote,
  deleteQuote,
  acceptQuote,
  updateRequestStatus,
  markRequestAsViewed,
  cleanupTestData,
} from '../controllers/requestController.js';
import { authenticate, isAdmin } from '../middleware/authMiddleware.js';
import { validate } from '../middleware/validationMiddleware.js';
import {
  gptRequestSchema,
  submitQuoteSchema,
  addNoteSchema,
  createQuoteSchema,
  updateQuoteSchema,
  getObjectSchema,
  updateStatusSchema,
} from '../validation/schemas.js';

const router = express.Router();
const upload = multer({ storage: multer.memoryStorage() });

// --- Core Quote Intake Routes ---

router.post('/gpt-follow-up', authenticate, validate(gptRequestSchema), getGptFollowUp);
router.post('/submit', authenticate, validate(submitQuoteSchema), submitQuoteRequest);

// --- SMS Test Route (moved to root level) ---
router.post('/attachments', authenticate, upload.array('attachment', 10), uploadAttachment);
router.get('/storage-object/*', authenticate, validate(getObjectSchema), getStorageObject);

// --- Client Portal & Admin Routes ---
router.get('/', authenticate, getAllRequests); // Get all requests for admin table
router.get('/new-request', authenticate, getAllRequests); // Temporary route for frontend bug
router.get('/debug-auth', authenticate, (req, res) => {
  res.json({
    userId: req.user.id,
    email: req.user.email,
    timestamp: new Date().toISOString(),
    message: 'Authentication successful'
  });
}); // Debug endpoint for auth issues
router.patch('/:id', authenticate, updateRequest); // Update request (address, etc.)
router.patch('/:id/viewed', authenticate, markRequestAsViewed); // Mark request as viewed by user
router.delete('/cleanup-test-data', authenticate, isAdmin, cleanupTestData); // Admin cleanup of test data
router.post('/:id/notes', authenticate, validate(addNoteSchema), addRequestNote);
router.patch('/:id/status', authenticate, isAdmin, validate(updateStatusSchema), updateRequestStatus);
router.put('/:id/status', authenticate, isAdmin, validate(updateStatusSchema), updateRequestStatus); // Legacy support
router.post('/:id/quotes', authenticate, isAdmin, validate(createQuoteSchema), createQuoteForRequest);
router.put('/:id/quotes/:quoteId', authenticate, isAdmin, validate(updateQuoteSchema), updateQuote);
router.delete('/:id/quotes/:quoteId', authenticate, isAdmin, deleteQuote);
router.post('/:id/quotes/:quoteId/accept', authenticate, acceptQuote);
router.get('/:id', authenticate, getRequestById);

export default router;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/routes/triageRoutes.js ---

// packages/backend/api/routes/triageRoutes.js
//
// TRIAGE ROUTES - AI-Powered Request Analysis
//
// This file defines routes for AI-powered triage functionality that analyzes
// plumbing requests to generate priority scores and profitability assessments.
//
// ARCHITECTURE:
// - Single POST endpoint for request triage
// - Admin-only access to prevent abuse
// - Calls OpenAI API for intelligent analysis
// - Updates request records with AI-generated scores
//
// DEPLOYMENT:
// - In development: runs as Express server at http://localhost:3000/api/triage/*
// - In production: deployed as Netlify Function via /.netlify/functions/api/*
// - Mounted at '/api/triage' in server.js
//
// AI ANALYSIS:
// - Analyzes problem descriptions, categories, and customer info
// - Generates priority scores (1-10) for urgency ranking
// - Provides profitability assessments for business decisions
// - Stores results in request.triage_summary, priority_score, profitability_score
//
// SECURITY:
// - Requires admin authentication
// - Rate limiting should be considered for production use
// - OpenAI API key required in environment variables

import express from 'express';
import { triageRequest } from '../controllers/triageController.js';
import { authenticate, isAdmin } from '../middleware/authMiddleware.js';

const router = express.Router();

// @route   POST /api/triage/:requestId
// @desc    Perform AI-powered triage on a request
// @access  Admin
router.post('/:requestId', authenticate, isAdmin, triageRequest);

export default router;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/routes/userRoutes.js ---

// packages/backend/api/routes/userRoutes.js
//
// USER ROUTES - Customer Profile Management
//
// This file defines routes for managing user profiles in the plumbing quote system.
// Handles customer information storage, updates, and retrieval for personalized service.
//
// ARCHITECTURE:
// - RESTful CRUD operations for user profiles
// - User-scoped access (users can only manage their own profiles)
// - Flexible profile updates without strict schema validation
// - Integration with Supabase auth system
//
// DEPLOYMENT:
// - In development: runs as Express server at http://localhost:3000/api/users/*
// - In production: deployed as Netlify Function via /.netlify/functions/api/*
// - Mounted at '/api/users' in server.js
//
// PROFILE DATA:
// - Stores customer contact information (name, email, phone, address)
// - Geographic data for service area calculations
// - User preferences and account settings
// - Links to Supabase auth.users table via user_id
//
// SECURITY:
// - All routes require user authentication
// - Users can only access/modify their own profile data
// - No admin routes (self-service only)
// - Input validation recommended for production
//
// DATABASE:
// - user_profiles table in Supabase
// - Foreign key relationship to auth.users
// - Optional fields allow flexible profile completion

import express from 'express';
import { updateUserProfile, createUserProfile, getUserProfile } from '../controllers/userController.js';
import { authenticate } from '../middleware/authMiddleware.js';
// We don't need a specific Zod schema here because the `update` is flexible,
// but for production, you would add one to validate the incoming fields.

const router = express.Router();

// Get the profile for the authenticated user
router.get('/profile', authenticate, getUserProfile);

// Create a new profile for the authenticated user
router.post('/profile', authenticate, createUserProfile);

// Update an existing profile for the authenticated user
router.put('/profile', authenticate, updateUserProfile);

export default router;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/server.js ---

// packages/backend/api/server.js (v4.3 - Serverless Clean)
import express from 'express';
import cors from 'cors';

// This is the ONLY place dotenv is configured. It is safe here.
// Netlify provides process.env, so this call is effectively ignored in production.
// Locally, it loads the .env file as needed.
import dotenv from 'dotenv';
dotenv.config({ path: '../../.env' });

import requestRoutes from './routes/requestRoutes.js';
import userRoutes from './routes/userRoutes.js';
import followUpRoutes from './routes/followUpRoutes.js';
import triageRoutes from './routes/triageRoutes.js';
import agentRoutes from './routes/agentRoutes.js';
import invoiceRoutes from './routes/invoiceRoutes.js';

const app = express();

const corsOptions = {
  origin: process.env.VITE_FRONTEND_BASE_URL,
};
app.use(cors(corsOptions));
app.use(express.json());

app.use('/api/requests', requestRoutes);
app.use('/api/follow-up', followUpRoutes);
app.use('/api/triage', triageRoutes);
app.use('/api/agents', agentRoutes);
app.use('/api', invoiceRoutes);
app.use('/api', userRoutes);

app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'API is healthy' });
});

app.use((err, req, res, next) => {
  console.error('[GLOBAL ERROR HANDLER]', err);
  res.status(500).json({
    error: 'An unexpected error occurred on the server.',
    details: process.env.NODE_ENV === 'development' ? err.message : undefined,
  });
});

// The serverless wrapper will import this `app` object.
export default app;

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/services/email/resend/client.js ---

// packages/backend/api/services/email/resend/client.js

import { Resend } from 'resend';
import { database as supabase } from '../../../config/supabase/index.js';

// Load environment variables correctly.
const resend = new Resend(process.env.RESEND_API_KEY);
// This should be the URL of your FRONTEND application.
const BASE_URL = process.env.FRONTEND_URL || 'http://localhost:5173';
const RESEND_ENABLED = process.env.RESEND_ENABLED === 'true';
const RESEND_FROM_EMAIL = process.env.RESEND_FROM_EMAIL || 'AquaFlow Plumbing <noreply@copilotfortrades.com>';

/**
 * A generic email sending function.
 */
// requestId is optional but should be provided by callers so audit rows can link to a request
const sendEmail = async ({ to, subject, html, text, requestId = null }) => {
  console.log(`[LOG] üìß EMAIL DEBUG: RESEND_ENABLED = ${RESEND_ENABLED}`);
  console.log(`[LOG] üìß EMAIL DEBUG: Attempting to send email from: ${RESEND_FROM_EMAIL}`);
  console.log(`[LOG] üìß EMAIL DEBUG: Attempting to send email to: ${to}`);
  console.log(`[LOG] üìß EMAIL DEBUG: Subject: ${subject}`);

  if (!RESEND_ENABLED) {
    console.log('[LOG] ‚ùå EMAIL DISABLED: Resend is disabled. Email not sent.');
    return { success: false, message: 'Email sending is disabled' };
  }

  try {
    console.log('[LOG] üì§ EMAIL DEBUG: Calling Resend API...');
    const { data, error } = await resend.emails.send({
      from: RESEND_FROM_EMAIL,
      to,
      subject,
      html,
      text,
    });

    if (error) {
      console.error('‚ùå EMAIL ERROR: Resend Error:', error);
      // Persist failure if possible
      try {
        await supabase.from('email_audit').insert({
          request_id: requestId || null,
          recipient: to,
          resend_message_id: null,
          status: 'error',
          provider_response: error ? JSON.parse(JSON.stringify(error)) : null,
          created_at: new Date().toISOString()
        });
      } catch (persistErr) {
        console.warn('Could not persist email_audit (error):', persistErr?.message || persistErr);
      }
      return { error };
    }

    console.log('[LOG] ‚úÖ EMAIL SUCCESS: Email sent successfully:', data);

    // Persist send audit if supabase is available
    try {
      await supabase.from('email_audit').insert({
        request_id: requestId || null,
        recipient: to,
        resend_message_id: data?.id || null,
        status: 'sent',
        provider_response: data ? data : null,
        created_at: new Date().toISOString()
      });
    } catch (persistErr) {
      console.warn('Could not persist email_audit (success):', persistErr?.message || persistErr);
    }

    return { data };
  } catch (error) {
    console.error('‚ùå EMAIL FAILED: Failed to send email:', error);
    try {
      await supabase.from('email_audit').insert({
        request_id: requestId || null,
        recipient: to,
        resend_message_id: null,
        status: 'failed',
        provider_response: { message: error?.message || String(error) },
        created_at: new Date().toISOString()
      });
    } catch (persistErr) {
      console.warn('Could not persist email_audit (exception):', persistErr?.message || persistErr);
    }
    return { error };
  }
};

// CRITICAL CHANGE: This now returns the customer's email.
const getRecipientEmail = (request) => {
  // The domain is now verified, so we can send to the actual customer.
  return request?.user_profiles?.email;
};

// RECOMMENDED IMPROVEMENT: Link directly to the request if your frontend supports it.
const getRequestUrl = (requestId) => {
  // Use hash-based route so the SPA can handle the client-side route
  return `${BASE_URL}/#/requests/${requestId}`;
};

const sendRequestSubmittedEmail = (request) => {
  const recipientEmail = getRecipientEmail(request);
  if (!recipientEmail) {
    console.log('[LOG] üìß EMAIL DEBUG: No recipient email found on request. Aborting sendRequestSubmittedEmail.');
    console.log('[LOG] üìß EMAIL DEBUG: request.user_profiles =', request?.user_profiles);
    return;
  }

  // Extra debug information to help trace any delivery issues
  console.log('[LOG] üìß EMAIL DEBUG: Preparing to send request-submitted email');
  console.log('[LOG] üìß EMAIL DEBUG: RESEND_ENABLED =', RESEND_ENABLED);
  console.log('[LOG] üìß EMAIL DEBUG: RESEND_FROM_EMAIL =', RESEND_FROM_EMAIL);
  console.log('[LOG] üìß EMAIL DEBUG: recipientEmail =', recipientEmail);
  console.log('[LOG] üìß EMAIL DEBUG: request.id =', request?.id);

  const requestUrl = getRequestUrl(request.id);
  const subject = `Your request has been received!`;
  // Build readable fields
  const humanizedCategory = request.problem_category ? request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'N/A';
  const customerName = request.user_profiles?.name || 'N/A';
  const customerEmail = request.user_profiles?.email || 'N/A';
  const customerPhone = request.user_profiles?.phone || 'N/A';
  const serviceAddress = request.service_address || 'N/A';
  const quotesCount = Array.isArray(request.quotes) ? request.quotes.length : 0;
  const triage = request.triage_summary || null;
  const asapFlag = request.asap ? 'Yes' : 'No';
  const scheduled = request.scheduled_date ? new Date(request.scheduled_date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : (request.asap ? 'ASAP' : 'Not scheduled');
  const rawSummary = request.description || '';
  const htmlSummary = rawSummary.length > 400 ? `${rawSummary.slice(0,400)}‚Ä¶` : rawSummary;

  const html = `
    <div style="font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; max-width:600px; margin:0 auto;">
      <h2 style="color:#111827">We've received your request</h2>
      <p style="color:#374151">Thanks ‚Äî we've recorded your request for "${humanizedCategory}". Click the button below to view details and manage quotes.</p>
      <p style="text-align:center; margin:24px 0;">
        <a href="${requestUrl}" style="background:#2563eb;color:white;padding:12px 20px;border-radius:6px;text-decoration:none;display:inline-block">View request</a>
      </p>

      <h3 style="color:#111827; font-size:16px; margin-top:8px;">Request details</h3>
      <table style="width:100%; font-size:14px; color:#374151; border-collapse:collapse;">
        <tr><td style="padding:6px 0; width:150px; color:#6b7280">Request ID</td><td style="padding:6px 0">${request.id}</td></tr>
        <tr><td style="padding:6px 0; color:#6b7280">Summary</td><td style="padding:6px 0">${htmlSummary || 'N/A'}</td></tr>
        <tr><td style="padding:6px 0; color:#6b7280">Type</td><td style="padding:6px 0">${humanizedCategory}</td></tr>
        <tr><td style="padding:6px 0; color:#6b7280">Emergency Request?</td><td style="padding:6px 0">${asapFlag}</td></tr>
        <tr><td style="padding:6px 0; color:#6b7280">Scheduled</td><td style="padding:6px 0">${scheduled}</td></tr>
        <tr><td style="padding:6px 0; color:#6b7280">Service address</td><td style="padding:6px 0">${serviceAddress}</td></tr>
        <tr><td style="padding:6px 0; color:#6b7280">Customer</td><td style="padding:6px 0">${customerName} ‚Äî ${customerEmail} ‚Äî ${customerPhone}</td></tr>
        <tr><td style="padding:6px 0; color:#6b7280">Quotes</td><td style="padding:6px 0">${quotesCount}</td></tr>
        ${triage ? `<tr><td style="padding:6px 0; color:#6b7280">Triage</td><td style="padding:6px 0">${triage}</td></tr>` : ''}
      </table>

      <p style="font-size:12px;color:#6b7280; margin-top:12px">Or open this link in your browser: <a href="${requestUrl}">${requestUrl}</a></p>
      <hr />
      <p style="color:#374151">Thanks,<br/>Plumbing POC</p>
    </div>
  `;

  const text = `We've received your request for "${humanizedCategory}".

Request ID: ${request.id}
Summary: ${rawSummary}
Type: ${humanizedCategory}
Emergency Request?: ${asapFlag}
Scheduled: ${scheduled}
Service address: ${serviceAddress}
Customer: ${customerName} ‚Äî ${customerEmail} ‚Äî ${customerPhone}
Quotes: ${quotesCount}
${triage ? `Triage: ${triage}\n` : ''}

View it here: ${requestUrl}

Thanks,
Plumbing POC`;

  return sendEmail({ to: recipientEmail, subject, html, text, requestId: request.id });
};

const sendStatusUpdateEmail = (request) => {
  const recipientEmail = getRecipientEmail(request);
  if (!recipientEmail) return;

  const requestUrl = getRequestUrl(request.id);
  const subject = `Update on your request`;
  // Shared field formatting
  const humanizedCategory = request.problem_category ? request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'N/A';
  const rawSummary = request.description || '';
  const htmlSummary = rawSummary.length > 300 ? `${rawSummary.slice(0,300)}‚Ä¶` : rawSummary;
  const asapFlag = request.asap ? 'Yes' : 'No';
  const scheduled = request.scheduled_date ? new Date(request.scheduled_date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : (request.asap ? 'ASAP' : 'Not scheduled');
  const customerName = request.user_profiles?.name || 'N/A';
  const customerPhone = request.user_profiles?.phone || 'N/A';
  const serviceAddress = request.service_address || 'N/A';
  const quotesCount = Array.isArray(request.quotes) ? request.quotes.length : 0;

  const html = `
    <div style="font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; max-width:600px; margin:0 auto;">
      <p style="color:#374151">The status of your request has been updated to: <strong>${request.status}</strong>.</p>
      <p style="text-align:center; margin:16px 0;"><a href="${requestUrl}" style="background:#2563eb;color:white;padding:10px 16px;border-radius:6px;text-decoration:none;display:inline-block">View request</a></p>

      <h4 style="margin-top:8px;color:#111827">Request details</h4>
      <p style="color:#374151; font-size:14px; line-height:1.4">${htmlSummary || 'N/A'}</p>
      <p style="color:#6b7280; font-size:13px">Type: ${humanizedCategory} ‚Ä¢ Emergency: ${asapFlag} ‚Ä¢ Scheduled: ${scheduled}</p>
      <p style="color:#6b7280; font-size:13px">Address: ${serviceAddress} ‚Ä¢ Customer: ${customerName} ‚Ä¢ Phone: ${customerPhone} ‚Ä¢ Quotes: ${quotesCount}</p>

      <p style="font-size:12px;color:#6b7280; margin-top:12px">Request ID: ${request.id} ‚Äî or open: <a href="${requestUrl}">${requestUrl}</a></p>
      <hr />
      <p style="color:#374151">Thanks,<br/>Plumbing POC</p>
    </div>
  `;

  const text = `The status of your request has been updated to: ${request.status}\n\nRequest ID: ${request.id}\nSummary: ${rawSummary}\nType: ${humanizedCategory}\nEmergency?: ${asapFlag}\nScheduled: ${scheduled}\nService address: ${serviceAddress}\nCustomer: ${customerName} ‚Äî ${customerPhone}\nQuotes: ${quotesCount}\n\nView it here: ${requestUrl}\n\nThanks,\nPlumbing POC`;

  return sendEmail({ to: recipientEmail, subject, html, text, requestId: request.id });
};

const sendQuoteAddedEmail = (request, quote) => {
    const recipientEmail = getRecipientEmail(request);
    if (!recipientEmail) return;

    const requestUrl = getRequestUrl(request.id);
    const subject = `You have a new quote for your request`;
    const humanizedCategory = request.problem_category ? request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'N/A';
    const rawSummary = request.description || '';
    const htmlSummary = rawSummary.length > 300 ? `${rawSummary.slice(0,300)}‚Ä¶` : rawSummary;
    const asapFlag = request.asap ? 'Yes' : 'No';
    const scheduled = request.scheduled_date ? new Date(request.scheduled_date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : (request.asap ? 'ASAP' : 'Not scheduled');
    const customerName = request.user_profiles?.name || 'N/A';
    const customerPhone = request.user_profiles?.phone || 'N/A';
    const serviceAddress = request.service_address || 'N/A';

    const html = `
      <div style="font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; max-width:600px; margin:0 auto;">
        <p style="color:#374151">A new quote for <strong>$${quote.quote_amount.toFixed(2)}</strong> has been added to your request.</p>
        <p style="text-align:center; margin:16px 0;"><a href="${requestUrl}" style="background:#10b981;color:white;padding:10px 16px;border-radius:6px;text-decoration:none;display:inline-block">View quote</a></p>

        <h4 style="margin-top:8px;color:#111827">Request details</h4>
        <p style="color:#374151; font-size:14px; line-height:1.4">${htmlSummary || 'N/A'}</p>
        <p style="color:#6b7280; font-size:13px">Type: ${humanizedCategory} ‚Ä¢ Emergency: ${asapFlag} ‚Ä¢ Scheduled: ${scheduled}</p>
        <p style="color:#6b7280; font-size:13px">Address: ${serviceAddress} ‚Ä¢ Customer: ${customerName} ‚Ä¢ Phone: ${customerPhone}</p>

        <p style="font-size:12px;color:#6b7280; margin-top:12px">Request ID: ${request.id} ‚Äî or open: <a href="${requestUrl}">${requestUrl}</a></p>
        <hr />
        <p style="color:#374151">Thanks,<br/>Plumbing POC</p>
      </div>
    `;

    const text = `A new quote for $${quote.quote_amount.toFixed(2)} has been added.\n\nRequest ID: ${request.id}\nSummary: ${rawSummary}\nType: ${humanizedCategory}\nEmergency?: ${asapFlag}\nScheduled: ${scheduled}\nService address: ${serviceAddress}\nCustomer: ${customerName} ‚Äî ${customerPhone}\n\nView it here: ${requestUrl}\n\nThanks,\nPlumbing POC`;

  return sendEmail({ to: recipientEmail, subject, html, text, requestId: request.id });
};

const sendFollowUpEmail = (request) => {
  const recipientEmail = getRecipientEmail(request);
  if (!recipientEmail) return;

  const requestUrl = getRequestUrl(request.id);
  const subject = `Following up on your quote for ${request.problem_category.replace(/_/g, ' ')}`;
  const humanizedCategory = request.problem_category ? request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'N/A';
  const rawSummary = request.description || '';
  const htmlSummary = rawSummary.length > 300 ? `${rawSummary.slice(0,300)}‚Ä¶` : rawSummary;
  const asapFlag = request.asap ? 'Yes' : 'No';
  const scheduled = request.scheduled_date ? new Date(request.scheduled_date).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : (request.asap ? 'ASAP' : 'Not scheduled');
  const customerName = request.user_profiles?.name || 'N/A';
  const customerPhone = request.user_profiles?.phone || 'N/A';
  const serviceAddress = request.service_address || 'N/A';

  const html = `
    <div style="font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; max-width:600px; margin:0 auto;">
      <p style="color:#374151">Hi ${customerName},</p>
      <p style="color:#374151">Just wanted to follow up on the quote we sent you for your recent request. Please let us know if you have any questions or if you'd like to move forward.</p>
      <p style="text-align:center; margin:16px 0;"><a href="${requestUrl}" style="background:#2563eb;color:white;padding:10px 16px;border-radius:6px;text-decoration:none;display:inline-block">View request</a></p>

      <h4 style="margin-top:8px;color:#111827">Request details</h4>
      <p style="color:#374151; font-size:14px; line-height:1.4">${htmlSummary || 'N/A'}</p>
      <p style="color:#6b7280; font-size:13px">Type: ${humanizedCategory} ‚Ä¢ Emergency: ${asapFlag} ‚Ä¢ Scheduled: ${scheduled}</p>
      <p style="color:#6b7280; font-size:13px">Address: ${serviceAddress} ‚Ä¢ Customer: ${customerName} ‚Ä¢ Phone: ${customerPhone}</p>

      <p style="font-size:12px;color:#6b7280; margin-top:12px">Request ID: ${request.id} ‚Äî or open: <a href="${requestUrl}">${requestUrl}</a></p>
      <hr />
      <p style="color:#374151">Thanks,<br/>Plumbing POC</p>
    </div>
  `;

  const text = `Hi ${customerName},\n\nJust wanted to follow up on the quote we sent you for your recent request.\n\nRequest ID: ${request.id}\nSummary: ${rawSummary}\nType: ${humanizedCategory}\nEmergency?: ${asapFlag}\nScheduled: ${scheduled}\nService address: ${serviceAddress}\nCustomer: ${customerName} ‚Äî ${customerPhone}\n\nView it here: ${requestUrl}\n\nThanks,\nPlumbing POC`;

  return sendEmail({ to: recipientEmail, subject, html, text, requestId: request.id });
};


export {
  sendRequestSubmittedEmail,
  sendStatusUpdateEmail,
  sendQuoteAddedEmail,
  sendFollowUpEmail,
};

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/services/email/resend/index.js ---

// packages/backend/api/services/email/resend/index.js

export * from './client.js';

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/services/sms/twilio/client.js ---

// packages/backend/api/services/sms/twilio/client.js

import axios from 'axios';
import { database as supabase } from '../../../config/supabase/index.js';
import twilio from 'twilio';
import { logger } from '../../../../src/lib/logger.js';

// Twilio credentials
const accountSid = process.env.TWILIO_ACCOUNT_SID;
const authToken = process.env.TWILIO_AUTH_TOKEN;
const fromPhone = process.env.TWILIO_PHONE_NUMBER;

// Fetches phone numbers for all users with the 'admin' role from Supabase.
// Automatically formats phone numbers to E.164 format for Twilio.
const getAdminPhoneNumbers = async () => {
  logger.log('üì± SMS SERVICE: getAdminPhoneNumbers called');

  // Use a more efficient query that gets unique phone numbers directly
  // This simulates: SELECT DISTINCT phone FROM user_profiles WHERE role='admin' AND phone IS NOT NULL
  const { data, error } = await supabase
    .from('user_profiles')
    .select('phone')
    .eq('role', 'admin')
    .not('phone', 'is', null)
    .order('phone'); // Order by phone to group duplicates together

  logger.log('üì± SMS SERVICE: Database query result:', { data, error });

  if (error) {
    console.error('‚ùå SMS Service: Database error:', error);
    return [];
  }

  if (!data || data.length === 0) {
    logger.log('üì± SMS SERVICE: No admin users with phone numbers found in database');
    return [];
  }

  logger.log('üì± SMS SERVICE: Found', data.length, 'admin users with phones');

  // Format phone numbers to E.164 format
  const formattedNumbers = data.map(admin => {
    let phone = admin.phone;

    // Remove all non-digit characters
    phone = phone.replace(/\D/g, '');

    // If it doesn't start with country code, assume North America (+1)
    if (!phone.startsWith('1')) {
      phone = '1' + phone;
    }

    // Add + prefix for E.164 format
    return '+' + phone;
  });

  // Remove duplicates to avoid sending multiple SMS to same number
  const uniqueNumbers = [...new Set(formattedNumbers)];

  return uniqueNumbers;
};

// Makes a direct call to Twilio API to send SMS
const triggerSms = async (to, body) => {
  logger.log(`üîç SMS DEBUG: Attempting to send SMS to: ${to}`);
  logger.log(`üîç SMS DEBUG: From number: ${fromPhone}`);
  logger.log(`üîç SMS DEBUG: Message length: ${body.length} characters`);

  // FEATURE FLAG: Only send SMS in production (Netlify) environment
  // This prevents accidental SMS sending during local development
  const isProduction = process.env.NODE_ENV === 'production' || process.env.NETLIFY === 'true';
  if (!isProduction) {
    logger.log('üì± SMS SKIPPED: SMS sending disabled in development environment');
    logger.log('üì± SMS SKIPPED: To prevent accidental costs during development');
    logger.log('üì± SMS SKIPPED: SMS would have been sent to:', to);
    logger.log('üì± SMS SKIPPED: Message preview:', body.substring(0, 50) + '...');
    return;
  }

  if (!accountSid || !authToken || !fromPhone) {
    console.error('‚ùå SMS ERROR: Twilio credentials not configured');
    console.error('‚ùå SMS ERROR: accountSid:', !!accountSid);
    console.error('‚ùå SMS ERROR: authToken:', !!authToken);
    console.error('‚ùå SMS ERROR: fromPhone:', !!fromPhone);
    return;
  }

  try {
    logger.log('üì§ SMS DEBUG: About to create Twilio client...');
    // Create Twilio client
    const twilioClient = twilio(accountSid, authToken);
    logger.log('üì§ SMS DEBUG: Twilio client created successfully');

    logger.log('üì§ SMS DEBUG: About to call Twilio API...');
    logger.log('üì§ SMS DEBUG: To:', to);
    logger.log('üì§ SMS DEBUG: From:', fromPhone);
    logger.log('üì§ SMS DEBUG: Body length:', body.length);

    // Send SMS directly
    const smsResponse = await twilioClient.messages.create({
      body: body,
      from: fromPhone,
      to: to
    });

    logger.log(`‚úÖ SMS SUCCESS: Sent to ${to}. SID: ${smsResponse.sid}`);
    logger.log(`üìä SMS STATUS: ${smsResponse.status}`);
    logger.log(`üí∞ SMS COST: ${smsResponse.price || 'N/A'}`);
  } catch (error) {
    console.error(`‚ùå SMS FAILED: To ${to}`);
    console.error(`‚ùå SMS ERROR:`, error.message);
    console.error(`‚ùå SMS ERROR CODE:`, error.code);
    console.error(`‚ùå SMS ERROR STATUS:`, error.status);
  }
};

// SCENARIO 1: New Quote Request
export const sendNewRequestNotification = async (request) => {
  logger.log('üì± SMS SERVICE: sendNewRequestNotification called');
  logger.log('üì± SMS SERVICE: Request ID:', request.id);
  logger.log('üì± SMS SERVICE: Request data structure:', JSON.stringify(request, null, 2));
  logger.log('üì± SMS SERVICE: customer_name:', request.customer_name);
  logger.log('üì± SMS SERVICE: user_profiles:', request.user_profiles);

  // DEBUG: Check environment
  logger.log('üì± SMS SERVICE: NODE_ENV:', process.env.NODE_ENV);
  logger.log('üì± SMS SERVICE: NETLIFY:', process.env.NETLIFY);
  logger.log('üì± SMS SERVICE: isProduction check:', process.env.NODE_ENV === 'production' || process.env.NETLIFY === 'true');

  // DEBUG: Check Twilio credentials
  logger.log('üì± SMS SERVICE: TWILIO_ACCOUNT_SID present:', !!process.env.TWILIO_ACCOUNT_SID);
  logger.log('üì± SMS SERVICE: TWILIO_AUTH_TOKEN present:', !!process.env.TWILIO_AUTH_TOKEN);
  logger.log('üì± SMS SERVICE: TWILIO_PHONE_NUMBER present:', !!process.env.TWILIO_PHONE_NUMBER);
  logger.log('üì± SMS SERVICE: TWILIO_DEFAULT_ADMIN_NUMBER:', process.env.TWILIO_DEFAULT_ADMIN_NUMBER);

  // First try to get admin numbers from database
  const adminNumbers = await getAdminPhoneNumbers();
  logger.log('üì± SMS SERVICE: Found admin numbers from DB:', adminNumbers);

  let numbersToNotify = adminNumbers;

  // If no admin numbers in DB, use default admin number from env
  if (adminNumbers.length === 0) {
    const defaultAdminNumber = process.env.TWILIO_DEFAULT_ADMIN_NUMBER;
    logger.log('üì± SMS SERVICE: No admin numbers in DB, using default:', defaultAdminNumber);
    if (defaultAdminNumber) {
      numbersToNotify = [defaultAdminNumber];
    } else {
      logger.log('üì± SMS SERVICE: No default admin number configured, skipping SMS');
      return;
    }
  }

  const requestUrl = `${process.env.VITE_FRONTEND_BASE_URL}`;
  logger.log('üì± SMS SERVICE: Constructing message...');
  logger.log('üì± SMS SERVICE: request.id:', request.id);
  logger.log('üì± SMS SERVICE: request.problem_category:', request.problem_category);
  logger.log('üì± SMS SERVICE: request.customer_name:', request.customer_name);
  logger.log('üì± SMS SERVICE: request.service_address:', request.service_address);
  logger.log('üì± SMS SERVICE: requestUrl:', requestUrl);

  const messageBody = `New Quote Request!\nID: ${request.id}\nType: ${request.problem_category.replace(/_/g, " ")}\nFrom: ${request.customer_name}\nAddress: ${request.service_address}\nLink: ${requestUrl}`;
  logger.log('üì± SMS SERVICE: Message body constructed:', messageBody.substring(0, 50) + '...');
  logger.log('üì± SMS SERVICE: Message body length:', messageBody.length);

  logger.log('üì± SMS SERVICE: About to call triggerSms...');
  numbersToNotify.forEach((number, index) => {
    logger.log(`üì± SMS SERVICE: Calling triggerSms for number ${index + 1}: ${number}`);
    triggerSms(number, messageBody);
  });
  logger.log('üì± SMS SERVICE: All triggerSms calls completed');
};

// SCENARIO 2: Quote Accepted by Customer
export const sendQuoteAcceptedNotification = async (request, acceptedQuote) => {
  logger.log('üì± SMS SERVICE: sendQuoteAcceptedNotification called');
  logger.log('üì± SMS SERVICE: Request ID:', request.id);
  logger.log('üì± SMS SERVICE: Quote data:', JSON.stringify(acceptedQuote, null, 2));
  logger.log('üì± SMS SERVICE: Request data structure:', JSON.stringify(request, null, 2));
  logger.log('üì± SMS SERVICE: customer_name:', request.customer_name);
  logger.log('üì± SMS SERVICE: user_profiles:', request.user_profiles);

  const adminNumbers = await getAdminPhoneNumbers();
  logger.log('üì± SMS SERVICE: Found admin numbers from DB:', adminNumbers);
  if (adminNumbers.length === 0) return;

  const requestUrl = `${process.env.VITE_FRONTEND_BASE_URL}/#/dashboard`;
  const messageBody = `Quote ACCEPTED!\nID: ${request.id}\nAmount: $${acceptedQuote.quote_amount.toFixed(2)}\nFor: ${request.problem_category.replace(/_/g, " ")}\nCustomer: ${request.user_profiles.name}\nLink: ${requestUrl}`;

  adminNumbers.forEach(number => triggerSms(number, messageBody));
};

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/services/sms/twilio/index.js ---

// packages/backend/api/services/sms/twilio/index.js

export * from './client.js';

--- END OF FILE ---

--- START OF FILE ./packages/backend/api/validation/schemas.js ---

// packages/backend/api/validation/schemas.js

import { z } from 'zod';

// Schema for the initial request from the AI agent for follow-up questions
const gptRequestSchema = z.object({
  body: z.object({
    clarifyingAnswers: z.array(z.object({ question: z.string(), answer: z.string() })),
    category: z.string(),
    problem_description: z.string().optional(),
  }),
});

// Schema for the final submission of the entire quote request form
const submitQuoteSchema = z.object({
  body: z.object({
    clarifyingAnswers: z.array(z.object({ question: z.string(), answer: z.string() })),
    contactInfo: z.object({
      name: z.string().optional(),
      address: z.string().optional(),
      city: z.string().optional(),
      province: z.string().optional(),
      postal_code: z.string().optional(),
      email: z.string().email().optional(),
      phone: z.string().optional(),
    }),
    category: z.string(),
    isEmergency: z.boolean().optional(),
    property_type: z.string().optional(),
    is_homeowner: z.string().optional(),
    problem_description: z.string().optional(),
    preferred_timing: z.string().optional(),
    additional_notes: z.string().optional(),
  }),
});

// Schema for adding a new note to a request
const addNoteSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid request ID format.")
  }),
  body: z.object({
    note: z.string().min(1, "Note cannot be empty.")
  }),
});

// Schema for an admin creating a quote for a request
const createQuoteSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid request ID format.")
  }),
  body: z.object({
    quote_amount: z.number().positive("Quote amount must be a positive number."),
    details: z.string().min(1, "Quote details cannot be empty."),
  }),
});

// --- NEW SCHEMA FOR UPDATING A QUOTE ---
const updateQuoteSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid request ID format."),
    quoteId: z.string().uuid("Invalid quote ID format."),
  }),
  body: z.object({
    quote_amount: z.number().positive("Quote amount must be a positive number."),
    details: z.string().min(1, "Quote details cannot be empty."),
  }),
});

// Schema for getting an object from storage
const getObjectSchema = z.object({
    params: z.object({
        0: z.string().min(1, "Object path cannot be empty."),
    })
});

const updateStatusSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid request ID format."),
  }),
  body: z.object({
    status: z.string().min(1, "Status cannot be empty."),
    scheduled_start_date: z.string().datetime({ offset: true }).nullable().optional(),
  }),
});

export {
  gptRequestSchema,
  submitQuoteSchema,
  addNoteSchema,
  createQuoteSchema,
  updateQuoteSchema,
  getObjectSchema,
  updateStatusSchema,
};

--- END OF FILE ---

--- START OF FILE ./packages/backend/netlify/functions/README.md ---

# Netlify Functions

This directory contains the serverless functions that power the PlumbingPOC application on Netlify.

## Overview

The application uses Netlify Functions to run the Express.js backend serverlessly. The main function is `api.mjs` which wraps the Express app using `serverless-http`. Additional specialized functions handle specific features like AI-powered quote assistance (`quote-agent.mjs`) and SMS notifications (`send-sms.mjs`).

## File Structure

- `api.mjs` - Main API function that handles all HTTP requests
- `quote-agent.mjs` - YAML-driven quote intake agent with optional AI follow-up questions
- `triage-agent.mjs` - AI-powered request triage and scoring agent
- `send-sms.mjs` - SMS notification function for Twilio integration

## Module System

All functions use ES Modules (`.mjs` extension) to maintain consistency with the modern backend codebase. The functions are configured with external module dependencies to ensure proper serverless compatibility.

### Key Technical Decisions

1. **ESM Architecture**: Modern ES Modules throughout the entire backend for consistency and future-proofing.

2. **External Modules Configuration**: Netlify's bundler is configured via `netlify.toml` to treat complex Node.js packages (express, cors, serverless-http, etc.) as external dependencies rather than bundling them. This prevents bundling conflicts while maintaining runtime availability.

3. **AI Agent Functions**: Specialized functions use custom YAML-driven workflow engines with minimal OpenAI SDK usage:
   - `quote-agent.mjs`: Uses OpenAI only for optional follow-up question generation (`generateFollowUpQuestions()`)
   - `triage-agent.mjs`: Uses OpenAI for job complexity and urgency analysis
   - Both load YAML configurations from `agents/` directory and execute deterministic workflows
   - See [ADR-028](../../../../adrs/028-choice-of-custom-yaml-over-openai-agents-sdk.md) for why we use custom YAML instead of OpenAI Agents SDK

4. **Clean Function Wrappers**: Functions use standard ESM imports and exports, with the bundler configuration handling the complexity of external dependencies.

5. **Error Handling**: Functions include comprehensive error handling with proper HTTP status codes and JSON responses.

## Deployment

Functions are automatically deployed when code is pushed to the main branch. Netlify detects `.mjs` files in this directory and deploys them as serverless functions.

### Bundler Configuration

The functions use Netlify's esbuild bundler with special configuration in `netlify.toml`:

```toml
[functions]
  "api-mjs" = {
    external_node_modules = [
      "express",
      "cors",
      "serverless-http",
      "dotenv",
      "supabase",
      "@supabase/supabase-js"
    ]
  }

  "quote-agent-mjs" = {
    external_node_modules = [
      "openai",
      "yaml"
    ]
  }

  "triage-agent-mjs" = {
    external_node_modules = [
      "openai",
      "yaml"
    ]
  }
```

This configuration tells the bundler to not bundle these packages but instead make them available as external dependencies at runtime. The agent functions only require the standard OpenAI SDK (`openai`) and YAML parser (`yaml`), not the OpenAI Agents SDK.

## Environment Variables

Functions access environment variables set in the Netlify dashboard:
- `VITE_FRONTEND_BASE_URL` - CORS origin
- Database credentials (Supabase)
- `OPENAI_API_KEY` - Required for AI agent functions
- API keys (Twilio, etc.)

## Troubleshooting

### Common Issues

1. **502 Bad Gateway**: Usually indicates the function crashed during initialization. Check Netlify function logs for the exact error. Often related to bundling issues with external dependencies.

2. **Bundling Errors**: If you see errors about external modules, verify the `external_node_modules` configuration in `netlify.toml` includes all required packages.

3. **Agent Function Errors**: For agent functions, ensure the YAML files exist in `agents/` directory (`quote-agent.yaml`, `triage-agent.yaml`) and are valid YAML. Check that `OPENAI_API_KEY` is properly set.

4. **ESM Import Errors**: Ensure all backend files use consistent ES Modules syntax. The functions expect the backend to be ESM-compatible.

5. **Environment Variables**: Verify all required environment variables are set in Netlify dashboard. Functions access variables injected by Netlify at runtime.

### Function Logs

To debug issues:
1. Go to Netlify dashboard ‚Üí Functions
2. Click on the function (api-mjs)
3. View the "Function log" panel
4. Trigger requests to see real-time logs

### Local Development

Use `netlify dev` for local testing:
```bash
npm install -g netlify-cli
netlify dev
```

Functions will be available at `http://localhost:8888/.netlify/functions/api`

## Maintenance

When modifying functions:
1. Test locally with `netlify dev`
2. Check function logs after deployment
3. Ensure all imports work in the serverless environment
4. Keep error handling comprehensive

## Related Documentation

- `docs/NETLIFY_TROUBLESHOOTING.md` - Comprehensive troubleshooting guide
- `docs/SMS_TROUBLESHOOTING.md` - SMS-specific issues
- Netlify Functions documentation: https://docs.netlify.com/functions/overview/

--- END OF FILE ---

--- START OF FILE ./packages/backend/netlify/functions/api.mjs ---

// packages/backend/netlify/functions/api.mjs

// Use dynamic import to load the Express app
const appPromise = import('../../api/server.js');

export async function handler(event, context) {
  try {
    // Load the app dynamically
    const { default: app } = await appPromise;

    // Import serverless-http dynamically to avoid ESM issues
    const { default: serverless } = await import('serverless-http');

    // Create the handler
    const serverlessHandler = serverless(app);

    // Call the handler
    return await serverlessHandler(event, context);
  } catch (error) {
    console.error('Function initialization error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ error: 'Internal server error', details: error.message }),
    };
  }
}

--- END OF FILE ---

--- START OF FILE ./packages/backend/netlify/functions/quote-agent.mjs ---

// packages/backend/netlify/functions/quote-agent.mjs
// Self-contained YAML-driven quote agent - works locally and on Netlify

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import YAML from 'yaml';
import OpenAI from 'openai';
import { logger } from '../../src/lib/logger.js';

// Environment detection
const isNetlify = process.env.NETLIFY === 'true' || process.env.AWS_LAMBDA_FUNCTION_NAME;

// Get __dirname for both ESM and bundled environments
let __dirname;
try {
  const __filename = fileURLToPath(import.meta.url);
  __dirname = path.dirname(__filename);
} catch (error) {
  __dirname = process.cwd();
}

// Find YAML file (local vs Netlify paths)
let YAML_PATH;
if (isNetlify) {
  YAML_PATH = path.resolve(process.cwd(), 'agents/quote-agent.yaml');
} else {
  YAML_PATH = path.resolve(__dirname, '../../../../agents/quote-agent.yaml');
}

if (!fs.existsSync(YAML_PATH)) {
  YAML_PATH = path.resolve(__dirname, '../../../../../agents/quote-agent.yaml');
}

let yamlConfig;
try {
  yamlConfig = YAML.parse(fs.readFileSync(YAML_PATH, 'utf-8'));
  logger.log('[QuoteAgent] Loaded YAML from:', YAML_PATH);
} catch (error) {
  console.error('[QuoteAgent] Failed to load YAML:', error.message);
  throw new Error(`Failed to load quote-agent.yaml: ${error.message}`);
}

// Substitute environment variables in YAML config
function substituteEnvVars(obj) {
  if (typeof obj === 'string') {
    return obj.replace(/\$\{([^}]+)\}/g, (match, varName) => {
      return process.env[varName] || match;
    });
  } else if (Array.isArray(obj)) {
    return obj.map(substituteEnvVars);
  } else if (obj && typeof obj === 'object') {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = substituteEnvVars(value);
    }
    return result;
  }
  return obj;
}

yamlConfig = substituteEnvVars(yamlConfig);

const openAiClient = process.env.OPENAI_API_KEY
  ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY })
  : null;

const REVIEW_STAGE = 'review_summary';
const START_NODE = 'emergency_check';

// In-memory session storage
const sessions = new Map();

// Helper functions
function getNodeById(nodeId) {
  return yamlConfig.nodes.find((node) => node.id === nodeId);
}

function normalizeServiceKey(value) {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_$/g, '');
}

function createSession(sessionId) {
  const session = {
    id: sessionId,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    currentNodeId: START_NODE,
    answers: [],
    nodeData: {},
    history: [],
    processedUserMessages: 0,
    summary: null,
  };

  sessions.set(sessionId, session);

  addAssistantMessage(
    session,
    "Hi there! I'm the AquaFlow quote assistant. I'll ask a few quick questions so we can prepare your plumbing quote."
  );

  askCurrentNode(session);
  return session;
}

function getSession(sessionId) {
  if (!sessionId) {
    throw new Error('Session ID is required.');
  }

  const existing = sessions.get(sessionId);
  if (existing) {
    existing.updatedAt = Date.now();
    return existing;
  }
  return createSession(sessionId);
}

function addAssistantMessage(session, text, extra = {}) {
  session.history.push({ role: 'assistant', text, ...extra });
}

function addUserMessage(session, text) {
  session.history.push({ role: 'user', text });
}

function recordAnswer(session, nodeId, question, answer) {
  const node = getNodeById(nodeId);
  session.answers.push({
    nodeId,
    question,
    answer,
    captureKey: node?.capture || nodeId,
  });
}

function askCurrentNode(session) {
  const node = getNodeById(session.currentNodeId);

  if (!node) {
    console.error('[QuoteAgent] Node not found:', session.currentNodeId);
    buildSummary(session);
    return;
  }

  logger.log('[QuoteAgent] Processing node:', node.id, 'type:', node.type);

  switch (node.type) {
    case 'choice':
      addAssistantMessage(session, node.prompt, {
        type: 'choice',
        options: (node.options || []).map((option) => ({
          label: option,
          value: option,
        })),
      });
      break;
    case 'static':
      addAssistantMessage(session, node.prompt, {
        type: 'input',
        inputType: 'text',
      });
      break;
    case 'switch':
      handleSwitchNode(session, node);
      break;
    default:
      console.warn('[QuoteAgent] Unknown node type:', node.type);
      buildSummary(session);
  }
}

async function handleSwitchNode(session, node) {
  const variableValue = session.nodeData[node.variable];

  if (!variableValue) {
    console.error('[QuoteAgent] Switch variable not set:', node.variable);
    buildSummary(session);
    return;
  }

  const caseDefinition = node.cases?.[variableValue];

  if (!caseDefinition) {
    console.warn('[QuoteAgent] No case found for:', variableValue);
    buildSummary(session);
    return;
  }

  const questions = caseDefinition.prompt
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean)
    .filter((line) => line.startsWith('- '))
    .map((line) => line.replace(/^-\s*/, '').trim())
    .filter((line) => line.length > 0);

  if (questions.length === 0) {
    await moveToNextNode(session, node);
    return;
  }

  const questionsKey = `${node.id}_questions`;
  const indexKey = `${node.id}_index`;

  if (!session.nodeData[questionsKey]) {
    session.nodeData[questionsKey] = questions;
    session.nodeData[indexKey] = 0;
  }

  const currentIndex = session.nodeData[indexKey];
  const currentQuestion = questions[currentIndex];

  logger.log('[QuoteAgent] Switch node state:', {
    nodeId: node.id,
    totalQuestions: questions.length,
    currentIndex,
    hasQuestion: !!currentQuestion
  });

  if (currentQuestion) {
    addAssistantMessage(session, currentQuestion, {
      type: 'input',
      inputType: 'text',
    });
  } else {
    logger.log('[QuoteAgent] All switch questions answered, moving to next node');
    delete session.nodeData[questionsKey];
    delete session.nodeData[indexKey];
    await moveToNextNode(session, node);
  }
}

async function moveToNextNode(session, currentNode) {
  logger.log('[QuoteAgent] moveToNextNode called:', {
    currentNodeId: currentNode.id,
    hasNext: !!currentNode.next,
    nextNodeId: currentNode.next
  });

  if (currentNode.next) {
    session.currentNodeId = currentNode.next;
    askCurrentNode(session);
  } else {
    logger.log('[QuoteAgent] No next node, calling checkForAiFollowUps');
    await checkForAiFollowUps(session);
  }
}

async function checkForAiFollowUps(session) {
  logger.log('[QuoteAgent] checkForAiFollowUps called');

  if (session.nodeData.followUpsGenerated) {
    logger.log('[QuoteAgent] Follow-ups already generated, building summary');
    buildSummary(session);
    return;
  }

  logger.log('[QuoteAgent] Generating follow-up questions via OpenAI...');
  session.nodeData.followUpsGenerated = true;
  const followUps = await generateFollowUpQuestions(session);
  logger.log('[QuoteAgent] Generated follow-ups:', followUps.length, 'questions');

  if (followUps.length > 0) {
    logger.log('[QuoteAgent] Follow-up questions:', followUps);
    session.nodeData.followUpQuestions = followUps;
    session.nodeData.followUpIndex = 0;
    session.currentNodeId = null; // Clear current node so follow-ups are handled correctly
    askNextFollowUpQuestion(session);
  } else {
    logger.log('[QuoteAgent] No follow-ups needed, building summary');
    buildSummary(session);
  }
}

function askNextFollowUpQuestion(session) {
  const questions = session.nodeData.followUpQuestions || [];
  const index = session.nodeData.followUpIndex || 0;
  const question = questions[index];

  logger.log('[QuoteAgent] askNextFollowUpQuestion:', {
    totalQuestions: questions.length,
    currentIndex: index,
    hasQuestion: !!question,
    question: question
  });

  if (question) {
    addAssistantMessage(session, question, {
      type: 'input',
      inputType: 'text',
    });
  } else {
    logger.log('[QuoteAgent] No more follow-up questions, building summary');
    buildSummary(session);
  }
}

async function generateFollowUpQuestions(session) {
  if (!openAiClient) return [];

  const config = yamlConfig.ai_followup_config;
  if (!config) {
    console.warn('[QuoteAgent] No ai_followup_config found in YAML');
    return [];
  }

  console.log('[LOG] [QuoteAgent] Using AI model:', config.model);

  try {
    // Build conversation summary
    const conversationSummary = session.answers
      .map((item) => `Q: ${item.question}\nA: ${item.answer}`)
      .join('\n\n');

    const selectedService = session.nodeData.selected_service || 'General plumbing service';

    // Replace placeholders in prompt from YAML config
    const prompt = config.user_prompt
      .replace('{service}', selectedService)
      .replace('{conversation_summary}', conversationSummary);

    // Use YAML config for API call
    const model = config.model || process.env.VITE_CHAT_GPT_QUOTE_AGENT_MODEL;
    const isGpt5Model = model?.startsWith('gpt-5');
    const isGpt4oModel = model?.startsWith('gpt-4o');

    let completion;
    if (isGpt5Model) {
      // Use new Responses API for GPT-5 models
      const responseParams = {
        model: model,
        input: `${config.system_prompt || 'You craft follow-up questions for plumbing quotes.'}\n\n${prompt}`,
        reasoning: { effort: "minimal" }, // Fast responses for structured tasks
        text: { verbosity: "low" }, // Concise responses
        max_output_tokens: config.max_completion_tokens || config.max_tokens || 250,
      };

      completion = await openAiClient.responses.create(responseParams);
    } else {
      // Use Chat Completions API for older models
      const apiParams = {
        model: model,
        messages: [
          { role: 'system', content: config.system_prompt || 'You craft follow-up questions for plumbing quotes.' },
          { role: 'user', content: prompt },
        ],
      };

      // Set max tokens parameter based on model type
      if (isGpt4oModel) {
        apiParams.max_completion_tokens = config.max_completion_tokens || config.max_tokens || 250;
      } else {
        apiParams.max_tokens = config.max_completion_tokens || config.max_tokens || 250;
      }

      // Add temperature for non-GPT-5 models
      apiParams.temperature = config.temperature ?? 0.2;

      completion = await openAiClient.chat.completions.create(apiParams);
    }

    // Extract content based on API type
    const content = isGpt5Model
      ? completion.output_text
      : completion.choices?.[0]?.message?.content;
    if (!content) return [];

    const parsed = JSON.parse(content);
    // Always try to return questions if they exist, regardless of requiresFollowUp flag
    if (Array.isArray(parsed.questions) && parsed.questions.length > 0) {
      return parsed.questions.filter((q) => typeof q === 'string' && q.trim().length > 0);
    }
    return [];
  } catch (error) {
    console.error('[QuoteAgent] Failed to generate follow-up questions:', error);
    return [];
  }
}

function buildSummary(session) {
  const emergencyAnswer = session.answers.find((a) => a.captureKey === 'is_emergency');
  const isEmergency = emergencyAnswer?.answer?.toLowerCase().startsWith('y') || false;

  const selectedService = session.nodeData.selected_service;
  const selectedServiceKey = selectedService ? normalizeServiceKey(selectedService) : 'other';

  const summary = {
    service: {
      label: selectedService || 'Plumbing Service',
      key: selectedServiceKey,
    },
    emergency: isEmergency,
    answers: session.answers.map((item) => ({
      question: item.question,
      answer: item.answer || 'Not provided',
    })),
  };

  session.summary = summary;
  session.currentNodeId = REVIEW_STAGE;

  const answerLines = summary.answers
    .map((item) => `‚Ä¢ ${item.question}\n  ${item.answer}`)
    .join('\n');

  addAssistantMessage(
    session,
    `Here's a summary of what I collected:
- Service: ${summary.service.label}
- Emergency: ${summary.emergency ? 'Yes' : 'No'}

Your answers:
${answerLines}

Let's review your contact details, service location, and any attachments before we submit the quote.`,
    { type: 'summary' }
  );
}

async function handleUserInput(session, userText) {
  const currentNode = getNodeById(session.currentNodeId);

  if (!currentNode) {
    const followUpQuestions = session.nodeData.followUpQuestions || [];
    const followUpIndex = session.nodeData.followUpIndex || 0;

    if (followUpIndex < followUpQuestions.length) {
      const question = followUpQuestions[followUpIndex];
      recordAnswer(session, 'ai_followup', question, userText);
      session.nodeData.followUpIndex = followUpIndex + 1;
      askNextFollowUpQuestion(session);
      return;
    }

    if (session.currentNodeId === REVIEW_STAGE) {
      addAssistantMessage(
        session,
        'I already have all the details I need. Please review the summary and submit the request when ready.'
      );
    }
    return;
  }

  switch (currentNode.type) {
    case 'choice':
    case 'static':
      recordAnswer(session, currentNode.id, currentNode.prompt, userText);

      if (currentNode.capture) {
        session.nodeData[currentNode.capture] = userText;
      }

      await moveToNextNode(session, currentNode);
      break;

    case 'switch':
      const questionsKey = `${currentNode.id}_questions`;
      const indexKey = `${currentNode.id}_index`;
      const questions = session.nodeData[questionsKey] || [];
      const currentIndex = session.nodeData[indexKey] || 0;
      const currentQuestion = questions[currentIndex];

      if (currentQuestion) {
        recordAnswer(session, currentNode.id, currentQuestion, userText);
        session.nodeData[indexKey] = currentIndex + 1;
        await handleSwitchNode(session, currentNode);
      }
      break;

    default:
      console.warn('[QuoteAgent] Unhandled node type:', currentNode.type);
      buildSummary(session);
  }
}

function extractUserMessages(messages = []) {
  return messages.filter((message) => message?.role === 'user');
}

async function runQuoteAgent({ sessionId, messages = [] }) {
  logger.log('[QuoteAgent] Called with:', { sessionId, messagesCount: messages.length });

  const session = getSession(sessionId);
  const userMessages = extractUserMessages(messages);

  while (session.processedUserMessages < userMessages.length) {
    const message = userMessages[session.processedUserMessages];
    const content =
      typeof message.text === 'string'
        ? message.text
        : typeof message.content === 'string'
        ? message.content
        : Array.isArray(message.content)
        ? message.content.map((chunk) => chunk?.text || chunk).join(' ')
        : '';

    if (content && content.trim().length > 0) {
      addUserMessage(session, content.trim());
      await handleUserInput(session, content.trim());
    }

    session.processedUserMessages += 1;
  }

  const responseStage = session.currentNodeId === REVIEW_STAGE ? REVIEW_STAGE : 'chat';

  return {
    messages: session.history.map((item) => ({
      role: item.role,
      text: item.text,
      type: item.type,
      inputType: item.inputType,
      options: item.options,
    })),
    stage: responseStage,
    summary: session.currentNodeId === REVIEW_STAGE ? session.summary : null,
    currentNode: session.currentNodeId,
    completedNodes: [],
  };
}

// Netlify function handler
export async function handler(event, context) {
  try {
    // Handle CORS preflight
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type'
        },
        body: ''
      };
    }

    if (event.httpMethod !== 'POST') {
      return {
        statusCode: 405,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }

    const body = JSON.parse(event.body || '{}');
    const { messages, context: agentContext } = body;
    const sessionId = agentContext?.sessionId || agentContext?.userId || agentContext?.conversationId;

    if (!sessionId) {
      return {
        statusCode: 400,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'sessionId is required to run the quote agent.' }),
      };
    }

    const result = await runQuoteAgent({
      sessionId,
      messages: messages || [],
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type'
      },
      body: JSON.stringify(result)
    };

  } catch (error) {
    console.error('[QuoteAgent] Function error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Agent execution failed',
        details: error.message
      })
    };
  }
}

// Export for testing
export { generateFollowUpQuestions };

--- END OF FILE ---

--- START OF FILE ./packages/backend/netlify/functions/send-sms.mjs ---

// packages/backend/netlify/functions/send-sms.mjs

import twilio from 'twilio';
import { logger } from '../../src/lib/logger.js';

export async function handler(event) {
  // 1. Security Check: Only allow POST requests with the correct secret header.
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: 'Method Not Allowed' };
  }
  const providedSecret = event.headers['x-netlify-function-secret'];
  if (providedSecret !== process.env.NETLIFY_FUNCTION_SECRET) {
    console.warn('Unauthorized attempt to trigger SMS function.');
    return { statusCode: 401, body: 'Unauthorized' };
  }

  // 2. Get Twilio credentials from Netlify environment variables.
  const accountSid = process.env.TWILIO_ACCOUNT_SID;
  const authToken = process.env.TWILIO_AUTH_TOKEN;
  const fromPhone = process.env.TWILIO_PHONE_NUMBER;

  if (!accountSid || !authToken || !fromPhone) {
    console.error('Twilio environment variables are not configured in Netlify.');
    return { statusCode: 500, body: 'SMS service is not configured.' };
  }

  const client = twilio(accountSid, authToken);

  try {
    // 3. Parse the incoming request to get the recipient and message.
    const { to, body } = JSON.parse(event.body);
    if (!to || !body) {
      return { statusCode: 400, body: 'Missing "to" or "body" in request.' };
    }

    // 4. Send the SMS message using Twilio regular messaging.
    const smsResponse = await client.messages.create({
      body: body,
      from: fromPhone,
      to: to, // Must be in E.164 format (e.g., "+12505551234")
    });

    logger.log(`SMS sent successfully to ${to}. SID: ${smsResponse.sid}`);
    return { statusCode: 200, body: JSON.stringify({ success: true, sid: smsResponse.sid }) };

  } catch (error) {
    console.error('Error sending SMS via Twilio:', error);
    return { statusCode: 500, body: JSON.stringify({ success: false, error: error.message }) };
  }
};

--- END OF FILE ---

--- START OF FILE ./packages/backend/netlify/functions/triage-agent.mjs ---

// packages/backend/netlify/functions/triage-agent.mjs
// Self-contained YAML-driven triage agent - works locally and on Netlify

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import YAML from 'yaml';
import OpenAI from 'openai';
import { logger } from '../../src/lib/logger.js';
import dotenv from "dotenv";
dotenv.config();

// Environment detection
const isNetlify = process.env.NETLIFY === 'true' || process.env.AWS_LAMBDA_FUNCTION_NAME;

// Get __dirname for both ESM and bundled environments
let __dirname;
try {
  const __filename = fileURLToPath(import.meta.url);
  __dirname = path.dirname(__filename);
} catch (error) {
  __dirname = process.cwd();
}

// Find YAML file (local vs Netlify paths)
let YAML_PATH;
if (isNetlify) {
  YAML_PATH = path.resolve(process.cwd(), 'agents/triage-agent.yaml');
} else {
  YAML_PATH = path.resolve(__dirname, '../../../../agents/triage-agent.yaml');
}

if (!fs.existsSync(YAML_PATH)) {
  YAML_PATH = path.resolve(__dirname, '../../../../../agents/triage-agent.yaml');
}

let yamlConfig;
try {
  yamlConfig = YAML.parse(fs.readFileSync(YAML_PATH, 'utf-8'));
  logger.log('[TriageAgent] Loaded YAML from:', YAML_PATH);
} catch (error) {
  console.error('[TriageAgent] Failed to load YAML:', error.message);
  throw new Error(`Failed to load triage-agent.yaml: ${error.message}`);
}

// Substitute environment variables in YAML config
function substituteEnvVars(obj) {
  if (typeof obj === 'string') {
    return obj.replace(/\$\{([^}]+)\}/g, (match, varName) => {
      return process.env[varName] || match;
    });
  } else if (Array.isArray(obj)) {
    return obj.map(substituteEnvVars);
  } else if (obj && typeof obj === 'object') {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = substituteEnvVars(value);
    }
    return result;
  }
  return obj;
}

yamlConfig = substituteEnvVars(yamlConfig);

const openAiClient = process.env.OPENAI_API_KEY
  ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY })
  : null;

/**
 * Calculate job complexity based on service category and details
 */
function calculateJobComplexity(serviceCategory, problemDescription, locationDetails) {
  const complexityMap = {
    'leak_repair': 5,
    'water_heater': 7,
    'pipe_installation': 7,
    'drain_cleaning': 3,
    'fixture_install': 3,
    'gas_line_services': 10,
    'perimeter_drains': 8,
    'main_line_repair': 10,
    'emergency_service': 8,
    'bathroom_reno': 9,
    'other': 5
  };

  const baseComplexity = complexityMap[serviceCategory] || 5;

  let locationMultiplier = 1;
  const location = (locationDetails || '').toLowerCase();
  if (location.includes('basement') || location.includes('crawlspace')) {
    locationMultiplier = 1.2;
  } else if (location.includes('attic') || location.includes('under house')) {
    locationMultiplier = 1.3;
  }

  return Math.min(10, Math.round(baseComplexity * locationMultiplier));
}

/**
 * Assess customer urgency based on emergency flag and timeline
 */
function assessCustomerUrgency(isEmergency, timelineRequested, problemSeverity) {
  if (isEmergency) return 10;

  const urgencyMap = {
    'today': 9,
    'tomorrow': 8,
    'this week': 7,
    'next week': 5,
    'asap': 8,
    'soon': 6,
    'flexible': 3
  };

  const timeline = (timelineRequested || '').toLowerCase();
  const timelineUrgency = urgencyMap[timeline] || 4;

  let severityBoost = 0;
  const severity = (problemSeverity || '').toLowerCase();
  if (severity.includes('flooding') || severity.includes('no water') || severity.includes('burst')) {
    severityBoost = 2;
  }

  return Math.min(10, timelineUrgency + severityBoost);
}

/**
 * Format Q&A data for AI analysis
 */
function formatAnswersForAnalysis(answers) {
  if (!Array.isArray(answers)) return 'No answers provided';
  return answers
    .map((qa, index) => `Q${index + 1}: ${qa.question}\nA${index + 1}: ${qa.answer}`)
    .join('\n\n');
}

/**
 * Run triage analysis on a request
 */
async function runTriageAnalysis(requestData) {
  if (!openAiClient) {
    throw new Error('OpenAI API key not configured');
  }

  logger.log('[TriageAgent] Starting triage analysis for request:', requestData.id);

  const {
    problem_category,
    is_emergency,
    answers,
    problem_description,
    service_address,
    preferred_timing,
    property_type,
    additional_notes
  } = requestData;

  const complexityScore = calculateJobComplexity(
    problem_category,
    problem_description,
    additional_notes
  );

  const urgencyScore = assessCustomerUrgency(
    is_emergency,
    preferred_timing,
    problem_description
  );

  const formattedAnswers = formatAnswersForAnalysis(answers);

  const analyzeNode = yamlConfig.nodes.find(node => node.id === 'analyze_request');
  if (!analyzeNode) {
    throw new Error('analyze_request node not found in triage-agent.yaml');
  }

  const systemPrompt = `${analyzeNode.prompt}

**Request Details:**
- Service Category: ${problem_category}
- Emergency Status: ${is_emergency ? 'YES - EMERGENCY' : 'No'}
- Property Type: ${property_type || 'Not specified'}
- Preferred Timing: ${preferred_timing || 'Not specified'}
- Service Address: ${service_address || 'Not specified'}

**Problem Description:**
${problem_description || 'Not provided'}

**Customer Answers to Questions:**
${formattedAnswers}

**Additional Notes:**
${additional_notes || 'None'}

**Preliminary Scores:**
- Calculated Complexity: ${complexityScore}/10
- Calculated Urgency: ${urgencyScore}/10

Return your analysis as a JSON object matching the specified output schema.`;

  try {
    const model = analyzeNode.model;
    console.log('[LOG] [TriageAgent] Using AI model:', model);

    const isGpt5Model = model?.startsWith('gpt-5');
    const isGpt4oModel = model?.startsWith('gpt-4o');

    let response;
    let maxTokens = 4000; // Increased from 2000 to 4000 for more reliable completions
    let retryCount = 0;
    const maxRetries = 2; // Increased from 1 to 2 retries

    while (retryCount <= maxRetries) {
      if (isGpt5Model) {
        const responseParams = {
          model: model,
          input: `${systemPrompt}\n\nPlease analyze this plumbing service request and provide the triage assessment.`,
          reasoning: { effort: "medium" },
          text: { verbosity: "medium" },
          max_output_tokens: maxTokens,
          tools: [{
            type: "function",
            name: "provide_triage_assessment",
            description: "Provide a structured triage assessment for a plumbing service request",
            parameters: analyzeNode.output
          }],
          tool_choice: { type: "function", name: "provide_triage_assessment" }
        };

        response = await openAiClient.responses.create(responseParams);
      } else {
        const apiParams = {
          model: model,
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: 'Please analyze this plumbing service request and provide the triage assessment.' }
          ],
          response_format: { type: 'json_object' },
          tools: [{
            type: 'function',
            function: {
              name: 'provide_triage_assessment',
              description: 'Provide a structured triage assessment for a plumbing service request',
              parameters: analyzeNode.output
            }
          }],
          tool_choice: { type: 'function', function: { name: 'provide_triage_assessment' } }
        };

        if (isGpt4oModel) {
          apiParams.max_completion_tokens = maxTokens;
        } else {
          apiParams.max_tokens = maxTokens;
        }

        response = await openAiClient.chat.completions.create(apiParams);
      }

      // Check if response is complete for GPT-5 models
      if (isGpt5Model && response.status === 'incomplete' && response.incomplete_details?.reason === 'max_output_tokens' && retryCount < maxRetries) {
        logger.log(`[TriageAgent] Response incomplete due to max_output_tokens, retrying with higher limit. Attempt ${retryCount + 1}/${maxRetries}`);
        maxTokens = Math.min(maxTokens * 2, 16000); // Double tokens, max 16000 (increased from 8000)
        retryCount++;
        continue;
      }

      break; // Exit loop if response is complete or not retrying
    }

    // üîπ NEW: Hardened parsing logic
    let analysis;
    if (isGpt5Model) {
      const toolCall = response.output?.find(o => o.type === "function_call");
      if (toolCall?.arguments) {
        try {
          analysis = JSON.parse(toolCall.arguments);
        } catch (err) {
          logger.error("[TriageAgent] Failed to parse function_call arguments JSON:", err.message);
        }
      }

      if (!analysis && response.output_text) {
        try {
          analysis = JSON.parse(response.output_text);
          logger.log("[TriageAgent] Fallback: parsed JSON from output_text");
        } catch (err) {
          logger.error("[TriageAgent] Failed to parse output_text JSON:", err.message);
        }
      }
    } else {
      const toolCall = response.choices[0]?.message?.tool_calls?.[0];
      if (toolCall?.function?.arguments) {
        try {
          analysis = JSON.parse(toolCall.function.arguments);
        } catch (err) {
          logger.error("[TriageAgent] Failed to parse tool_call arguments JSON:", err.message);
        }
      }
    }

    logger.log("[DEBUG] OpenAI raw response:", JSON.stringify(response, null, 2));

    if (!analysis) {
      // Fallback: generate basic analysis from preliminary scores
      logger.log("[TriageAgent] No parsable analysis from AI, using fallback based on preliminary scores");
      analysis = {
        triage_summary: `Basic triage assessment based on preliminary analysis. Service category: ${problem_category}. Emergency: ${is_emergency ? 'Yes' : 'No'}.`,
        priority_score: Math.min(10, Math.max(1, Math.round((complexityScore + urgencyScore) / 2))),
        priority_explanation: `Priority based on complexity (${complexityScore}/10) and urgency (${urgencyScore}/10) scores.`,
        profitability_score: Math.min(10, Math.max(1, Math.round(complexityScore * 0.8))), // Assume profitability correlates with complexity
        profitability_explanation: `Profitability estimated based on job complexity (${complexityScore}/10).`,
        required_expertise: {
          skill_level: complexityScore >= 8 ? 'master' : complexityScore >= 6 ? 'journeyman' : 'apprentice',
          specialized_skills: [problem_category.replace('_', ' ')],
          reasoning: `Skill level determined by job complexity score of ${complexityScore}/10.`
        }
      };
    }

    logger.log('[TriageAgent] Analysis completed:', {
      priority: analysis.priority_score,
      profitability: analysis.profitability_score,
      expertise: analysis.required_expertise?.skill_level
    });

    return {
      triage_summary: analysis.triage_summary,
      priority_score: analysis.priority_score,
      priority_explanation: analysis.priority_explanation,
      profitability_score: analysis.profitability_score,
      profitability_explanation: analysis.profitability_explanation,
      required_expertise: analysis.required_expertise,
      complexity_score: complexityScore,
      urgency_score: urgencyScore
    };

  } catch (error) {
    console.error('[TriageAgent] Error during analysis:', error);
    throw error;
  }
}

// Netlify function handler
export async function handler(event, context) {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Access-Control-Allow-Methods': 'POST, OPTIONS'
      },
      body: ''
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const requestData = JSON.parse(event.body);
    logger.log('[TriageAgent] Received triage request for:', requestData.id);

    const analysis = await runTriageAnalysis(requestData);

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify(analysis)
    };

  } catch (error) {
    console.error('[TriageAgent] Error:', error);

    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({
        error: 'Triage analysis failed',
        message: error.message
      })
    };
  }
}

--- END OF FILE ---

--- START OF FILE ./packages/backend/package.json ---

{
  "name": "@plumbingpoc/backend",
  "version": "1.0.0",
  "type": "module",
  "main": "api/server.js",
  "scripts": {
    "start": "node start.js"
  }
}

--- END OF FILE ---

--- START OF FILE ./packages/backend/src/lib/logger.js ---

// packages/backend/src/lib/logger.js
// Simple logger for backend - uses console.log directly
// since backend doesn't need environment-controlled logging like frontend

const logger = {
  log: (...args) => console.log('[LOG]', ...args),
  error: (...args) => console.error('[ERROR]', ...args),
  warn: (...args) => console.warn('[WARN]', ...args),
  info: (...args) => console.info('[INFO]', ...args),
  debug: (...args) => console.debug('[DEBUG]', ...args)
};

export { logger };

--- END OF FILE ---

--- START OF FILE ./packages/backend/start.js ---

// packages/backend/start.js
import app from './api/server.js';
import dotenv from 'dotenv';
import { logger } from './src/lib/logger.js';

dotenv.config({ path: '../../.env' });

const PORT = process.env.BACKEND_PORT || 3000;

app.listen(PORT, () => {
  logger.log(`LOCAL DEV: API server running on http://localhost:${PORT}`);
});

--- END OF FILE ---

--- START OF FILE ./packages/frontend/config/netlify/vite.config.js ---

import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path'; // Import path module

export default defineConfig(({ mode }) => {
  // Load environment variables from .env file based on the current mode
  const env = loadEnv(mode, path.resolve(process.cwd(), '..', '..'), ''); // Load from project root

  // Check if we're running under Netlify dev (which handles API routing itself)
  const isNetlifyDev = process.env.NETLIFY_DEV || process.env.NETLIFY;

  return {
    plugins: [react()],
    server: {
      proxy: isNetlifyDev ? undefined : {
        '/api': (env.VITE_BACKEND_BASE_URL || 'http://localhost:3000').replace(/\/$/, '')
      }
    }
  };
});

--- END OF FILE ---

--- START OF FILE ./packages/frontend/package.json ---

{
  "name": "@plumbingpoc/frontend",
  "version": "1.0.0",
  "type": "module",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "tsc --noEmit && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  }
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/components/examples/RealtimeDemo.tsx ---

// packages/frontend/src/components/examples/RealtimeDemo.tsx

import React from 'react';
import {
  useUserRequests,
  useAllRequests,
  useAdminDashboard,
  useStatistics
} from '../../hooks';
import { useAuth } from '../../features/auth/AuthContext';

/**
 * Demo component showing how to use the new real-time system
 * This component will automatically update when database changes occur
 */
export const RealtimeDemo: React.FC = () => {
  const { user, profile } = useAuth();
  const isAdmin = profile?.role === 'admin';

  if (!user) {
    return <div>Please log in to see real-time demo</div>;
  }

  return (
    <div className="p-6 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">Real-Time System Demo</h1>

      {isAdmin ? <AdminDemo /> : <UserDemo userId={user.id} />}

      <div className="mt-8 p-4 bg-gray-100 rounded">
        <h3 className="font-semibold mb-2">üîÑ Real-Time Features:</h3>
        <ul className="text-sm space-y-1">
          <li>‚Ä¢ Data updates automatically when database changes</li>
          <li>‚Ä¢ No manual refresh needed</li>
          <li>‚Ä¢ Works across multiple browser tabs/windows</li>
          <li>‚Ä¢ Optimized for performance with intelligent caching</li>
        </ul>
      </div>
    </div>
  );
};

const UserDemo: React.FC<{ userId: string }> = ({ userId }) => {
  const { data: requests, loading, error } = useUserRequests(userId);

  if (loading) return <div>Loading your requests...</div>;
  if (error) return <div className="text-red-500">Error: {error}</div>;

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">Your Requests (Real-Time)</h2>

      <div className="grid gap-4 md:grid-cols-2">
        <div className="p-4 border rounded">
          <h3 className="font-medium mb-2">üìä Quick Stats</h3>
          <div className="space-y-1 text-sm">
            <div>Total Requests: <span className="font-semibold">{requests.length}</span></div>
            <div>New: <span className="font-semibold text-blue-600">
              {requests.filter(r => r.status === 'new').length}
            </span></div>
            <div>Quoted: <span className="font-semibold text-green-600">
              {requests.filter(r => r.status === 'quoted').length}
            </span></div>
            <div>Completed: <span className="font-semibold text-gray-600">
              {requests.filter(r => r.status === 'completed').length}
            </span></div>
          </div>
        </div>

        <div className="p-4 border rounded">
          <h3 className="font-medium mb-2">üìù Recent Requests</h3>
          <div className="space-y-2">
            {requests.slice(0, 3).map(request => (
              <div key={request.id} className="text-sm p-2 bg-gray-50 rounded">
                <div className="font-medium">{request.problem_category?.substring(0, 40)}...</div>
                <div className="text-gray-500">
                  Status: <span className="capitalize">{request.status}</span>
                </div>
              </div>
            ))}
            {requests.length === 0 && (
              <div className="text-gray-500 text-sm">No requests yet</div>
            )}
          </div>
        </div>
      </div>

      <div className="text-sm text-gray-600 mt-4">
        üí° <strong>Try this:</strong> Open another browser window as admin, add a quote to one of your requests,
        and watch this page update automatically!
      </div>
    </div>
  );
};

const AdminDemo: React.FC = () => {
  const { requests, users, quotes, loading } = useAdminDashboard();
  const { stats } = useStatistics();

  if (loading) return <div>Loading admin dashboard...</div>;

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-semibold">Admin Dashboard (Real-Time)</h2>

      {/* Real-time Statistics */}
      <div className="grid gap-4 md:grid-cols-4">
        <div className="p-4 border rounded bg-blue-50">
          <div className="text-2xl font-bold text-blue-600">{stats.totalRequests}</div>
          <div className="text-sm text-gray-600">Total Requests</div>
        </div>
        <div className="p-4 border rounded bg-yellow-50">
          <div className="text-2xl font-bold text-yellow-600">{stats.newRequests}</div>
          <div className="text-sm text-gray-600">New Requests</div>
        </div>
        <div className="p-4 border rounded bg-green-50">
          <div className="text-2xl font-bold text-green-600">{stats.quotedRequests}</div>
          <div className="text-sm text-gray-600">Quoted</div>
        </div>
        <div className="p-4 border rounded bg-red-50">
          <div className="text-2xl font-bold text-red-600">{stats.emergencyRequests}</div>
          <div className="text-sm text-gray-600">Emergency</div>
        </div>
      </div>

      {/* Recent Activity */}
      <div className="grid gap-4 md:grid-cols-2">
        <div className="p-4 border rounded">
          <h3 className="font-medium mb-3">üìã Recent Requests</h3>
          <div className="space-y-2 max-h-60 overflow-y-auto">
            {requests.slice(0, 5).map(request => (
              <div key={request.id} className="text-sm p-2 bg-gray-50 rounded">
                <div className="font-medium">{request.problem_category?.substring(0, 50)}...</div>
                <div className="text-gray-500 flex justify-between">
                  <span>Status: <span className="capitalize">{request.status}</span></span>
                  <span>Priority: {request.priority_score || 'N/A'}</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        <div className="p-4 border rounded">
          <h3 className="font-medium mb-3">üë• User Overview</h3>
          <div className="space-y-2">
            <div className="text-sm">
              <span className="font-medium">Total Users:</span> {users.length}
            </div>
            <div className="text-sm">
              <span className="font-medium">Total Quotes:</span> {quotes.length}
            </div>
            <div className="text-sm text-gray-500">
              Last updated: {new Date().toLocaleTimeString()}
            </div>
          </div>
        </div>
      </div>

      <div className="text-sm text-gray-600 mt-4">
        üí° <strong>Try this:</strong> Open another browser window as a user, create a new request,
        and watch the statistics above update in real-time!
      </div>
    </div>
  );
};

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/admin/components/MapView.tsx ---

import React, { useState } from 'react';
import { APIProvider, Map, AdvancedMarker, InfoWindow } from '@vis.gl/react-google-maps';
import { Box, Paper, Typography, Button } from '@mui/material';
import { QuoteRequest } from '../../requests/types';
import { getRequestStatusPinColor } from '../../../lib/statusColors';

interface MapViewProps {
  requests: QuoteRequest[];
  onRequestSelect: (request: QuoteRequest) => void;
}

const MapView: React.FC<MapViewProps> = ({ requests, onRequestSelect }) => {
  const [selectedRequest, setSelectedRequest] = useState<QuoteRequest | null>(null);

  const apiKey = import.meta.env.VITE_GOOGLE_MAPS_API_KEY;
  // Map ID for cloud-based Google Maps styling (Light Political style)
  const mapId = import.meta.env.VITE_GOOGLE_MAPS_ID;

  if (!apiKey) {
    return (
      <Paper sx={{ height: 600, width: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <Box sx={{ textAlign: 'center' }}>
          <Typography variant="h6" color="error">
            Google Maps API Key Missing
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Please set VITE_GOOGLE_MAPS_API_KEY in your environment variables
          </Typography>
        </Box>
      </Paper>
    );
  }

  if (!mapId) {
    return (
      <Paper sx={{ height: 600, width: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
        <Box sx={{ textAlign: 'center' }}>
          <Typography variant="h6" color="error">
            Google Maps ID Missing
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Please set VITE_GOOGLE_MAPS_ID in your environment variables for Light Political map style
          </Typography>
        </Box>
      </Paper>
    );
  }

  const geocodedRequests = requests.filter(
    request => request.latitude && request.longitude
  );


  const handleMarkerClick = (request: QuoteRequest) => {
    setSelectedRequest(request);
  };

  const handleCloseInfoWindow = () => {
    setSelectedRequest(null);
  };

  return (
    <Paper sx={{ height: 600, width: '100%', position: 'relative' }}>
      <APIProvider apiKey={apiKey}>
        <Map
          defaultCenter={{ lat: 48.4284, lng: -123.3656 }}
          defaultZoom={10}
          mapId={mapId}
          style={{ width: '100%', height: '100%' }}
        >
          {geocodedRequests.map((request) => (
            <AdvancedMarker
              key={request.id}
              position={{ lat: request.latitude!, lng: request.longitude! }}
              onClick={() => handleMarkerClick(request)}
            >
              <Box
                sx={{
                  width: 20,
                  height: 20,
                  borderRadius: '50%',
                  backgroundColor: getRequestStatusPinColor(request.status),
                  border: '2px solid white',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.3)',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Box
                  sx={{
                    width: 8,
                    height: 8,
                    borderRadius: '50%',
                    backgroundColor: 'white',
                  }}
                />
              </Box>
            </AdvancedMarker>
          ))}

          {selectedRequest && (
            <InfoWindow
              position={{ lat: selectedRequest.latitude!, lng: selectedRequest.longitude! }}
              onCloseClick={handleCloseInfoWindow}
            >
              <Box sx={{ p: 1, minWidth: 250 }}>
                <Typography variant="h6" sx={{ mb: 1 }}>
                  {selectedRequest.user_profiles?.name || selectedRequest.customer_name || 'Unknown Customer'}
                </Typography>
                <Typography variant="body2" sx={{ mb: 1 }}>
                  {selectedRequest.service_address}
                </Typography>
                <Typography variant="body2" sx={{ mb: 2, color: 'text.secondary' }}>
                  Status: {selectedRequest.status}
                </Typography>
                <Button
                  variant="contained"
                  size="small"
                  onClick={() => {
                    onRequestSelect(selectedRequest);
                    handleCloseInfoWindow();
                  }}
                >
                  View Full Job Docket
                </Button>
              </Box>
            </InfoWindow>
          )}
        </Map>
      </APIProvider>

      {geocodedRequests.length === 0 && (
        <Box
          sx={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            zIndex: 1000,
          }}
        >
          <Typography variant="h6" color="text.secondary">
            No geocoded requests to display
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Requests need latitude and longitude coordinates to appear on the map
          </Typography>
        </Box>
      )}
    </Paper>
  );
};

export default MapView;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/auth/AuthContext.tsx ---

import React, { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '../../lib/supabaseClient';
import { logger } from '../../lib/logger';
import { Session, User } from '@supabase/supabase-js';

// Define a more specific type for your profile data
export interface UserProfile {
  user_id: string;
  name: string;
  email?: string;
  phone?: string;
  address?: string;
  city?: string;
  province?: string;
  postal_code?: string;
  role?: string;
}

interface AuthContextType {
  user: User | null;
  profile: UserProfile | null;
  loading: boolean;
  profileIncomplete: boolean;
  refreshProfile: () => void;
  signOut: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState(true);
  const [profileIncomplete, setProfileIncomplete] = useState(false);

  useEffect(() => {
    const getInitialSession = async () => {
      logger.log('üîê AuthContext: Getting initial session...');
      const { data: { session }, error } = await supabase.auth.getSession();

      if (error) {
        logger.error('‚ùå AuthContext: Session error:', error);
      } else {
        logger.log('‚úÖ AuthContext: Session retrieved:', !!session, 'User:', !!session?.user);
      }

      setUser(session?.user ?? null);
      setLoading(false);
    };

    getInitialSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((event, session) => {
      logger.log('üîÑ AuthContext: Auth state changed:', event, 'User ID:', session?.user?.id || 'null', 'Email:', session?.user?.email || 'null');
      setUser(session?.user ?? null);
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, []);

  const fetchProfile = async (currentUser: User | null) => {
    if (currentUser) {
      logger.log('üë§ AuthContext: Fetching profile for user:', currentUser.id);
      const { data, error } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('user_id', currentUser.id)
        .single();

      if (error && error.code !== 'PGRST116') { // PGRST116 = no rows found
        logger.error('‚ùå AuthContext: Error fetching profile:', error);
      } else if (error && error.code === 'PGRST116') {
        logger.log('‚ÑπÔ∏è AuthContext: No profile found for user (this is normal for new users)');
      } else {
        logger.log('‚úÖ AuthContext: Profile loaded:', data ? 'complete' : 'null');
      }

      setProfile(data);
      // A profile is incomplete if it doesn't exist, or if the required 'name' field is missing.
      const incomplete = !data || !data.name;
      setProfileIncomplete(incomplete);
      logger.log('üìä AuthContext: Profile status - Complete:', !incomplete, 'Incomplete:', incomplete);
    } else {
      logger.log('üë§ AuthContext: No user, clearing profile');
      setProfile(null);
      setProfileIncomplete(false);
    }
  };

  useEffect(() => {
    fetchProfile(user);
  }, [user]);

  const signOut = async () => {
    logger.log('üö™ AuthContext: Signing out user...');
    await supabase.auth.signOut();
    logger.log('‚úÖ AuthContext: Sign out complete');
    setUser(null);
    setProfile(null);
    // Redirect to home page after sign out
    window.location.hash = '';
  };

  const refreshProfile = () => fetchProfile(user);

  return (
    <AuthContext.Provider value={{ user, profile, loading, profileIncomplete, refreshProfile, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/auth/components/AuthModal.tsx ---

import React from 'react';
import { supabase } from '../../../lib/supabaseClient';
import { logger } from '../../../lib/logger';
import ModalHeader from '../../requests/components/ModalHeader';
import { User, Mail, Lock } from 'lucide-react';

interface AuthModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const AuthModal: React.FC<AuthModalProps> = ({ isOpen, onClose }) => {
  const [isSignUp, setIsSignUp] = React.useState(false);
  const [name, setName] = React.useState('');
  const [message, setMessage] = React.useState<string | null>(null);
  const [messageType, setMessageType] = React.useState<'success' | 'error' | 'info'>('info');
  const [loading, setLoading] = React.useState(false);
  if (!isOpen) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-40">
      <div className="bg-gray-50 rounded-xl shadow-2xl max-w-md w-full relative overflow-hidden">
        <ModalHeader title={isSignUp ? 'Create Your Account' : 'Sign In to Your Portal'} onClose={onClose} />
        <div className="p-8 space-y-6">
        <button
          className="bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold w-full mb-4"
          onClick={async () => {
            logger.log('üîê Starting Google OAuth sign-in...');
            try {
              const result = await supabase.auth.signInWithOAuth({ provider: 'google' });
              logger.log('üîç Google OAuth initiated:', result);
            } catch (error) {
              logger.error('‚ùå Google OAuth error:', error);
            }
          }}
        >
          Continue with Google
        </button>
        <button
          className="bg-gray-900 text-white px-6 py-3 rounded-lg font-semibold w-full mb-4"
          onClick={async () => {
            logger.log('üîê Starting Microsoft OAuth sign-in...');
            try {
              const result = await supabase.auth.signInWithOAuth({ provider: 'azure' });
              logger.log('üîç Microsoft OAuth initiated:', result);
            } catch (error) {
              logger.error('‚ùå Microsoft OAuth error:', error);
            }
          }}
        >
          Continue with Microsoft
        </button>

        {/* Divider with text */}
        <div className="relative flex py-5 items-center">
          <div className="flex-grow border-t border-gray-300"></div>
          <span className="flex-shrink mx-4 text-gray-500 text-sm">Or continue with</span>
          <div className="flex-grow border-t border-gray-300"></div>
        </div>

        <form
          className="mt-4"
          onSubmit={async e => {
            e.preventDefault();
            setLoading(true);
            setMessage(null);
            const email = (e.target as any).email.value;
            const password = (e.target as any).password.value;
            try {
              if (isSignUp) {
                logger.log('üîê Starting email/password sign-up process...');
                logger.log('üìß Email:', email);
                logger.log('üë§ Name:', name);
                const { data, error } = await supabase.auth.signUp({ email, password });
                logger.log('üîç Sign-up response:', { data: data ? 'present' : 'null', error: error ? error.message : 'null' });
                if (error) {
                  logger.error('‚ùå Sign-up error:', error);
                  setMessage(error.message || 'Sign up failed.');
                  setMessageType('error');
                } else if (data.user) {
                  logger.log('‚úÖ Sign-up successful, creating user profile...');
                  await supabase.from('user_profiles').insert({ user_id: data.user.id, name });
                  logger.log('‚úÖ User profile created');
                  setMessage('Sign up successful! Please check your email and click the confirmation link before signing in.');
                  setMessageType('success');
                }
              } else {
                logger.log('üîê Starting email/password sign-in process...');
                logger.log('üìß Email:', email);
                const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                logger.log('üîç Sign-in response:', { data: data ? 'present' : 'null', error: error ? error.message : 'null' });
                if (error) {
                  logger.error('‚ùå Sign-in error:', error);
                  setMessage(error.message || 'Sign in failed.');
                  setMessageType('error');
                } else {
                  logger.log('‚úÖ Sign-in successful, user data:', data?.user ? 'present' : 'null');
                  setMessage('Sign in successful!');
                  setMessageType('success');
                  setTimeout(() => {
                    setMessage(null);
                    onClose();
                  }, 1200);
                }
              }
            } catch (err: any) {
              setMessage(err.message || 'An error occurred.');
              setMessageType('error');
            } finally {
              setLoading(false);
            }
          }}
        >
          {isSignUp && (
            <div className="relative mb-3">
              <User className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <input
                name="name"
                type="text"
                placeholder="Full Name"
                className="border border-gray-300 px-10 py-3 rounded-lg w-full shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
                value={name}
                onChange={e => setName(e.target.value)}
                required
              />
            </div>
          )}
          <div className="relative mb-3">
            <Mail className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
            <input
              name="email"
              type="email"
              placeholder="Email"
              className="border border-gray-300 px-10 py-3 rounded-lg w-full shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
              required
            />
          </div>
          <div className="relative mb-4">
            <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
            <input
              name="password"
              type="password"
              placeholder="Password"
              className="border border-gray-300 px-10 py-3 rounded-lg w-full shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
              required
            />
          </div>
          <button type="submit" className="bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold w-full" disabled={loading}>
            {loading ? (isSignUp ? 'Signing Up...' : 'Signing In...') : (isSignUp ? 'Sign Up with Email' : 'Sign In with Email')}
          </button>
        {message && (
          <div className={`mt-2 text-center text-sm ${messageType === 'success' ? 'text-green-600' : messageType === 'error' ? 'text-red-600' : 'text-gray-600'}`}>
            {message}
          </div>
        )}
        </form>
        <div className="mt-4 text-center">
          {isSignUp ? (
            <span className="text-sm">Already have an account?{' '}
              <button className="text-blue-600 underline" onClick={() => setIsSignUp(false)}>Sign In</button>
            </span>
          ) : (
            <span className="text-sm">Don't have an account?{' '}
              <button className="text-blue-600 underline" onClick={() => setIsSignUp(true)}>Sign Up</button>
            </span>
          )}
        </div>
      </div>
    </div>
    </div>
  );
};

export default AuthModal;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/auth/components/UserMenu.tsx ---

import React, { useState } from 'react';
import { User, LogOut, Settings, ChevronDown, LayoutDashboard, ListChecks } from 'lucide-react';
import { useAuth } from '../AuthContext';
import { logger } from '../../../lib/logger';

interface UserMenuProps {
  onOpenProfile: () => void;
  onNavigateToDashboard?: () => void;
}

const UserMenu: React.FC<UserMenuProps> = ({ onOpenProfile, onNavigateToDashboard }) => {
  const [isOpen, setIsOpen] = useState(false);
  const { user, profile, signOut } = useAuth();

  logger.log('üë§ UserMenu Debug:', {
    userId: user?.id,
    userEmail: user?.email,
    profileRole: profile?.role,
    profileName: profile?.name,
    isAdmin: profile?.role === 'admin',
    hasNavigateCallback: !!onNavigateToDashboard
  });

  if (!user) return null;

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg hover:bg-gray-700 transition-colors"
      >
        <div className="w-8 h-8 bg-gradient-to-r from-blue-500 to-blue-700 rounded-full flex items-center justify-center">
          <User className="w-4 h-4 text-white" />
        </div>
        <div className="text-left">
          <span className="text-sm font-medium text-white">Dashboard</span>
        </div>
        <ChevronDown className="w-4 h-4 text-gray-400" />
      </button>
      {isOpen && (
        <>
          <div className="fixed inset-0 z-10" onClick={() => setIsOpen(false)} />
          <div className="absolute right-0 mt-2 w-56 bg-gray-800 border border-gray-600 rounded-lg shadow-lg z-20">
            <div className="p-3 border-b border-gray-600">
              <div className="text-sm font-medium text-white">
                {profile?.name || 'User'}
              </div>
              <div className="text-xs text-gray-400">
                {user.email}
              </div>
            </div>
            <div className="py-1">
              {(() => {
                logger.log('üîç Command Center render check:', {
                  hasProfile: !!profile,
                  profileRole: profile?.role,
                  isAdmin: profile?.role === 'admin',
                  shouldShowCommandCenter: profile && profile.role === 'admin'
                });
                return profile && profile.role === 'admin' && (
                  <button
                    onClick={() => {
                      logger.log('üöÄ Command Center clicked!');
                      setIsOpen(false);
                      if (onNavigateToDashboard) {
                        logger.log('‚úÖ Calling onNavigateToDashboard callback');
                        onNavigateToDashboard();
                      } else {
                        logger.log('‚ùå No onNavigateToDashboard callback provided');
                      }
                    }}
                    className="flex items-center gap-2 w-full px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 hover:text-white transition-colors"
                  >
                    <LayoutDashboard className="w-4 h-4" />
                    Command Center
                  </button>
                );
               })()}
               {profile && profile.role !== 'admin' && (
                 <a
                   href="/#/dashboard"
                   onClick={(e) => {
                     e.preventDefault();
                     window.location.hash = '#/dashboard';
                     setIsOpen(false);
                   }}
                   className="flex items-center gap-2 w-full px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 hover:text-white transition-colors"
                 >
                   <ListChecks className="w-4 h-4" />
                   My Quote Requests
                 </a>
               )}
               <button
                onClick={() => {
                  onOpenProfile();
                  setIsOpen(false);
                }}
                className="flex items-center gap-2 w-full px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 hover:text-white transition-colors"
              >
                <Settings className="w-4 h-4" />
                Profile Settings
              </button>
              <button
                onClick={signOut}
                className="flex items-center gap-2 w-full px-3 py-2 text-sm text-red-400 hover:bg-gray-700 hover:text-red-300 transition-colors"
              >
                <LogOut className="w-4 h-4" />
                Sign Out
              </button>
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default UserMenu;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/landing/components/AboutSection.tsx ---

/**
 * =============================================================================
 * AboutSection.tsx - About Section Component
 * =============================================================================
 *
 * WHAT IS THIS COMPONENT?
 * -----------------------
 * The AboutSection component displays information about AquaFlow Plumbing
 * company, including their experience, values, and key differentiators.
 * This is part of the landing page and helps build trust with potential customers.
 *
 * COMPONENT FEATURES:
 * -------------------
 * - Company overview with 15+ years experience
 * - Professional credentials (licensed, insured, 24/7 emergency)
 * - Quality guarantees and customer satisfaction metrics
 * - Responsive design with mobile-first approach
 * - Visual elements with icons and company photo
 *
 * LAYOUT STRUCTURE:
 * -----------------
 * - Left side: Company photo (hidden on mobile)
 * - Right side: Company description and feature grid
 * - Feature grid: 4 key value propositions with icons
 *
 * RESPONSIVE BEHAVIOR:
 * -------------------
 * - Desktop: 2-column grid with photo and content
 * - Mobile: Single column with content only
 *
 * ICONS USED:
 * -----------
 * - Shield: Licensed & Insured
 * - Clock: 24/7 Emergency Service
 * - CheckCircle: Quality Guarantee
 * - Star: 5-Star Rated
 *
 * STYLING:
 * --------
 * - Uses Tailwind CSS classes
 * - Blue color scheme matching brand
 * - Rounded corners and shadows for visual appeal
 * - Hover effects on interactive elements
 */

import React from 'react';
import { Shield, Clock, CheckCircle, Star } from 'lucide-react';

const AboutSection: React.FC = () => (
  <section id="about" className="py-20 bg-white">
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 grid lg:grid-cols-2 gap-12 items-center">
      <div className="hidden lg:block">
        <img src="/plumber.jpg" alt="AquaFlow Plumbing company team photo" className="rounded-lg shadow-lg w-full h-64 object-cover" />
      </div>
      <div>
        <h2 className="text-3xl md:text-4xl font-bold text-gray-900 mb-6">About AquaFlow Plumbing</h2>
        <p className="text-lg text-gray-600 mb-6">With over 15 years of experience serving communities across Greater Victoria, from Oak Bay to Saanich and Langford, AquaFlow Plumbing has built a reputation for reliable, professional service and competitive pricing.</p>
        <p className="text-lg text-gray-600 mb-8">Our team of licensed professionals is committed to providing the highest quality workmanship and customer service. We use the latest tools and techniques to ensure your plumbing systems work perfectly.</p>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 mt-8">
          <div className="bg-white p-6 rounded-lg shadow-md border border-gray-100 flex items-center gap-4">
            <Shield className="w-8 h-8 text-blue-600" />
            <div>
              <h4 className="font-semibold text-gray-900">Licensed & Insured</h4>
              <p className="text-gray-600 text-sm">Full coverage protection for your peace of mind.</p>
            </div>
          </div>
          <div className="bg-white p-6 rounded-lg shadow-md border border-gray-100 flex items-center gap-4">
            <Clock className="w-8 h-8 text-blue-600" />
            <div>
              <h4 className="font-semibold text-gray-900">24/7 Emergency</h4>
              <p className="text-gray-600 text-sm">Always available when you need us most.</p>
            </div>
          </div>
          <div className="bg-white p-6 rounded-lg shadow-md border border-gray-100 flex items-center gap-4">
            <CheckCircle className="w-8 h-8 text-green-500" />
            <div>
              <h4 className="font-semibold text-gray-900">Quality Guarantee</h4>
              <p className="text-gray-600 text-sm">100% satisfaction on all workmanship.</p>
            </div>
          </div>
          <div className="bg-white p-6 rounded-lg shadow-md border border-gray-100 flex items-center gap-4">
            <Star className="w-8 h-8 text-yellow-500" />
            <div>
              <h4 className="font-semibold text-gray-900">5-Star Rated</h4>
              <p className="text-gray-600 text-sm">Proven customer satisfaction and top reviews.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
);

export default AboutSection;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/landing/components/ContactSection.tsx ---

/**
 * =============================================================================
 * ContactSection.tsx - Contact Information Component
 * =============================================================================
 *
 * WHAT IS THIS COMPONENT?
 * -----------------------
 * The ContactSection component provides all contact information for AquaFlow
 * Plumbing, including phone numbers, service areas, email, and business hours.
 * It also prominently features emergency service availability.
 *
 * COMPONENT FEATURES:
 * -------------------
 * - Contact information grid with icons
 * - Emergency service call-to-action
 * - Direct phone number links (tel: protocol)
 * - Responsive layout (2-column on desktop, stacked on mobile)
 * - Dark theme matching footer styling
 *
 * CONTACT INFORMATION DISPLAYED:
 * -----------------------------
 * - Phone: (555) 123-4567 (call or text)
 * - Service Area: Greater Metro Area
 * - Email: info@aquaflowplumbing.com
 * - Business Hours: 24/7 Emergency Service
 *
 * LAYOUT STRUCTURE:
 * -----------------
 * - Left side (2/3 width): Main contact info grid
 * - Right side (1/3 width): Emergency service callout box
 * - Emergency box: Red CTA button with phone icon
 *
 * RESPONSIVE BEHAVIOR:
 * -------------------
 * - Desktop: 3-column grid (2 for contact info, 1 for emergency)
 * - Tablet: 2-column contact grid, stacked emergency box
 * - Mobile: Single column stack
 *
 * ICONS USED:
 * -----------
 * - Phone: Phone number contact
 * - MapPin: Service area coverage
 * - Mail: Email contact
 * - Clock: Business hours
 *
 * STYLING:
 * --------
 * - Dark background (bg-gray-900) with white text
 * - Blue accent color for icons and backgrounds
 * - Red emergency button for high visibility
 * - Rounded corners and proper spacing
 * - Hover effects on interactive elements
 */

import React from 'react';
import { Phone, MapPin, Mail, Clock } from 'lucide-react';

const ContactSection: React.FC = () => (
  <section id="contact" className="py-20 bg-gray-900 text-white">
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 grid lg:grid-cols-3 gap-12">
      <div className="lg:col-span-2">
        <h2 className="text-3xl md:text-4xl font-bold mb-6">Get In Touch</h2>
        <p className="text-xl text-gray-300 mb-8">Ready to solve your plumbing problems? Contact us today for fast, professional service.</p>
        <div className="grid md:grid-cols-2 gap-6">
          <div className="flex items-center space-x-4">
            <div className="bg-blue-600 p-3 rounded-full">
              <Phone className="w-6 h-6" />
            </div>
            <div>
              <div className="font-bold">Call or Text</div>
              <div className="text-gray-300">(555) 123-4567</div>
            </div>
          </div>
          <div className="flex items-center space-x-4">
            <div className="bg-blue-600 p-3 rounded-full">
              <MapPin className="w-6 h-6" />
            </div>
            <div>
              <div className="font-bold">Service Area</div>
              <div className="text-gray-300">Greater Metro Area</div>
            </div>
          </div>
          <div className="flex items-center space-x-4">
            <div className="bg-blue-600 p-3 rounded-full">
              <Mail className="w-6 h-6" />
            </div>
            <div>
              <div className="font-bold">Email Us</div>
              <div className="text-gray-300">info@aquaflowplumbing.com</div>
            </div>
          </div>
          <div className="flex items-center space-x-4">
            <div className="bg-blue-600 p-3 rounded-full">
              <Clock className="w-6 h-6" />
            </div>
            <div>
              <div className="font-bold">Business Hours</div>
              <div className="text-gray-300">24/7 Emergency Service</div>
            </div>
          </div>
        </div>
      </div>
      <div className="bg-gray-800 p-6 rounded-xl">
        <h3 className="text-xl font-semibold mb-4">Emergency Service</h3>
        <p className="text-gray-300 mb-6">Plumbing emergencies don't wait for business hours. We're available 24/7 for urgent repairs.</p>
        <a
          href="tel:555-123-4567"
          className="bg-red-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-red-700 transition-colors inline-flex items-center space-x-2 w-full justify-center"
        >
          <Phone className="w-5 h-5" />
          <span>Emergency Line</span>
        </a>
      </div>
    </div>
  </section>
);

export default ContactSection;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/landing/components/ReviewsSection.tsx ---

/**
 * =============================================================================
 * ReviewsSection.tsx - Customer Testimonials Component
 * =============================================================================
 *
 * WHAT IS THIS COMPONENT?
 * -----------------------
 * The ReviewsSection component displays customer testimonials and reviews
 * to build social proof and trust with potential customers. It showcases
 * positive experiences from real customers of AquaFlow Plumbing.
 *
 * COMPONENT FEATURES:
 * -------------------
 * - Static customer testimonials with ratings
 * - 5-star rating display with filled star icons
 * - Responsive grid layout (1 column mobile, 3 columns desktop)
 * - Hover effects and smooth transitions
 * - Professional testimonial cards with shadows
 *
 * TESTIMONIAL DATA:
 * -----------------
 * Contains 3 hardcoded testimonials:
 * 1. Jane D. - Fast, friendly service
 * 2. Mike R. - Professional team, great price
 * 3. Sara L. - Emergency service at 2am
 *
 * LAYOUT STRUCTURE:
 * -----------------
 * - Section header with title and description
 * - Grid of testimonial cards
 * - Each card contains: star rating, testimonial text, customer name
 *
 * RESPONSIVE BEHAVIOR:
 * -------------------
 * - Mobile: Single column stack
 * - Desktop: 3-column grid
 *
 * STYLING:
 * --------
 * - Light gray background (bg-gray-50)
 * - White testimonial cards with rounded corners
 * - Yellow star ratings
 * - Hover shadow effects
 * - Clean typography with italic quotes
 */

import React from 'react';
import { Star } from 'lucide-react';

const testimonials = [
  { name: "Jane D.", rating: 5, text: "Fast, friendly, and fixed my leak in no time!" },
  { name: "Mike R.", rating: 5, text: "Professional team, great price, highly recommend." },
  { name: "Sara L.", rating: 5, text: "Emergency call at 2am, they showed up and saved my basement!" }
];

const ReviewsSection: React.FC = () => (
  <section id="testimonials" className="py-20 bg-gray-50">
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div className="text-center mb-16">
        <h2 className="text-4xl font-bold text-gray-900 mb-4">What Our Customers Say</h2>
        <p className="text-xl text-gray-600">Don't just take our word for it - see what our satisfied customers have to say.</p>
      </div>
      <div className="grid md:grid-cols-3 gap-8">
        {testimonials.map((testimonial, index) => (
          <div key={index} className="bg-white p-8 rounded-2xl shadow hover:shadow-lg transition-shadow duration-300">
            <div className="flex items-center mb-4">
              {[...Array(testimonial.rating)].map((_, i) => (
                <Star key={i} className="w-6 h-6 text-yellow-400 fill-current" />
              ))}
            </div>
            <p className="text-gray-700 mb-4 italic">"{testimonial.text}"</p>
            <div className="font-bold text-gray-900">{testimonial.name}</div>
          </div>
        ))}
      </div>
    </div>
  </section>
);

export default ReviewsSection;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/landing/components/ServicesSection.tsx ---

import React from 'react';
import { ArrowRight, CheckCircle, Droplets, Wrench, Wind, Thermometer, ShowerHead, Settings } from 'lucide-react';
import { services as allServices, ServiceDefinition } from '../../../lib/serviceDefinitions';

const iconComponents: { [key: string]: React.ReactElement } = {
  Droplets: <Droplets className="w-8 h-8 text-blue-700" />,
  Wrench: <Wrench className="w-8 h-8 text-blue-700" />,
  Wind: <Wind className="w-8 h-8 text-blue-700" />,
  Thermometer: <Thermometer className="w-8 h-8 text-blue-700" />,
  ShowerHead: <ShowerHead className="w-8 h-8 text-blue-700" />,
  Settings: <Settings className="w-8 h-8 text-blue-700" />,
};

// Display all 8 services in the correct order
const mainServiceKeys = ["leak_repair", "pipe_installation", "drain_cleaning", "water_heater", "fixture_install", "gas_line_services", "perimeter_drains", "other"];
const displayServices = allServices.filter(s => mainServiceKeys.includes(s.key))
  .sort((a, b) => mainServiceKeys.indexOf(a.key) - mainServiceKeys.indexOf(b.key));

interface ServicesSectionProps {
  onServiceSelect: (service: ServiceDefinition) => void;
}

const ServicesSection: React.FC<ServicesSectionProps> = ({ onServiceSelect }) => (
  <section id="services" className="py-20 bg-gray-50">
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div className="text-center mb-16">
        <h2 className="text-4xl font-bold text-gray-900 mb-4">Professional Plumbing Services in Victoria, BC</h2>
        <p className="text-xl text-gray-600 max-w-3xl mx-auto">From emergency repairs to complete installations, we provide comprehensive plumbing solutions for homes and businesses.</p>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
        {displayServices.map((service) => (
          <button key={service.key} onClick={() => onServiceSelect(service)} className="text-left bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl transition-all duration-300 flex flex-col group hover:scale-105 relative overflow-hidden">
            <div className="relative z-10 flex flex-col h-full">
              <div className="bg-blue-100 p-3 rounded-full inline-flex mb-4 w-min">
                {iconComponents[service.icon]}
              </div>
              <div className="flex items-center gap-2 mb-2">
                <h3 className="text-lg font-bold text-gray-900">{service.title}</h3>
                {(service.key === 'leak_repair' || service.key === 'water_heater') && (
                  <span className="bg-red-100 text-red-800 text-xs font-medium px-2 py-0.5 rounded-full">Emergency</span>
                )}
              </div>
              <p className="text-gray-600 mb-4 text-sm flex-grow line-clamp-3">{service.description}</p>
              <div className="absolute bottom-6 right-6 bg-blue-600 p-2 rounded-full opacity-0 group-hover:opacity-100 transition-all duration-300 transform group-hover:scale-110">
                <ArrowRight className="text-white w-5 h-5" />
              </div>
            </div>
          </button>
        ))}
      </div>
    </div>
  </section>
);

export default ServicesSection;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/profile/components/ProfileModal.tsx ---

// packages/frontend/src/features/profile/components/ProfileModal.tsx

import React, { useState, useEffect } from 'react';
import apiClient from '../../../lib/apiClient';
import { useAuth } from '../../auth/AuthContext';
import { Box, Typography, Paper, TextField, Button, Select, MenuItem, InputLabel, FormControl, CircularProgress, IconButton } from '@mui/material';
import { X as XIcon, User, MapPin } from 'lucide-react';
import ModalHeader from '../../requests/components/ModalHeader';
import ModalFooter from '../../requests/components/ModalFooter';
import { logger } from '../../../lib/logger';

interface ProfileModalProps {
  isClosable?: boolean;
  onClose?: () => void;
  onComplete?: () => void; // <-- ADD THIS NEW PROP
}

const provinces = [
  'AB', 'BC', 'MB', 'NB', 'NL', 'NS', 'ON', 'PE', 'QC', 'SK', 'NT', 'NU', 'YT'
];

const ProfileModal: React.FC<ProfileModalProps> = ({ isClosable = false, onClose, onComplete }) => {
  const showDebugPanel = (import.meta.env.VITE_DEBUG_PANEL === 'true');

  const DebugOverlay = () => (
    <div style={{
      background: '#222',
      color: '#fff',
      padding: '10px 14px',
      borderRadius: '8px',
      fontSize: '12px',
      fontFamily: 'monospace',
      boxShadow: '0 2px 12px rgba(0,0,0,0.18)',
      opacity: 0.97,
      maxWidth: 420,
      margin: '18px auto 0 auto',
      display: 'block'
    }}>
      <div style={{ fontWeight: 600, marginBottom: 4, fontSize: '13px' }}>ProfileModal Debug</div>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '4px 16px' }}>
        <div>User ID:</div><div>{user?.id || 'none'}</div>
        <div>Email:</div><div>{email}</div>
        <div>Loading:</div><div>{String(loading)}</div>
        <div>SaveError:</div><div>{saveError || 'none'}</div>
        <div>SaveSuccess:</div><div>{String(saveSuccess)}</div>
      </div>
    </div>
  );

  const { user, profile: contextProfile } = useAuth();
  const [email, setEmail] = useState(user?.email || '');
  const [name, setName] = useState(contextProfile?.name || '');
  const [phone, setPhone] = useState(contextProfile?.phone || '');
  const [province, setProvince] = useState(contextProfile?.province || 'BC');
  const [city, setCity] = useState(contextProfile?.city || 'Victoria');
  const [address, setAddress] = useState(contextProfile?.address || '');
  const [postalCode, setPostalCode] = useState(contextProfile?.postal_code || '');
  const [loading, setLoading] = useState(false);
  const [saveError, setSaveError] = useState('');
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [geocodingStatus, setGeocodingStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');

  useEffect(() => {
    if (contextProfile) {
      setName(contextProfile.name || '');
      setPhone(contextProfile.phone || '');
      setProvince(contextProfile.province || 'BC');
      setCity(contextProfile.city || 'Victoria');
      setAddress(contextProfile.address || '');
      setPostalCode(contextProfile.postal_code || '');
    }
    if (user?.email) {
      setEmail(user.email);
    }
  }, [contextProfile, user]);

  // Reset geocoding status when address fields change
  useEffect(() => {
    if (geocodingStatus === 'success' || geocodingStatus === 'error') {
      setGeocodingStatus('idle');
    }
  }, [address, city, province, postalCode]);

  const geocodeAddress = async () => {
    if (!address.trim() || !city.trim() || !province.trim() || !postalCode.trim()) {
      return null;
    }

    setGeocodingStatus('loading');

    try {
      const fullAddress = `${address}, ${city}, ${province} ${postalCode}, Canada`;
      logger.log('Geocoding profile address:', fullAddress);

      // Load Google Maps API if not already loaded
      if (!window.google || !window.google.maps) {
        const apiKey = import.meta.env.VITE_GOOGLE_MAPS_API_KEY || 'AIzaSyDkEszizq7L57f0sY73jl99ZvvwDwZ_MGY';

        if (!apiKey) {
          throw new Error('Google Maps API key not found');
        }

        logger.log('Loading Google Maps API for profile geocoding');

        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&v=weekly&libraries=places`;
        script.async = true;
        script.defer = true;

        await new Promise((resolve, reject) => {
          script.onload = () => {
            logger.log('Google Maps API loaded for profile');
            resolve(void 0);
          };
          script.onerror = (error) => {
            console.error('Failed to load Google Maps API for profile:', error);
            reject(error);
          };
          document.head.appendChild(script);
        });
      }

      // Use Google Maps Geocoding service
      const geocoder = new (window as any).google.maps.Geocoder();

      return new Promise<{lat: number, lng: number, formattedAddress: string} | null>((resolve) => {
        geocoder.geocode({ address: fullAddress }, (results: any, status: any) => {
          logger.log('Profile geocoding response:', {
            status,
            resultsCount: results?.length,
            firstResult: results?.[0]?.formatted_address
          });

          if (status === (window as any).google.maps.GeocoderStatus.OK && results && results[0]) {
            const location = results[0].geometry.location;
            const lat = location.lat();
            const lng = location.lng();
            const formattedAddress = results[0].formatted_address;

            logger.log('Profile geocoding successful:', { lat, lng, formattedAddress });
            setGeocodingStatus('success');
            resolve({ lat, lng, formattedAddress });
          } else {
            console.error('Profile geocoding failed with status:', status);
            setGeocodingStatus('error');
            resolve(null);
          }
        });
      });

    } catch (error) {
      console.error('Profile geocoding setup error:', error);
      setGeocodingStatus('error');
      return null;
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setSaveError(''); // Clear both error states
    setSaveSuccess(false);

    // 1. EMAIL VALIDATION (read-only but check it exists)
    if (!email || !email.trim()) {
      setSaveError('Email is required but missing. Please refresh and try again.');
      setLoading(false);
      return;
    }

    // 2. NAME VALIDATION
    if (!name || !name.trim()) {
      setSaveError('Name is required');
      setLoading(false);
      return;
    }
    if (name.trim().length < 2) {
      setSaveError('Name must be at least 2 characters long');
      setLoading(false);
      return;
    }
    if (name.trim().length > 100) {
      setSaveError('Name cannot be longer than 100 characters');
      setLoading(false);
      return;
    }

    // 3. PHONE VALIDATION
    if (!phone || !phone.trim()) {
      setSaveError('Phone number is required');
      setLoading(false);
      return;
    }

    // More detailed phone validation with specific error messages
    const phoneRegex = /^\d{3}-\d{3}-\d{4}$/;
    if (!phoneRegex.test(phone)) {
      if (!phone.includes('-')) {
        setSaveError('Phone number must include dashes. Format: 250-885-7003');
      } else if (phone.length < 12) {
        setSaveError('Phone number is too short. Format: 250-885-7003 (12 characters)');
      } else if (phone.length > 12) {
        setSaveError('Phone number is too long. Format: 250-885-7003 (12 characters)');
      } else if (!/^\d/.test(phone)) {
        setSaveError('Phone number must start with a digit. Format: 250-885-7003');
      } else if (!/^\d{3}-/.test(phone)) {
        setSaveError('First 3 digits must be followed by a dash. Format: 250-885-7003');
      } else if (!/^\d{3}-\d{3}-/.test(phone)) {
        setSaveError('Missing dash after area code and prefix. Format: 250-885-7003');
      } else if (!/\d{4}$/.test(phone)) {
        setSaveError('Phone number must end with 4 digits. Format: 250-885-7003');
      } else {
        setSaveError('Phone number format is invalid. Use only numbers and dashes: 250-885-7003');
      }
      setLoading(false);
      return;
    }

    // 4. PROVINCE VALIDATION
    if (!province || !province.trim()) {
      setSaveError('Province is required');
      setLoading(false);
      return;
    }
    const validProvinces = ['AB', 'BC', 'MB', 'NB', 'NL', 'NS', 'ON', 'PE', 'QC', 'SK', 'NT', 'NU', 'YT'];
    if (!validProvinces.includes(province)) {
      setSaveError('Please select a valid Canadian province or territory');
      setLoading(false);
      return;
    }

    // 5. CITY VALIDATION
    if (!city || !city.trim()) {
      setSaveError('City is required');
      setLoading(false);
      return;
    }
    if (city.trim().length < 2) {
      setSaveError('City name must be at least 2 characters long');
      setLoading(false);
      return;
    }
    if (city.trim().length > 100) {
      setSaveError('City name cannot be longer than 100 characters');
      setLoading(false);
      return;
    }
    if (!/^[a-zA-Z\s\-'\.]+$/.test(city.trim())) {
      setSaveError('City name can only contain letters, spaces, hyphens, apostrophes, and periods');
      setLoading(false);
      return;
    }

    // 6. ADDRESS VALIDATION
    if (!address || !address.trim()) {
      setSaveError('Street address is required');
      setLoading(false);
      return;
    }
    if (address.trim().length < 5) {
      setSaveError('Street address must be at least 5 characters long (e.g., "123 Main St")');
      setLoading(false);
      return;
    }
    if (address.trim().length > 200) {
      setSaveError('Street address cannot be longer than 200 characters');
      setLoading(false);
      return;
    }
    // Basic address format validation (should contain at least a number and some letters)
    if (!/\d/.test(address)) {
      setSaveError('Street address should include a house/building number');
      setLoading(false);
      return;
    }
    if (!/[a-zA-Z]/.test(address)) {
      setSaveError('Street address should include a street name');
      setLoading(false);
      return;
    }

    // 7. POSTAL CODE VALIDATION
    if (!postalCode || !postalCode.trim()) {
      setSaveError('Postal code is required');
      setLoading(false);
      return;
    }

    const postalCodePattern = /^[A-Za-z]\d[A-Za-z][ -]?\d[A-Za-z]\d$/;
    if (!postalCodePattern.test(postalCode)) {
      if (postalCode.length < 6) {
        setSaveError('Postal code is too short. Format: V8N 2L4 or V8N-2L4');
      } else if (postalCode.length > 7) {
        setSaveError('Postal code is too long. Format: V8N 2L4 or V8N-2L4');
      } else if (!/^[A-Za-z]/.test(postalCode)) {
        setSaveError('Postal code must start with a letter. Format: V8N 2L4');
      } else if (!/^[A-Za-z]\d/.test(postalCode)) {
        setSaveError('Second character must be a number. Format: V8N 2L4');
      } else if (!/^[A-Za-z]\d[A-Za-z]/.test(postalCode)) {
        setSaveError('Third character must be a letter. Format: V8N 2L4');
      } else if (!/\d[A-Za-z]\d$/.test(postalCode)) {
        setSaveError('Last 3 characters must be: number-letter-number. Format: V8N 2L4');
      } else {
        setSaveError('Invalid postal code format. Use Canadian format: V8N 2L4 or V8N-2L4');
      }
      setLoading(false);
      return;
    }

    const formattedPostalCode = postalCode.toUpperCase().replace(/\s/g, '').replace(/([A-Z0-9]{3})([A-Z0-9]{3})/, '$1-$2');

    // Geocode the address if it's complete
    const geocodedData = await geocodeAddress();

    const profilePayload = {
      name,
      email, // Add email to payload for backend insertion
      phone,
      province,
      city,
      address,
      postal_code: formattedPostalCode,
      latitude: geocodedData?.lat || null,
      longitude: geocodedData?.lng || null,
      geocoded_address: geocodedData?.formattedAddress || null
    };

    try {
      let profileExists = !!contextProfile;

      if (profileExists) {
        await apiClient.put('/profile', profilePayload);
      } else {
        await apiClient.post('/profile', profilePayload);
      }

      setSaveSuccess(true);
      setGeocodingStatus('idle'); // Reset geocoding status
      setTimeout(() => {
        setSaveSuccess(false);
        // <-- THE FIX: Call onComplete if it exists, otherwise call onClose
        if (onComplete) {
          onComplete();
        } else if (onClose) {
          onClose();
        }
      }, 1200);

    } catch (err: any) {
      setSaveError(err.response?.data?.error || 'Failed to save profile. Please try again.');
      setGeocodingStatus('idle'); // Reset on error
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <div style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100vw',
        height: '100vh',
        background: 'rgba(0,0,0,0.6)',
        zIndex: 1200,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <div style={{
          background: 'white',
          borderRadius: '12px',
          maxWidth: '700px',
          width: '90%',
          maxHeight: '85vh',
          overflow: 'hidden',
          boxShadow: '0 10px 40px rgba(0,0,0,0.3)'
        }}>
          {/* Header */}
          <div style={{
            padding: '20px 24px',
            borderBottom: '1px solid #4b5563',
            background: '#374151',
            color: 'white',
            borderRadius: '12px 12px 0 0'
          }}>
            <h2 style={{ margin: 0, fontSize: '1.5rem', fontWeight: '600' }}>
              üìù Update Your Profile
            </h2>
          </div>

          <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', height: 'calc(85vh - 140px)' }}>
            {/* Scrollable Content */}
            <div style={{
              flex: 1,
              overflowY: 'auto',
              padding: '24px'
            }}>
              {/* Contact Information Card */}
              <div style={{
                background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
                padding: '20px',
                marginBottom: '20px',
                borderRadius: '10px',
                border: '1px solid #e1e8ed'
              }}>
                <h3 style={{
                  margin: '0 0 15px 0',
                  color: '#2c3e50',
                  fontSize: '1.2rem',
                  fontWeight: '600',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px'
                }}>
                  üë§ Contact Information
                </h3>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
                  <div>
                    <label style={{
                      display: 'block',
                      marginBottom: '5px',
                      fontWeight: '500',
                      color: '#555'
                    }}>Email:</label>
                    <input
                      type="email"
                      value={email}
                      disabled
                      style={{
                        width: '100%',
                        padding: '12px',
                        border: '1px solid #ddd',
                        borderRadius: '6px',
                        fontSize: '1rem',
                        background: '#f8f9fa'
                      }}
                    />
                  </div>
                  <div>
                    <label style={{
                      display: 'block',
                      marginBottom: '5px',
                      fontWeight: '500',
                      color: '#555'
                    }}>Name:</label>
                    <input
                      type="text"
                      value={name}
                      onChange={e => setName(e.target.value)}
                      placeholder="John Doe"
                      required
                      style={{
                        width: '100%',
                        padding: '12px',
                        border: '1px solid #ddd',
                        borderRadius: '6px',
                        fontSize: '1rem'
                      }}
                    />
                  </div>
                  <div>
                    <label style={{
                      display: 'block',
                      marginBottom: '5px',
                      fontWeight: '500',
                      color: '#555'
                    }}>Phone:</label>
                    <input
                      type="text"
                      value={phone}
                      onChange={e => setPhone(e.target.value)}
                      placeholder="250-555-1234"
                      required
                      style={{
                        width: '100%',
                        padding: '12px',
                        border: '1px solid #ddd',
                        borderRadius: '6px',
                        fontSize: '1rem'
                      }}
                    />
                    <div style={{ fontSize: '0.8rem', color: '#666', marginTop: '4px' }}>
                      Format: 250-555-1234
                    </div>
                  </div>
                </div>
              </div>

              {/* Service Address Card */}
              <div style={{
                background: 'linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%)',
                padding: '20px',
                borderRadius: '10px',
                border: '1px solid #90caf9'
              }}>
                <h3 style={{
                  margin: '0 0 15px 0',
                  color: '#1565c0',
                  fontSize: '1.2rem',
                  fontWeight: '600',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px'
                }}>
                  üìç Service Address
                </h3>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px', marginBottom: '15px' }}>
                  <div>
                    <label style={{
                      display: 'block',
                      marginBottom: '5px',
                      fontWeight: '500',
                      color: '#555'
                    }}>Province:</label>
                    <select
                      value={province}
                      onChange={e => setProvince(e.target.value)}
                      required
                      style={{
                        width: '100%',
                        padding: '12px',
                        border: '1px solid #ddd',
                        borderRadius: '6px',
                        fontSize: '1rem'
                      }}
                    >
                      <option value="">Select Province</option>
                      {provinces.map(p => <option key={p} value={p}>{p}</option>)}
                    </select>
                  </div>
                  <div>
                    <label style={{
                      display: 'block',
                      marginBottom: '5px',
                      fontWeight: '500',
                      color: '#555'
                    }}>City:</label>
                    <input
                      type="text"
                      value={city}
                      onChange={e => setCity(e.target.value)}
                      placeholder="Victoria"
                      required
                      style={{
                        width: '100%',
                        padding: '12px',
                        border: '1px solid #ddd',
                        borderRadius: '6px',
                        fontSize: '1rem'
                      }}
                    />
                  </div>
                </div>
                <div style={{ marginBottom: '15px' }}>
                  <label style={{
                    display: 'block',
                    marginBottom: '5px',
                    fontWeight: '500',
                    color: '#555'
                  }}>Street Address:</label>
                  <input
                    type="text"
                    value={address}
                    onChange={e => setAddress(e.target.value)}
                    placeholder="123 Main Street"
                    required
                    style={{
                      width: '100%',
                      padding: '12px',
                      border: '1px solid #ddd',
                      borderRadius: '6px',
                      fontSize: '1rem'
                    }}
                  />
                </div>
                <div style={{ marginBottom: '15px' }}>
                  <label style={{
                    display: 'block',
                    marginBottom: '5px',
                    fontWeight: '500',
                    color: '#555'
                  }}>Postal Code:</label>
                  <input
                    type="text"
                    value={postalCode}
                    onChange={e => setPostalCode(e.target.value)}
                    placeholder="V8N 2L4"
                    required
                    style={{
                      width: '100%',
                      padding: '12px',
                      border: '1px solid #ddd',
                      borderRadius: '6px',
                      fontSize: '1rem'
                    }}
                  />
                  <div style={{ fontSize: '0.8rem', color: '#666', marginTop: '4px' }}>
                    Format: V8N 2L4 or V8N-2L4
                  </div>
                </div>

                {/* Geocoding Status */}
                {geocodingStatus === 'loading' && (
                  <div style={{
                    padding: '10px',
                    background: '#fff3cd',
                    border: '1px solid #ffeaa7',
                    borderRadius: '6px',
                    color: '#856404',
                    fontSize: '0.9rem'
                  }}>
                    üîç Verifying address location...
                  </div>
                )}
                {geocodingStatus === 'success' && (
                  <div style={{
                    padding: '10px',
                    background: '#d4edda',
                    border: '1px solid #c3e6cb',
                    borderRadius: '6px',
                    color: '#155724',
                    fontSize: '0.9rem'
                  }}>
                    ‚úÖ Address location verified and cached
                  </div>
                )}
                {geocodingStatus === 'error' && (
                  <div style={{
                    padding: '10px',
                    background: '#f8d7da',
                    border: '1px solid #f5c6cb',
                    borderRadius: '6px',
                    color: '#721c24',
                    fontSize: '0.9rem'
                  }}>
                    ‚ö†Ô∏è Address verification failed - coordinates will be calculated later
                  </div>
                )}
              </div>
            </div>

            {/* Footer with Save and Cancel Buttons */}
            <div style={{
              padding: '20px 24px',
              borderTop: '1px solid #e0e0e0',
              background: '#f8f9fa',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              gap: '15px'
            }}>
              {saveError && (
                <div style={{
                  color: '#dc3545',
                  fontSize: '0.9rem',
                  textAlign: 'center',
                  padding: '8px',
                  background: '#f8d7da',
                  borderRadius: '6px',
                  width: '100%'
                }}>
                  {saveError}
                </div>
              )}
              {saveSuccess && (
                <div style={{
                  color: '#28a745',
                  fontSize: '0.9rem',
                  textAlign: 'center',
                  padding: '8px',
                  background: '#d4edda',
                  borderRadius: '6px',
                  width: '100%'
                }}>
                  ‚úÖ Profile saved successfully!
                </div>
              )}

              {/* Button Container */}
              <div style={{
                display: 'flex',
                justifyContent: 'flex-end',
                gap: '12px',
                width: '100%'
              }}>
                {/* Cancel Button - Only show if closable */}
                {isClosable && (
                  <button
                    type="button"
                    onClick={onClose}
                    disabled={loading}
                    style={{
                      background: 'transparent',
                      color: '#6c757d',
                      border: '1px solid #6c757d',
                      padding: '12px 24px',
                      fontSize: '1rem',
                      fontWeight: '600',
                      borderRadius: '6px',
                      cursor: loading ? 'not-allowed' : 'pointer',
                      transition: 'all 0.3s ease',
                      flexShrink: 0
                    }}
                    onMouseOver={(e) => {
                      if (!loading) {
                        e.currentTarget.style.background = '#6c757d';
                        e.currentTarget.style.color = 'white';
                      }
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.background = 'transparent';
                      e.currentTarget.style.color = '#6c757d';
                    }}
                  >
                    Cancel
                  </button>
                )}

                {/* Save Button */}
                <button
                  type="submit"
                  disabled={loading || saveSuccess}
                  style={{
                    background: loading || saveSuccess ? '#6c757d' : '#2563eb',
                    color: 'white',
                    border: 'none',
                    padding: '12px 24px',
                    fontSize: '1rem',
                    fontWeight: '600',
                    borderRadius: '6px',
                    cursor: loading || saveSuccess ? 'not-allowed' : 'pointer',
                    transition: 'all 0.3s ease',
                    flexShrink: 0
                  }}
                  onMouseOver={(e) => {
                    if (!loading && !saveSuccess) {
                      e.currentTarget.style.background = '#1d4ed8';
                    }
                  }}
                  onMouseOut={(e) => {
                    if (!loading && !saveSuccess) {
                      e.currentTarget.style.background = '#2563eb';
                    }
                  }}
                >
                  {loading ? 'Saving...' : 'Save Profile'}
                </button>
              </div>
            </div>
          </form>
        </div>
      </div>
    </>
  );
};
export default ProfileModal;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/AITriageSummary.tsx ---

// packages/frontend/src/features/requests/components/AITriageSummary.tsx

import React from 'react';
import { Box, Typography, Paper, Chip, LinearProgress } from '@mui/material';
import { Zap, TrendingUp, Award } from 'lucide-react';
import { QuoteRequest } from '../types';

interface AITriageSummaryProps {
  request: QuoteRequest;
}

// Helper function to determine priority color (Chip compatible)
const getPriorityColorChip = (score: number | null): 'default' | 'error' | 'warning' | 'success' | 'info' => {
  if (score === null) return 'default';
  if (score >= 8) return 'error';    // Red for high priority (8-10)
  if (score >= 5) return 'warning';  // Orange for medium priority (5-7)
  return 'success';                  // Green for low priority (1-4)
};

// Helper function for LinearProgress (no 'default' option)
const getPriorityColorProgress = (score: number | null): 'error' | 'warning' | 'success' | 'info' | 'inherit' => {
  if (score === null) return 'inherit';
  if (score >= 8) return 'error';    // Red for high priority (8-10)
  if (score >= 5) return 'warning';  // Orange for medium priority (5-7)
  return 'success';                  // Green for low priority (1-4)
};

// Helper function to determine profitability color (Chip compatible)
const getProfitabilityColorChip = (score: number | null): 'default' | 'error' | 'warning' | 'success' | 'info' => {
  if (score === null) return 'default';
  if (score >= 8) return 'success';  // Green for high profit (8-10)
  if (score >= 5) return 'info';     // Blue for medium profit (5-7)
  return 'warning';                  // Orange for low profit (1-4)
};

// Helper function for LinearProgress (no 'default' option)
const getProfitabilityColorProgress = (score: number | null): 'error' | 'warning' | 'success' | 'info' | 'inherit' => {
  if (score === null) return 'inherit';
  if (score >= 8) return 'success';  // Green for high profit (8-10)
  if (score >= 5) return 'info';     // Blue for medium profit (5-7)
  return 'warning';                  // Orange for low profit (1-4)
};

// Helper function to determine expertise color
const getExpertiseColor = (level: string) => {
  switch (level?.toLowerCase()) {
    case 'master': return 'error';     // Red for master
    case 'journeyman': return 'warning'; // Orange for journeyman
    case 'apprentice': return 'info';   // Blue for apprentice
    default: return 'default';
  }
};

const AITriageSummary: React.FC<AITriageSummaryProps> = ({ request }) => {
  // This component only renders if the triage summary exists.
  if (!request.triage_summary) {
    return null;
  }

  // Determine background and border color based on priority
  const getBackgroundColors = () => {
    const score = request.priority_score;
    if (score === null) return {
      headerBg: 'grey.100',
      contentBg: 'grey.50',
      borderColor: 'grey.400'
    };
    if (score >= 8) return {
      headerBg: 'error.100',
      contentBg: 'error.50',
      borderColor: 'error.400'
    };
    if (score >= 5) return {
      headerBg: 'warning.100',
      contentBg: 'warning.50',
      borderColor: 'warning.400'
    };
    return {
      headerBg: 'success.100',
      contentBg: 'success.50',
      borderColor: 'success.400'
    };
  };

  const { headerBg, contentBg, borderColor } = getBackgroundColors();

  return (
    <Paper variant="outlined">
      {/* Header Section - Darker background */}
      <Box sx={{
        p: 2,
        borderLeft: 4,
        borderColor,
        bgcolor: headerBg,
        borderBottom: 1,
        borderBottomColor: 'divider'
      }}>
        <Typography variant="overline" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 1, fontWeight: 'bold' }}>
          <Zap size={16} /> AI TRIAGE SUMMARY
        </Typography>
        <Typography variant="body1" sx={{ mt: 1 }}>
          {request.triage_summary}
        </Typography>
      </Box>

      {/* Content Section - Lighter background */}
      <Box sx={{ p: 2, bgcolor: contentBg }}>

        {/* Priority Score with visual indicator */}
        <Box sx={{ mt: 2 }}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
            <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
              Priority Score:
            </Typography>
            <Chip
              label={`${request.priority_score}/10`}
              color={getPriorityColorChip(request.priority_score)}
              size="small"
              sx={{ fontWeight: 'bold' }}
            />
          </Box>
          <LinearProgress
            variant="determinate"
            value={(request.priority_score || 0) * 10}
            color={getPriorityColorProgress(request.priority_score)}
            sx={{ height: 8, borderRadius: 1 }}
          />
          {request.priority_explanation && (
            <Typography variant="body2" sx={{ mt: 0.5, fontStyle: 'italic', color: 'text.secondary' }}>
              {request.priority_explanation}
            </Typography>
          )}
        </Box>

        {/* Profitability Score with visual indicator */}
        {request.profitability_score != null && (
          <Box sx={{ mt: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
              <TrendingUp size={16} />
              <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                Profitability Score:
              </Typography>
              <Chip
                label={`${request.profitability_score}/10`}
                color={getProfitabilityColorChip(request.profitability_score)}
                size="small"
                sx={{ fontWeight: 'bold' }}
              />
            </Box>
            <LinearProgress
              variant="determinate"
              value={(request.profitability_score || 0) * 10}
              color={getProfitabilityColorProgress(request.profitability_score)}
              sx={{ height: 8, borderRadius: 1 }}
            />
            {request.profitability_explanation && (
              <Typography variant="body2" sx={{ mt: 0.5, fontStyle: 'italic', color: 'text.secondary' }}>
                {request.profitability_explanation}
              </Typography>
            )}
          </Box>
        )}

        {/* Required Expertise with badge */}
        {request.required_expertise && (
          <Box sx={{ mt: 2, pt: 2, borderTop: 1, borderColor: 'divider' }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
              <Award size={16} />
              <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                Required Expertise:
              </Typography>
              <Chip
                label={request.required_expertise.skill_level?.charAt(0).toUpperCase() + request.required_expertise.skill_level?.slice(1)}
                color={getExpertiseColor(request.required_expertise.skill_level)}
                size="small"
                sx={{ fontWeight: 'bold' }}
              />
            </Box>
            {request.required_expertise.specialized_skills && request.required_expertise.specialized_skills.length > 0 && (
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mt: 1 }}>
                {request.required_expertise.specialized_skills.map((skill, idx) => (
                  <Chip
                    key={idx}
                    label={skill}
                    size="small"
                    variant="outlined"
                    color="primary"
                  />
                ))}
              </Box>
            )}
            {request.required_expertise.reasoning && (
              <Typography variant="body2" sx={{ mt: 1, fontStyle: 'italic', color: 'text.secondary' }}>
                {request.required_expertise.reasoning}
              </Typography>
            )}
          </Box>
        )}
      </Box>
    </Paper>
  );
};

export default AITriageSummary;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/AttachmentSection.tsx ---

// packages/frontend/src/features/requests/components/AttachmentSection.tsx

import React, { useState, useEffect, useMemo } from 'react';
import { useDropzone } from 'react-dropzone';
import { useQueryClient } from '@tanstack/react-query';
import { supabase } from '../../../lib/supabaseClient';
import apiClient from '../../../lib/apiClient';
import { Box, Typography, Paper, Button, CircularProgress, Alert, IconButton, Divider } from '@mui/material';
import { FileText as FileTextIcon, Paperclip, X as XIcon, UploadCloud } from 'lucide-react';
import { QuoteAttachment } from '../types';
import { useRequestById } from '../../../hooks';
import { logger } from '../../../lib/logger';

interface AttachmentSectionProps {
  requestId: string;
  attachments?: QuoteAttachment[]; // Made optional since we'll use the hook
  pendingFiles?: File[];
  editable: boolean;
  onUpdate?: () => void; // Made optional since real-time handles updates
  onNewFiles?: (files: File[]) => void;
  onRemovePendingFile?: (index: number) => void;
  quoteId?: string | null;
}

const AttachmentGroup: React.FC<{ title: string; attachments: (QuoteAttachment | File)[]; imageUrls: { [key: string]: string }; onRemove?: ((index: number) => void) | undefined; editable?: boolean }> = ({ title, attachments, imageUrls, onRemove, editable }) => {
  if (attachments.length === 0) return null;

  return (
    <Box sx={{ mb: 2 }}>
      <Typography variant="subtitle2" color="text.secondary" sx={{ fontWeight: 'bold' }}>{title}</Typography>
      <Divider sx={{ mb: 1.5 }} />
      <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
        {attachments.map((att, index) => {
          const isFile = att instanceof File;
          const key = isFile ? `pending-${index}` : att.id;
          const name = isFile ? att.name : att.file_name;
          const type = isFile ? att.type : att.mime_type;
          const urlKey = isFile ? `pending-${index}` : att.id;
          const url = imageUrls[urlKey];

          return (
            <Box key={key} sx={{ position: 'relative', width: 100, height: 100 }}>
              <a href={url} target="_blank" rel="noopener noreferrer" title={name}>
                {type?.startsWith('image/') && url ? (
                  <img src={url} alt={name} style={{ width: '100px', height: '100px', objectFit: 'cover', borderRadius: '8px' }} />
                ) : (
                  <Box sx={{ width: 100, height: 100, borderRadius: 2, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', bgcolor: 'grey.200' }}>
                    <FileTextIcon size={24} />
                    <Typography variant="caption" sx={{ mt: 1, textAlign: 'center', wordBreak: 'break-all', p: '0 4px' }}>{name}</Typography>
                  </Box>
                )}
              </a>
              {isFile && editable && onRemove && (
                <IconButton size="small" onClick={() => onRemove(index)} sx={{ position: 'absolute', top: -5, right: -5, bgcolor: 'background.paper', '&:hover': { bgcolor: 'grey.200' } }}>
                  <XIcon size={14} />
                </IconButton>
              )}
            </Box>
          );
        })}
      </Box>
    </Box>
  );
};


const AttachmentSection: React.FC<AttachmentSectionProps> = ({ requestId, attachments: initialAttachments, pendingFiles = [], editable, onUpdate, onNewFiles, onRemovePendingFile, quoteId = null }) => {
  const [signedUrls, setSignedUrls] = useState<{ [key: string]: string }>({});
  const [pendingImageUrls, setPendingImageUrls] = useState<{ [key: string]: string }>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const queryClient = useQueryClient();

  logger.log('üîß AttachmentSection DEBUG:', {
    requestId,
    editable,
    typeof_editable: typeof editable,
    pendingFiles_length: pendingFiles.length,
    quoteId
  });

  // For new requests (requestId === "new-request"), don't fetch existing data
  // Only fetch for existing requests that have real IDs
  const isNewRequest = requestId === 'new-request';
  const { data: requestArray, loading: requestLoading, error: requestError } = useRequestById(requestId, {
    enabled: !!requestId && !isNewRequest // Only fetch for real request IDs, not "new-request"
  });
  const request = requestArray?.[0];
  const attachments = isNewRequest ? [] : (request?.quote_attachments || initialAttachments || []);

  // Clear signed URLs and pending images when requestId changes to prevent showing old attachments
  useEffect(() => {
    setSignedUrls({});
    setPendingImageUrls({});
    setError(null);
    // Also clear any existing object URLs to prevent memory leaks
    Object.values(pendingImageUrls).forEach(url => {
      if (url && url.startsWith('blob:')) {
        URL.revokeObjectURL(url);
      }
    });
  }, [requestId]);

  logger.log('üîç AttachmentSection using standardized real-time system:', {
    requestId,
    attachmentsLength: attachments?.length,
    attachmentIds: attachments?.map(a => a.id) || [],
    pendingFilesLength: pendingFiles?.length,
    pendingFileNames: pendingFiles?.map(f => f.name) || [],
    requestLoading,
    requestError,
    hasRealTimeData: !!request,
    signedUrlsCount: Object.keys(signedUrls).length,
    pendingUrlsCount: Object.keys(pendingImageUrls).length,
    timestamp: new Date().toISOString()
  });

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop: acceptedFiles => {
      logger.log('üîß AttachmentSection onDrop triggered:', {
        filesCount: acceptedFiles.length,
        hasOnNewFiles: !!onNewFiles,
        requestId,
        editable
      });

      if (onNewFiles) {
        onNewFiles(acceptedFiles);
      } else {
        // For direct upload
        uploadFiles(acceptedFiles);
      }
    }
  });

  const stableAttachmentKey = useMemo(() => {
    return attachments.map(att => att.id).sort().join(',');
  }, [attachments]);

  // *** THE DEFINITIVE FIX: Create a stable key for the pendingFiles prop as well. ***
  // This uses the file name and size to create a unique, primitive key that is immune
  // to the parent passing a new array instance.
  const stablePendingFileKey = useMemo(() => {
    return pendingFiles.map(f => `${f.name}-${f.size}`).join(',');
  }, [pendingFiles]);

  useEffect(() => {
    if (attachments && attachments.length > 0) {
      setLoading(true);
      const filePaths = attachments.map(att => att.file_url);
      supabase.storage.from('PlumbingPoCBucket').createSignedUrls(filePaths, 3600)
        .then(({ data, error }) => {
          if (error) throw error;
          if (data) {
           const urlMap = attachments.reduce((acc, att, index) => {
             if (data[index] && data[index].signedUrl) {
               acc[att.id] = data[index].signedUrl;
             }
             return acc;
           }, {} as { [key: string]: string });
           setSignedUrls(urlMap);
         }
        })
        .catch(err => setError("Failed to load attachments."))
        .finally(() => setLoading(false));
    } else {
        setSignedUrls({});
    }
  }, [stableAttachmentKey]);

  useEffect(() => {
    const objectUrls: { [key: string]: string } = {};
    if (pendingFiles.length > 0) {
      pendingFiles.forEach((file, index) => {
        if (file.type.startsWith('image/')) {
          objectUrls[`pending-${index}`] = URL.createObjectURL(file);
        }
      });
      setPendingImageUrls(objectUrls);
    } else {
      setPendingImageUrls({});
    }

    return () => {
      // Clean up object URLs when the effect runs again or component unmounts
      Object.values(objectUrls).forEach(url => {
        if (url && url.startsWith('blob:')) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, [stablePendingFileKey]); // Use the new stable key here.

  // Cleanup effect when component unmounts
  useEffect(() => {
    return () => {
      // Clean up any remaining object URLs
      Object.values(pendingImageUrls).forEach(url => {
        if (url && url.startsWith('blob:')) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, []);

  const uploadFiles = async (files: File[]) => {
    if (!files || files.length === 0) return;

    logger.log('üöÄ AttachmentSection uploadFiles called:', {
      filesCount: files.length,
      requestId,
      quoteId,
      fileNames: files.map(f => f.name)
    });

    setLoading(true);
    setError(null);
    try {
      const formData = new FormData();
      formData.append('request_id', requestId);
      if (quoteId) {
        formData.append('quote_id', quoteId);
      }
      files.forEach(file => {
        formData.append('attachment', file);
      });

      const response = await apiClient.post('/requests/attachments', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });

      logger.log('‚úÖ Attachment uploaded successfully:', response.data);
      logger.log('‚úÖ Attachment upload complete, real-time system will handle updates automatically');

      // Call onUpdate callback if parent component needs additional side effects
      onUpdate?.();
    } catch (err: any) {
      console.error('‚ùå Attachment upload failed:', err);
      setError(err?.response?.data?.error || err.message || 'Failed to upload files.');
    } finally {
      setLoading(false);
    }
  };

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    logger.log('üîß AttachmentSection handleFileUpload:', {
      filesCount: files.length,
      hasOnNewFiles: !!onNewFiles,
      requestId,
      editable
    });

    if (onNewFiles) {
      onNewFiles(Array.from(files));
      event.target.value = '';
      return;
    }

    await uploadFiles(Array.from(files));
    event.target.value = '';
  };

  const allUrls = { ...signedUrls, ...pendingImageUrls };
  const requestAttachments = attachments.filter(att => !att.quote_id);
  const quotesWithAttachments = attachments
    .filter(att => att.quote_id)
    .reduce((acc, att) => {
      const qId = att.quote_id!;
      if (!acc[qId]) acc[qId] = [];
      acc[qId].push(att);
      return acc;
    }, {} as { [key: string]: QuoteAttachment[] });

  return (
    <Paper variant="outlined" sx={{ p: 2 }}>
      <Typography variant="overline" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        <Paperclip size={16} /> Attachments
      </Typography>
      {loading && <CircularProgress size={24} sx={{ mt: 1 }} />}
      <AttachmentGroup title="Customer Uploads (Request)" attachments={requestAttachments} imageUrls={allUrls} />
      {Object.entries(quotesWithAttachments).map(([qId, quoteAtts]) => (
        <AttachmentGroup key={qId} title={`Attachments for Quote #${qId.substring(0, 4)}`} attachments={quoteAtts} imageUrls={allUrls} />
      ))}
      {pendingFiles.length > 0 && (
        <AttachmentGroup title="New Pending Uploads" attachments={pendingFiles} imageUrls={allUrls} onRemove={onRemovePendingFile ? onRemovePendingFile : undefined} editable={editable} />
      )}
      {attachments.length === 0 && pendingFiles.length === 0 && !loading && (
        <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>No attachments yet.</Typography>
      )}
      {editable && (
        <Box sx={{ mt: 2 }}>
          <Box
            {...getRootProps()}
            sx={{
              border: '2px dashed',
              borderColor: isDragActive ? 'primary.main' : 'grey.300',
              borderRadius: 2,
              p: 3,
              textAlign: 'center',
              cursor: 'pointer',
              transition: 'border-color 0.2s',
              backgroundColor: isDragActive ? 'action.hover' : 'background.paper',
            }}
          >
            <input {...getInputProps()} />
            <UploadCloud size={32} style={{ margin: '0 auto', color: '#9e9e9e' }} />
            <Typography sx={{ mt: 1, color: 'text.secondary' }}>
              {isDragActive ? 'Drop the files here...' : "Drag 'n' drop files here, or click to select"}
            </Typography>
          </Box>
        </Box>
      )}
      {error && <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>}
    </Paper>
  );
};

export default AttachmentSection;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/CommunicationLog.tsx ---

// packages/frontend/src/features/requests/components/CommunicationLog.tsx

import React, { useState } from 'react';
import apiClient from '../../../lib/apiClient';
import { Box, Typography, Paper, TextField, Button } from '@mui/material';
import { MessageSquare } from 'lucide-react';
import { RequestNote } from '../types'; // Import the type from the central location
import { useRequestById } from '../../../hooks';
import { logger } from '../../../lib/logger';

interface CommunicationLogProps {
  requestId: string;
  initialNotes?: RequestNote[]; // Kept for backward compatibility but not used
  onNoteAdded?: () => void; // Kept for backward compatibility
}

const CommunicationLog: React.FC<CommunicationLogProps> = ({ requestId, onNoteAdded }) => {
  const [newNote, setNewNote] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Use standardized real-time system to get request data including notes
  const { data: requestArray, loading, error, refetch } = useRequestById(requestId, {
    enabled: !!requestId // Only fetch when we have a requestId
  });
  const request = requestArray?.[0]; // Extract single request from array
  const notes = request?.request_notes || [];

  logger.log('üîç CommunicationLog render:', {
    notesLength: notes?.length,
    noteIds: notes?.map(n => n.id) || [],
    noteTexts: notes?.map(n => n.note.substring(0, 30) + '...') || [],
    requestId,
    loading,
    error,
    hasRequest: !!request,
    timestamp: new Date().toISOString()
  });

  // Log when notes change to detect realtime updates
  React.useEffect(() => {
    logger.log('üìù CommunicationLog notes updated:', {
      notesCount: notes?.length,
      latestNote: notes?.[notes.length - 1]?.note?.substring(0, 50) + '...',
      timestamp: new Date().toISOString()
    });
  }, [notes?.length]);

  const handleAddNote = async () => {
    if (!newNote.trim() || !requestId) return;

    logger.log('üí¨ BEFORE adding note:', {
      noteText: newNote,
      requestId,
      currentNotesCount: notes?.length,
      currentNotes: notes?.map(n => ({ id: n.id, note: n.note.substring(0, 20) + '...' }))
    });

    setIsSubmitting(true);
    try {
      // Add the note to the database
      const response = await apiClient.post(`/requests/${requestId}/notes`, { note: newNote });
      logger.log('üóÑÔ∏è API response for adding note:', response.data);

      setNewNote("");

      // Trigger refresh of the request data to show the new message
      logger.log('üîÑ Refreshing request data to show new message...');
      onNoteAdded?.();
      logger.log('‚úÖ Note added successfully and UI updated');
    } catch (error) {
      console.error("üí• Failed to add note:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Paper variant="outlined" sx={{ display: 'flex', flexDirection: 'column', overflow: 'hidden', height: '100%' }}>
      <Typography variant="overline" sx={{ p: 2, bgcolor: 'grey.100', display: 'flex', alignItems: 'center', gap: 1 }}>
        <MessageSquare size={16} /> Communication Log
      </Typography>

      <Box sx={{ flexGrow: 1, overflowY: 'auto', p: 2, minHeight: '200px' }}>
        {loading ? (
          <Typography variant="body2" color="text.secondary" sx={{ p: 2, textAlign: 'center' }}>
            Loading notes...
          </Typography>
        ) : error ? (
          <Typography variant="body2" color="error" sx={{ p: 2, textAlign: 'center' }}>
            Error loading notes: {error}
          </Typography>
        ) : notes.length > 0 ? (
          notes.map((note: RequestNote) => (
            <Box
              key={note.id}
              sx={{ mb: 1.5, display: 'flex', justifyContent: note.author_role === 'admin' ? 'flex-start' : 'flex-end' }}
            >
              <Box>
                <Paper elevation={0} sx={{ p: 1.5, bgcolor: note.author_role === 'admin' ? '#e3f2fd' : '#ede7f6', borderRadius: 2 }}>
                  <Typography variant="body2">{note.note}</Typography>
                </Paper>
                <Typography variant="caption" display="block" sx={{ px: 1, color: 'text.secondary', textAlign: note.author_role === 'admin' ? 'left' : 'right' }}>
                  {note.author_role === 'admin' ? 'Admin' : 'You'} - {new Date(note.created_at).toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}
                </Typography>
              </Box>
            </Box>
          ))
        ) : (
          <Typography variant="body2" color="text.secondary" sx={{ p: 2, textAlign: 'center' }}>
            No notes yet.
          </Typography>
        )}
      </Box>

      <Box sx={{ p: 2, borderTop: 1, borderColor: 'divider', bgcolor: 'grey.50' }}>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <TextField
            label="Add a note or message..."
            value={newNote}
            onChange={(e) => setNewNote(e.target.value)}
            fullWidth
            multiline
            maxRows={3}
            size="small"
            onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleAddNote(); }}}
          />
          <Button variant="contained" onClick={handleAddNote} disabled={isSubmitting || !newNote.trim()}>
            {isSubmitting ? '...' : 'Send'}
          </Button>
        </Box>
      </Box>
    </Paper>
  );
};

export default CommunicationLog;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/CompleteJobModal.tsx ---

// packages/frontend/src/features/requests/components/CompleteJobModal.tsx

import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  Box,
  InputAdornment,
  CircularProgress
} from '@mui/material';
import { CheckCircle } from 'lucide-react';
import { logger } from '../../../lib/logger';

// Define the shape of the data this modal will send back
interface CompletionData {
  actual_cost: number;
  completion_notes: string;
}

// Define the component's props, including the critical onConfirm function
interface CompleteJobModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: (data: CompletionData) => void; // This function will trigger the API call
  isSubmitting: boolean;
  jobTitle: string;
}

const CompleteJobModal: React.FC<CompleteJobModalProps> = ({ isOpen, onClose, onConfirm, isSubmitting, jobTitle }) => {
  // Internal state to manage the form fields
  const [actualCost, setActualCost] = useState('');
  const [completionNotes, setCompletionNotes] = useState('');

  // Handler for the confirm button click
  const handleConfirm = () => {
    logger.log('üîò CompleteJobModal: Confirm button clicked');
    const data = {
      actual_cost: parseFloat(actualCost) || 0,
      completion_notes: completionNotes,
    };
    logger.log('üì§ CompleteJobModal: Sending data:', data);
    // THE FIX: Call the onConfirm function passed down from the parent
    // and provide it with the current state of the form.
    onConfirm(data);
  };

  return (
    // Use the MUI Dialog component for a consistent look and feel
    <Dialog open={isOpen} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <CheckCircle color="green" />
          Complete Job: {jobTitle}
        </Box>
      </DialogTitle>
      <DialogContent dividers>
        <Box component="form" noValidate autoComplete="off" sx={{ mt: 1 }}>
          {/* Use the MUI TextField for consistent input styling */}
          <TextField
            autoFocus
            required
            margin="dense"
            label="Actual Final Cost"
            type="number"
            fullWidth
            variant="outlined"
            value={actualCost}
            onChange={(e) => setActualCost(e.target.value)}
            InputProps={{
              startAdornment: <InputAdornment position="start">$</InputAdornment>,
            }}
          />
          <TextField
            margin="dense"
            label="Internal Completion Notes (Optional)"
            type="text"
            fullWidth
            multiline
            rows={4}
            variant="outlined"
            value={completionNotes}
            onChange={(e) => setCompletionNotes(e.target.value)}
          />
        </Box>
      </DialogContent>
      <DialogActions sx={{ p: '16px 24px' }}>
        {/* Use MUI Buttons for consistent actions */}
        <Button onClick={onClose} variant="outlined" disabled={isSubmitting}>
          Cancel
        </Button>
        <Button
          onClick={handleConfirm}
          variant="contained"
          color="success"
          disabled={isSubmitting || !actualCost}
          startIcon={isSubmitting ? <CircularProgress size={20} color="inherit" /> : null}
        >
          {isSubmitting ? 'Confirming...' : 'Confirm Completion'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default CompleteJobModal;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/CustomerInfoSection.tsx ---

// packages/frontend/src/features/requests/components/CustomerInfoSection.tsx

import React, { useState, useEffect } from 'react';
import { Box, Typography, Paper, TextField, Button, Grid, IconButton, Alert } from '@mui/material';
import { Pencil, Check, X, User } from 'lucide-react';
import { logger } from '../../../lib/logger';

interface AddressData {
  service_address: string;
  latitude: number | null;
  longitude: number | null;
  geocoded_address: string | null;
}

interface CustomerInfoSectionProps {
   mode: 'view' | 'edit' | 'create';
   initialAddress?: string | AddressData;
   profileAddress?: string;
   isAdmin: boolean;
   onSave?: (addressData: AddressData) => Promise<void>;
   onCancel?: () => void;
   onDataChange?: (addressData: Partial<AddressData>) => void;
   onModeChange?: (useProfileAddress: boolean) => void;
   isUpdating?: boolean;
   request?: any; // For showing customer info
   showCustomerInfo?: boolean; // Whether to show customer name/phone/email
   canEdit?: boolean; // Whether user can edit (admin OR request owner)
 }

const CustomerInfoSection: React.FC<CustomerInfoSectionProps> = ({
   mode,
   initialAddress,
   profileAddress,
   isAdmin,
   onSave,
   onCancel,
   onDataChange,
   onModeChange,
   isUpdating = false,
   request,
   showCustomerInfo = false,
   canEdit = true, // Default to true for backward compatibility
 }) => {
  // State for edit mode
  const [isEditing, setIsEditing] = useState(mode === 'edit');
  const [useProfileAddress, setUseProfileAddress] = useState(true);
  const [serviceAddress, setServiceAddress] = useState('');
  const [serviceCity, setServiceCity] = useState('');
  const [serviceProvince, setServiceProvince] = useState('BC'); // Default to BC
  const [servicePostalCode, setServicePostalCode] = useState('');
  const [serviceCoordinates, setServiceCoordinates] = useState<{lat: number, lng: number} | null>(null);
  const [geocodingStatus, setGeocodingStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');

  // Initialize state based on mode and initialAddress
  useEffect(() => {
    if (mode === 'view' && typeof initialAddress === 'string') {
      // For view mode, parse the address in case user clicks edit later
      const parts = initialAddress.split(', ');
      if (parts.length >= 3) {
        // Format: "Street, City, Province PostalCode"
        setServiceAddress(parts[0]);
        const cityProvincePostal = parts.slice(1).join(', ');
        const lastPart = cityProvincePostal.split(' ');
        if (lastPart.length >= 3) {
          // Last 2 items are Province and PostalCode (e.g. "BC V8Z 5G6" -> ["BC", "V8Z", "5G6"])
          const postalCode = lastPart.slice(-2).join(' '); // "V8Z 5G6"
          const province = lastPart[lastPart.length - 3]; // "BC"
          const city = lastPart.slice(0, -3).join(' '); // "Victoria"
          setServiceCity(city);
          setServiceProvince(province);
          setServicePostalCode(postalCode);
        }
      }
      setIsEditing(false);
    } else if (mode === 'edit' && typeof initialAddress === 'string') {
      // Parse existing address for editing
      const parts = initialAddress.split(', ');
      if (parts.length >= 3) {
        setServiceAddress(parts[0]);
        const cityProvincePostal = parts.slice(1).join(', ');
        const lastPart = cityProvincePostal.split(' ');
        if (lastPart.length >= 3) {
          const postalCode = lastPart.slice(-2).join(' ');
          const province = lastPart[lastPart.length - 3];
          const city = lastPart.slice(0, -3).join(' ');
          setServiceCity(city);
          setServiceProvince(province);
          setServicePostalCode(postalCode);
        }
      }
      setIsEditing(true);
    } else if (mode === 'create') {
      // For create mode, start with empty fields
      setUseProfileAddress(true);
      setServiceAddress('');
      setServiceCity('');
      setServicePostalCode('');
      setServiceCoordinates(null);
      setGeocodingStatus('idle');
    }
  }, [mode, initialAddress]);

  // Geocoding function
  const geocodeServiceAddress = async () => {
    if (!serviceAddress.trim() || !serviceCity.trim() || !servicePostalCode.trim()) {
      return;
    }

    setGeocodingStatus('loading');

    try {
      const fullAddress = `${serviceAddress}, ${serviceCity}, ${serviceProvince} ${servicePostalCode}, Canada`;
      logger.log('Geocoding address:', fullAddress);

      // Load Google Maps API if not already loaded
      if (!window.google || !window.google.maps) {
        const apiKey = import.meta.env.VITE_GOOGLE_MAPS_API_KEY || 'AIzaSyDkEszizq7L57f0sY73jl99ZvvwDwZ_MGY';

        if (!apiKey) {
          throw new Error('Google Maps API key not found');
        }

        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&v=weekly&libraries=places`;
        script.async = true;
        script.defer = true;

        await new Promise((resolve, reject) => {
          script.onload = () => resolve(void 0);
          script.onerror = (error) => reject(error);
          document.head.appendChild(script);
        });
      }

      // Use Google Maps Geocoding service
      const geocoder = new (window as any).google.maps.Geocoder();

      geocoder.geocode({ address: fullAddress }, (results: any, status: any) => {
        if (status === (window as any).google.maps.GeocoderStatus.OK && results && results[0]) {
          const location = results[0].geometry.location;
          const coords = { lat: location.lat(), lng: location.lng() };
          setServiceCoordinates(coords);
          setGeocodingStatus('success');

          // Notify parent of geocoding success
          if (onDataChange) {
            onDataChange({
              service_address: `${serviceAddress}, ${serviceCity}, ${serviceProvince} ${servicePostalCode}`,
              latitude: coords.lat,
              longitude: coords.lng,
              geocoded_address: `${serviceAddress}, ${serviceCity}, ${serviceProvince} ${servicePostalCode}, Canada`,
            });
          }
        } else {
          setGeocodingStatus('error');
        }
      });

    } catch (error) {
      console.error('Geocoding error:', error);
      setGeocodingStatus('error');
    }
  };

  // Handle field changes
  const handleFieldChange = (field: string, value: string) => {
    let newAddress = serviceAddress;
    let newCity = serviceCity;
    let newProvince = serviceProvince;
    let newPostalCode = servicePostalCode;

    switch (field) {
      case 'street':
        newAddress = value;
        setServiceAddress(value);
        break;
      case 'city':
        newCity = value;
        setServiceCity(value);
        break;
      case 'province':
        newProvince = value;
        setServiceProvince(value);
        break;
      case 'postalCode':
        newPostalCode = value;
        setServicePostalCode(value);
        break;
    }

    // Reset geocoding status when user changes address
    if (geocodingStatus !== 'idle') {
      setGeocodingStatus('idle');
      setServiceCoordinates(null);
    }

    // Notify parent of data changes with full address
    if (onDataChange) {
      const fullAddress = `${newAddress}, ${newCity}, ${newProvince} ${newPostalCode}`;
      onDataChange({
        service_address: fullAddress,
        latitude: serviceCoordinates?.lat || null,
        longitude: serviceCoordinates?.lng || null,
        geocoded_address: serviceCoordinates ? `${newAddress}, ${newCity}, ${newProvince} ${newPostalCode}, Canada` : null,
      });
    }
  };

  // Handle save
  const handleSave = async () => {
    if (((mode === 'view' && isEditing) || mode === 'edit') && serviceCoordinates && onSave) {
      const addressData: AddressData = {
        service_address: `${serviceAddress}, ${serviceCity}, BC ${servicePostalCode}`,
        latitude: serviceCoordinates.lat,
        longitude: serviceCoordinates.lng,
        geocoded_address: `${serviceAddress}, ${serviceCity}, BC ${servicePostalCode}, Canada`
      };

      try {
        await onSave(addressData);
        // Exit edit mode on successful save
        setIsEditing(false);
      } catch (error) {
        // Keep in edit mode on error so user can try again
        console.error('Failed to save address:', error);
      }
    } else if (mode === 'create' && onDataChange) {
      // For create mode, just notify parent of the current state
      onDataChange({
        service_address: useProfileAddress ? '' : `${serviceAddress}, ${serviceCity}, BC ${servicePostalCode}`,
        latitude: serviceCoordinates?.lat || null,
        longitude: serviceCoordinates?.lng || null,
        geocoded_address: serviceCoordinates ? `${serviceAddress}, ${serviceCity}, BC ${servicePostalCode}, Canada` : null,
      });
    }
  };

  // Handle cancel
  const handleCancel = () => {
    if (mode === 'view' || mode === 'edit') {
      setIsEditing(false);
    }
    if (onCancel) {
      onCancel();
    }
  };

  // Render view mode
  if (mode === 'view' && !isEditing) {
    const customerProfile = request?.user_profiles;

    if (showCustomerInfo) {
      // Render as a Paper component with customer info AND service address
      return (
        <Paper variant="outlined" sx={{ p: 2 }}>
          <Typography variant="overline" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <User size={16} /> Customer Info
          </Typography>
          <Grid container spacing={2} sx={{ mt: 0.5 }}>
            <Grid item xs={12} sm={6}>
              <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>Name</Typography>
              <Typography variant="body1">{customerProfile?.name || 'N/A'}</Typography>
            </Grid>
            <Grid item xs={12} sm={6}>
              <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>Phone</Typography>
              <Button component="a" href={`tel:${customerProfile?.phone}`} size="small" sx={{ p: 0, justifyContent: 'flex-start' }}>
                {customerProfile?.phone || 'N/A'}
              </Button>
            </Grid>
            <Grid item xs={12} sm={6}>
              <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>Email</Typography>
              <Button component="a" href={`mailto:${customerProfile?.email}`} size="small" sx={{ p: 0, justifyContent: 'flex-start', textTransform: 'none' }}>
                {customerProfile?.email || 'N/A'}
              </Button>
            </Grid>
            <Grid item xs={12}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mt: 1 }}>
                <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>
                  Service Address
                </Typography>
                {canEdit && (
                  <IconButton size="small" onClick={() => setIsEditing(true)} disabled={isUpdating}>
                    <Pencil size={16} />
                  </IconButton>
                )}
              </Box>
              <Button
                component="a"
                href={`https://maps.google.com/?q=${encodeURIComponent(typeof initialAddress === 'string' ? initialAddress : '')}`}
                target="_blank"
                size="small"
                sx={{ p: 0, justifyContent: 'flex-start', textAlign: 'left', mt: 0.5 }}
              >
                {typeof initialAddress === 'string' ? initialAddress : 'N/A'}
              </Button>
            </Grid>
          </Grid>
        </Paper>
      );
    }

    // Original Grid item rendering (for RequestDetailModal compatibility)
    return (
      <Grid item xs={12} sm={6}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>
            Service Address
          </Typography>
          {canEdit && (
            <IconButton size="small" onClick={() => setIsEditing(true)} disabled={isUpdating}>
              <Pencil size={16} />
            </IconButton>
          )}
        </Box>
        <Button
          component="a"
          href={`https://maps.google.com/?q=${encodeURIComponent(typeof initialAddress === 'string' ? initialAddress : '')}`}
          target="_blank"
          size="small"
          sx={{ p: 0, justifyContent: 'flex-start', textAlign: 'left' }}
        >
          {typeof initialAddress === 'string' ? initialAddress : 'N/A'}
        </Button>
      </Grid>
    );
  }

  // Render edit mode (for both 'view' mode when editing and 'edit' mode)
  if ((mode === 'view' && isEditing) || (mode === 'edit' && isEditing)) {
    return (
      <Grid item xs={12}>
        <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary', mb: 1 }}>
          Service Address
        </Typography>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
          <TextField
            label="Street Address"
            value={serviceAddress}
            onChange={(e) => handleFieldChange('street', e.target.value)}
            size="small"
            fullWidth
            placeholder="123 Main Street"
            disabled={isUpdating}
            autoFocus
          />
          <Box sx={{ display: 'flex', gap: 1 }}>
            <TextField
              label="City"
              value={serviceCity}
              onChange={(e) => handleFieldChange('city', e.target.value)}
              size="small"
              fullWidth
              placeholder="Victoria"
              disabled={isUpdating}
            />
            <TextField
              label="Province"
              value={serviceProvince}
              onChange={(e) => handleFieldChange('province', e.target.value)}
              size="small"
              placeholder="BC"
              sx={{ minWidth: 80 }}
              disabled={isUpdating}
            />
            <TextField
              label="Postal Code"
              value={servicePostalCode}
              onChange={(e) => handleFieldChange('postalCode', e.target.value)}
              size="small"
              placeholder="V8W 1A1"
              sx={{ minWidth: 120 }}
              disabled={isUpdating}
            />
          </Box>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 1 }}>
            <Button
              variant="outlined"
              size="small"
              onClick={geocodeServiceAddress}
              disabled={geocodingStatus === 'loading' || !serviceAddress.trim() || !serviceCity.trim() || !servicePostalCode.trim() || isUpdating}
            >
              {geocodingStatus === 'loading' ? 'Verifying...' : 'Verify Address'}
            </Button>
            {geocodingStatus === 'success' && (
              <Typography variant="body2" sx={{ color: 'success.main', fontSize: '0.8rem' }}>
                ‚úì Address verified
              </Typography>
            )}
            {geocodingStatus === 'error' && (
              <Typography variant="body2" sx={{ color: 'error.main', fontSize: '0.8rem' }}>
                ‚úó Could not verify
              </Typography>
            )}
          </Box>
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
            <Button size="small" onClick={handleCancel} disabled={isUpdating}>
              Cancel
            </Button>
            <Button
              variant="contained"
              size="small"
              onClick={handleSave}
              disabled={isUpdating || geocodingStatus !== 'success'}
            >
              Save Changes
            </Button>
          </Box>
        </Box>
      </Grid>
    );
  }

  // Render create mode (for QuoteAgentModal)
  if (mode === 'create') {
    return (
      <Paper sx={{
        p: 3,
        borderRadius: 2,
        border: '1px solid',
        borderColor: 'divider'
      }}>
        <Typography variant="h6" sx={{ fontWeight: 600, mb: 2, color: 'primary.main' }}>
          Service Location
        </Typography>
        <Typography variant="body2" sx={{ mb: 2, color: 'text.secondary' }}>
          Where do you need the plumbing service performed?
        </Typography>

        {/* Address Option Toggle */}
        <Box sx={{ mb: 3 }}>
          <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
            <Button
              variant={useProfileAddress ? "contained" : "outlined"}
              size="small"
              onClick={() => {
                setUseProfileAddress(true);
                setServiceAddress("");
                setServiceCity("");
                setServiceProvince("BC");
                setServicePostalCode("");
                setServiceCoordinates(null);
                setGeocodingStatus('idle');
                if (onModeChange) {
                  onModeChange(true);
                }
              }}
              sx={{ flex: 1 }}
            >
              Use My Address
            </Button>
            <Button
              variant={!useProfileAddress ? "contained" : "outlined"}
              size="small"
              onClick={() => {
                setUseProfileAddress(false);
                if (onModeChange) {
                  onModeChange(false);
                }
              }}
              sx={{ flex: 1 }}
            >
              Different Address
            </Button>
          </Box>

          {useProfileAddress ? (
            <Box sx={{ p: 2, bgcolor: 'grey.50', borderRadius: 1 }}>
              <Typography variant="body2" sx={{ fontWeight: 500, mb: 1 }}>
                Service will be at your registered address:
              </Typography>
              <Typography variant="body2" sx={{ color: 'text.secondary' }}>
                {profileAddress || 'No address found in profile'}
              </Typography>
            </Box>
          ) : (
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
              <TextField
                label="Street Address"
                value={serviceAddress}
                onChange={(e) => handleFieldChange('street', e.target.value)}
                fullWidth
                size="small"
                placeholder="123 Main Street"
              />
              <Box sx={{ display: 'flex', gap: 2 }}>
                <TextField
                  label="City"
                  value={serviceCity}
                  onChange={(e) => handleFieldChange('city', e.target.value)}
                  fullWidth
                  size="small"
                  placeholder="Victoria"
                />
                <TextField
                  label="Province"
                  value={serviceProvince}
                  onChange={(e) => handleFieldChange('province', e.target.value)}
                  size="small"
                  placeholder="BC"
                  sx={{ minWidth: 80 }}
                />
                <TextField
                  label="Postal Code"
                  value={servicePostalCode}
                  onChange={(e) => handleFieldChange('postalCode', e.target.value)}
                  size="small"
                  placeholder="V8W 1A1"
                  sx={{ minWidth: 120 }}
                />
              </Box>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                <Button
                  variant="outlined"
                  size="small"
                  onClick={geocodeServiceAddress}
                  disabled={geocodingStatus === 'loading' || !serviceAddress.trim() || !serviceCity.trim() || !servicePostalCode.trim()}
                >
                  {geocodingStatus === 'loading' ? 'Verifying...' : 'Verify Address'}
                </Button>
                {geocodingStatus === 'success' && (
                  <Typography variant="body2" sx={{ color: 'success.main', fontSize: '0.8rem' }}>
                    ‚úì Address verified and located on map
                  </Typography>
                )}
                {geocodingStatus === 'error' && (
                  <Typography variant="body2" sx={{ color: 'error.main', fontSize: '0.8rem' }}>
                    ‚úó Could not verify address - please check spelling
                  </Typography>
                )}
              </Box>
            </Box>
          )}
        </Box>
      </Paper>
    );
  }

  return null;
};

export default CustomerInfoSection;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/Dashboard.tsx ---

// packages/frontend/src/features/requests/components/Dashboard.tsx

import React, { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { useAuth } from '../../auth/AuthContext';
import { Box, Typography, CircularProgress, Paper, Chip, Button, ButtonGroup, FormControlLabel, Switch, FormControl, InputLabel, Select, MenuItem, InputAdornment } from '@mui/material';
import { DataGrid, GridColDef } from '@mui/x-data-grid';
import RequestDetailModal from './RequestDetailModal';
import PipelineView from './PipelineView';
import { AlertTriangle, Map, Table, Siren, CalendarDays } from 'lucide-react';
import { getRequestStatusChipColor, getRequestStatusPinColor } from '../../../lib/statusColors';
import statusColors from '../../../lib/statusColors.json';
import { QuoteRequest, Quote } from '../types';
import MapView from '../../admin/components/MapView';
import { useRealtimeInvalidation } from '../../../hooks/useSupabaseRealtimeV3';
import { logger } from '../../../lib/logger';

interface DashboardProps {
  requests: QuoteRequest[];
  loading: boolean;
  error: string | null;
  refreshRequests: () => void;
}

const Dashboard: React.FC<DashboardProps> = ({ requests: allRequests, loading, error, refreshRequests }) => {
  const { profile } = useAuth();
  const [selectedRequest, setSelectedRequest] = useState<QuoteRequest | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [activeFilterStatus, setActiveFilterStatus] = useState<string>('all');
  const [activePipelineStage, setActivePipelineStage] = useState<string | null>(null);
  const [pipelineFilterStatuses, setPipelineFilterStatuses] = useState<string[]>([]);
  const [viewMode, setViewMode] = useState<'table' | 'map'>('table');
  const [isEmergencyFilter, setIsEmergencyFilter] = useState(false);
  const [dateFilter, setDateFilter] = useState<string>('all');
  const dataGridRef = useRef<HTMLDivElement>(null);

  // Enable centralized real-time invalidation for admin dashboard
  useRealtimeInvalidation();

  useEffect(() => {
    logger.log('üìä Dashboard: allRequests prop updated', {
      requestCount: allRequests.length,
      requestStatuses: allRequests.map(r => ({ id: r.id, status: r.status, hasQuotes: r.quotes?.length || 0 })),
      timestamp: new Date().toISOString()
    });

    if (selectedRequest && allRequests.length > 0) {
      const newRequestData = allRequests.find(r => r.id === selectedRequest.id);
      if (newRequestData) {
        logger.log('üìä Dashboard: updating selectedRequest', {
          id: newRequestData.id,
          oldStatus: selectedRequest.status,
          newStatus: newRequestData.status,
          timestamp: new Date().toISOString()
        });
        setSelectedRequest(newRequestData);
      }
    }
  }, [allRequests, selectedRequest?.id]);

  const filteredRequests = useMemo(() => {
    let requests = allRequests;

    // Apply pipeline stage filter if active (takes precedence)
    if (pipelineFilterStatuses.length > 0) {
      requests = requests.filter(request =>
        pipelineFilterStatuses.includes(request.status)
      );
    }
    // Otherwise apply single status filter from chips
    else if (activeFilterStatus !== 'all') {
      requests = requests.filter(request => request.status === activeFilterStatus);
    }

    // Apply date filter
    if (dateFilter !== 'all') {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const weekStart = new Date(today);
      weekStart.setDate(today.getDate() - today.getDay()); // Start of week (Sunday)
      const weekEnd = new Date(weekStart);
      weekEnd.setDate(weekStart.getDate() + 6); // End of week (Saturday)

      requests = requests.filter(request => {
        const scheduledDate = request.scheduled_start_date ? new Date(request.scheduled_start_date) : null;

        switch (dateFilter) {
          case 'today':
            return scheduledDate && scheduledDate.toDateString() === today.toDateString();
          case 'week':
            return scheduledDate && scheduledDate >= weekStart && scheduledDate <= weekEnd;
          case 'unscheduled':
            return request.status === 'accepted' && !scheduledDate;
          case 'overdue':
            return scheduledDate && scheduledDate < today && request.status !== 'completed';
          default:
            return true;
        }
      });
    }

    // Then, apply emergency filter on top
    if (isEmergencyFilter) {
      requests = requests.filter(request => request.is_emergency === true);
    }

    return requests;
  }, [allRequests, activeFilterStatus, pipelineFilterStatuses, dateFilter, isEmergencyFilter]);

  // Add data-request-id attributes to DataGrid rows for integration testing
  useEffect(() => {
    logger.log('üîç DataGrid useEffect running:', {
      hasRef: !!dataGridRef.current,
      requestCount: filteredRequests.length,
      viewMode
    });

    if (dataGridRef.current && filteredRequests.length > 0) {
      const rows = dataGridRef.current.querySelectorAll('[role="row"]');
      logger.log(`üîç Found ${rows.length} rows in DataGrid`);

      rows.forEach((row, index) => {
        if (index > 0 && filteredRequests[index - 1]) { // Skip header row
          const requestId = filteredRequests[index - 1].id;
          row.setAttribute('data-request-id', requestId);
          logger.log(`‚úÖ Added data-request-id="${requestId}" to row ${index}`);
        }
      });
    }
  }, [filteredRequests, viewMode]);

  const handleRowClick = (params: any) => {
    // Instead of directly opening the modal, navigate via hash so URL reflects state
    const id = params.id as string;
    if (id) {
      window.location.hash = `#/requests/${id}`;
    }
  };

  const handleModalUpdate = useCallback(() => {
    refreshRequests();
  }, [refreshRequests]);

  const handleCloseModal = () => {
    // Close by navigating back to dashboard route
    window.location.hash = '#/dashboard';
    setIsModalOpen(false);
    setSelectedRequest(null);
  };

  // Sync modal state with URL hash: if #/requests/:id, open modal for that id
  useEffect(() => {
    const checkHash = () => {
      const hash = window.location.hash || '';
      if (hash.startsWith('#/requests/')) {
        const id = hash.split('/')[2];
        if (id) {
          const found = allRequests.find(r => r.id === id);
          if (found) {
            setSelectedRequest(found);
            setIsModalOpen(true);
          } else {
            // If not found yet (list may still be loading), keep modal closed but
            // allow the RequestDetailModalLoader to fetch details via hook if needed.
            setSelectedRequest(null);
            setIsModalOpen(true);
          }
          return;
        }
      }
      // Default: not a request deep-link
      setIsModalOpen(false);
      setSelectedRequest(null);
    };

    // Run on mount and whenever allRequests changes
    checkHash();
    const onHashChange = () => checkHash();
    window.addEventListener('hashchange', onHashChange);
    return () => window.removeEventListener('hashchange', onHashChange);
  }, [allRequests]);

  const handleStageClick = useCallback((stageId: string, statuses: string[]) => {
    // If clicking the same stage, clear filter to show all
    if (activePipelineStage === stageId) {
      setActivePipelineStage(null);
      setPipelineFilterStatuses([]);
      setActiveFilterStatus('all');
    } else {
      // Set active stage and filter to ALL statuses in the stage's array
      setActivePipelineStage(stageId);
      setPipelineFilterStatuses(statuses);
      setActiveFilterStatus('all'); // Clear chip filter when using pipeline
    }
  }, [activePipelineStage]);

  const allStatuses = [
    'all',
    'new',
    'viewed',
    'quoted',
    'accepted',
    'scheduled',
    'in_progress',
    'completed',
    'invoiced',
    'paid',
    'overdue',
    'disputed',
    'cancelled'
  ];

  const columns: GridColDef[] = [
    // 1. STATUS: Most important workflow state.
    {
      field: 'status',
      headerName: 'Status',
      width: 120,
      renderCell: (params) => {
        const status = params.value || 'default';
        const color = statusColors[status as keyof typeof statusColors] || statusColors.default;
        // Determine text color based on background for better contrast
        const textColor = ['#FBC02D', '#F57C00'].includes(color) ? '#000' : '#fff';

        return (
          <Chip
            label={params.value || 'N/A'}
            size="small"
            sx={{
              textTransform: 'capitalize',
              fontWeight: 'bold',
              backgroundColor: color,
              color: textColor,
            }}
          />
        );
      },
    },
    // 2. PRIORITY: AI-generated score for triage.
    {
      field: 'priority_score',
      headerName: 'Priority',
      width: 100,
      type: 'number',
      renderCell: (params) => (
        params.value == null
          ? <Typography variant="body2" color="text.secondary">‚Äî</Typography>
          : <Typography variant="body2" sx={{ fontWeight: 'bold' }}>{params.value}</Typography>
      )
    },
    // 3. URGENCY: Clear visual flag for emergencies.
    {
      field: 'is_emergency',
      headerName: 'Urgency',
      width: 120,
      renderCell: (params) => (
        params.value
          ? <Chip icon={<AlertTriangle size={14} />} label="Emergency" color="error" size="small" variant="outlined" />
          : null
      ),
    },
    // 4. CUSTOMER NAME: Essential context.
    {
      field: 'customer_name',
      headerName: 'Customer Name',
      width: 180,
      valueGetter: (value, row) => row.user_profiles?.name || row.customer_name || 'N/A',
    },
    // 5. REQUEST TYPE: What is the job?
    {
      field: 'problem_category',
      headerName: 'Request Type',
      width: 180,
      valueFormatter: (value) => value ? String(value).replace(/_/g, " ").replace(/\b\w/g, (l:string) => l.toUpperCase()) : 'N/A',
    },
    // 6. RECEIVED DATE: How old is the lead?
    {
      field: 'created_at',
      headerName: 'Received',
      width: 180,
      type: 'dateTime',
      valueGetter: (value) => value ? new Date(value) : null,
      valueFormatter: (value) => value ? new Date(value).toLocaleString() : '',
    },
    // 7. SCHEDULED DATE: When is the job scheduled?
    {
      field: 'scheduled_start_date',
      headerName: 'Scheduled',
      width: 180,
      type: 'dateTime',
      valueGetter: (value, row) => {
        // Only show scheduled date if status is 'scheduled' or 'accepted' with a date
        if (row.status === 'scheduled' && value) {
          return new Date(value);
        }
        if (row.status === 'accepted' && value) {
          return new Date(value);
        }
        return null;
      },
      valueFormatter: (value) => value ? new Date(value).toLocaleString() : '',
      renderCell: (params) => {
        const scheduledDate = params.value;
        if (!scheduledDate) {
          // Show different text based on status
          const status = params.row.status;
          if (status === 'accepted') {
            return <Typography variant="body2" color="warning.main" sx={{ fontStyle: 'italic' }}>Needs Scheduling</Typography>;
          }
          return <Typography variant="body2" color="text.secondary">‚Äî</Typography>;
        }
        return <Typography variant="body2">{new Date(scheduledDate).toLocaleString()}</Typography>;
      }
    },
    // 8. ADDRESS: Geographic context. Takes remaining space.
    {
      field: 'service_address',
      headerName: 'Address',
      flex: 1
    },
  ];

  if (loading && allRequests.length === 0) return <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}><CircularProgress /></Box>;
  if (!profile || profile.role !== 'admin') return <Box sx={{ p: 4 }}><Typography>Access Denied. You must be an administrator to view this page.</Typography></Box>;
  if (error) return <Box sx={{ p: 4 }}><Typography color="error">{error}</Typography></Box>;

  return (
    <>
      <Box sx={{ bgcolor: '#f4f6f8', minHeight: 'calc(100vh - 80px)', p: { xs: 2, md: 4 } }}>
        <Box sx={{ maxWidth: '1200px', margin: 'auto' }}>
          {/* Main Dashboard Header */}
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
            <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
              Plumber's Command Center
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              {/* Date Filter */}
              <FormControl size="small" sx={{ minWidth: 180 }}>
                <InputLabel id="date-filter-label">Schedule</InputLabel>
                <Select
                  labelId="date-filter-label"
                  value={dateFilter}
                  label="Schedule"
                  onChange={(e) => setDateFilter(e.target.value)}
                  startAdornment={
                    <InputAdornment position="start">
                      <CalendarDays size={16} />
                    </InputAdornment>
                  }
                >
                  <MenuItem value="all">All Time</MenuItem>
                  <MenuItem value="today">Scheduled Today</MenuItem>
                  <MenuItem value="week">Scheduled This Week</MenuItem>
                  <MenuItem value="unscheduled">Unscheduled (Accepted)</MenuItem>
                  <MenuItem value="overdue">Overdue</MenuItem>
                </Select>
              </FormControl>

              {/* Emergency Toggle */}
              <FormControlLabel
                control={<Switch checked={isEmergencyFilter} onChange={(e) => setIsEmergencyFilter(e.target.checked)} />}
                label={
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    <Siren size={16} />
                    Emergencies Only
                  </Box>
                }
              />

              <ButtonGroup variant="outlined" size="small">
                <Button
                  startIcon={<Table size={16} />}
                  variant={viewMode === 'table' ? 'contained' : 'outlined'}
                  onClick={() => setViewMode('table')}
                >
                  Table
                </Button>
                <Button
                  startIcon={<Map size={16} />}
                  variant={viewMode === 'map' ? 'contained' : 'outlined'}
                  onClick={() => setViewMode('map')}
                >
                  Map
                </Button>
              </ButtonGroup>
            </Box>
          </Box>

          {/* Pipeline Workflow Visualization */}
          <Box sx={{ mb: 3 }}>
            <PipelineView
              requests={filteredRequests}
              activeStage={activePipelineStage}
              onStageClick={handleStageClick}
              activeFilterStatus={activeFilterStatus}
              onStatusClick={(status) => {
                setActiveFilterStatus(status);
                setPipelineFilterStatuses([status]);
              }}
            />

            {/* Clear Filters Button - Only show when filters are active */}
            {(activePipelineStage || activeFilterStatus !== 'all' || dateFilter !== 'all' || isEmergencyFilter) && (
              <Box sx={{ display: 'flex', justifyContent: 'center', mt: 2 }}>
                <Button
                  variant="outlined"
                  size="small"
                  onClick={() => {
                    setActivePipelineStage(null);
                    setPipelineFilterStatuses([]);
                    setActiveFilterStatus('all');
                    setDateFilter('all');
                    setIsEmergencyFilter(false);
                  }}
                  sx={{ textTransform: 'none' }}
                >
                  Clear All Filters
                </Button>
              </Box>
            )}
          </Box>

          {viewMode === 'table' ? (
            <Paper ref={dataGridRef} sx={{ height: 600, width: '100%' }}>
              <DataGrid
                rows={filteredRequests}
                columns={columns}
                getRowId={(row) => row.id}
                onRowClick={handleRowClick}
                disableColumnFilter={false}
                initialState={{
                  pagination: { paginationModel: { pageSize: 10 } },
                  sorting: { sortModel: [{ field: 'created_at', sort: 'desc' }] },
                }}
                pageSizeOptions={[10, 25, 50]}
                sx={{
                  border: 0,
                  '& .MuiDataGrid-columnHeaders': {
                    backgroundColor: '#e3f2fd',
                    fontSize: '1rem'
                  },
                  '& .MuiDataGrid-columnHeaderTitle': {
                    fontWeight: 'bold'
                  },
                  '& .MuiDataGrid-row': {
                    minHeight: '60px !important', // Increase row height
                    '&:hover': {
                      cursor: 'pointer',
                      backgroundColor: '#f0f7ff'
                    }
                  },
                  '& .MuiDataGrid-cell': {
                    padding: '12px 16px', // Add more padding to cells
                  }
                }}
              />
            </Paper>
          ) : (
            <MapView
              requests={filteredRequests}
              onRequestSelect={(request) => {
                setSelectedRequest(request);
                setIsModalOpen(true);
              }}
            />
          )}
        </Box>
      </Box>
      {selectedRequest && (
        <RequestDetailModal
          isOpen={isModalOpen}
          onClose={handleCloseModal}
          request={selectedRequest}
          onUpdateRequest={handleModalUpdate}
        />
      )}
    </>
  );
};

export default Dashboard;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/InvoiceFormModal.tsx ---

// packages/frontend/src/features/requests/components/InvoiceFormModal.tsx

import React, { useState, useEffect, useRef } from 'react';
import { Box, Typography, TextField, Button, Divider, InputAdornment, Grid, MenuItem, Chip } from '@mui/material';
import { useAuth } from '../../auth/AuthContext';
import { QuoteRequest } from '../types';
import apiClient from '../../../lib/apiClient';

// Import reusable components
import ModalHeader from './ModalHeader';
import ModalFooter from './ModalFooter';
import CustomerInfoSection from './CustomerInfoSection';

interface InvoiceFormModalProps {
  isOpen: boolean;
  onClose: (updated?: boolean) => void;
  invoice?: any;
  mode: 'create' | 'edit' | 'view';
  request: QuoteRequest;
  requestId: string;
}

interface LineItem {
  description: string;
  quantity: string;
  unit_price: string;
  total: number;
}

const InvoiceFormModal: React.FC<InvoiceFormModalProps> = ({
  isOpen,
  onClose,
  invoice,
  mode,
  request,
  requestId
}) => {
  const { profile } = useAuth();
  const firstFieldRef = useRef<HTMLInputElement>(null);

  const [laborItems, setLaborItems] = useState<LineItem[]>([{ description: '', quantity: '1', unit_price: '', total: 0 }]);
  const [materialItems, setMaterialItems] = useState<LineItem[]>([{ description: '', quantity: '1', unit_price: '', total: 0 }]);
  const [dueDate, setDueDate] = useState('');
  const [notes, setNotes] = useState('');
  const [paymentMethod, setPaymentMethod] = useState('');
  const [isSaving, setIsSaving] = useState(false);

  const isAdmin = profile?.role === 'admin';
  const editable = mode !== 'view' && isAdmin;
  const isReadOnly = mode === 'view' || !isAdmin || request.status === 'paid';

  useEffect(() => {
    if (isOpen) {
      if (invoice) {
        // Load existing invoice data
        const lineItems = invoice.line_items || [];
        const labor = lineItems.filter((item: any) => item.type === 'labor');
        const materials = lineItems.filter((item: any) => item.type === 'material');

        setLaborItems(labor.length > 0 ? labor : [{ description: '', quantity: '1', unit_price: '', total: 0 }]);
        setMaterialItems(materials.length > 0 ? materials : [{ description: '', quantity: '1', unit_price: '', total: 0 }]);
        setNotes(invoice.notes || '');
        setDueDate(invoice.due_date?.split('T')[0] || '');
        setPaymentMethod(invoice.payment_method || '');
      } else if (mode === 'create' && request.accepted_quote_id) {
        // Pre-populate from accepted quote
        loadQuoteData(request.accepted_quote_id);
      } else {
        // New invoice with defaults
        setLaborItems([{ description: '', quantity: '1', unit_price: '', total: 0 }]);
        setMaterialItems([{ description: '', quantity: '1', unit_price: '', total: 0 }]);
        setNotes('');
        setPaymentMethod('');

        // Default due date to 30 days from now
        const thirtyDaysFromNow = new Date();
        thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
        setDueDate(thirtyDaysFromNow.toISOString().split('T')[0]);
      }

      // Auto-focus first field
      setTimeout(() => {
        if (firstFieldRef.current && editable) {
          firstFieldRef.current.focus();
        }
      }, 100);
    }
  }, [invoice, isOpen, mode, request.accepted_quote_id]);

  const loadQuoteData = async (quoteId: string) => {
    try {
      // Fetch the accepted quote to pre-populate invoice
      const response = await apiClient.get(`/quotes/${quoteId}`);
      const quote = response.data;

      if (quote.details) {
        const details = typeof quote.details === 'string' ? JSON.parse(quote.details) : quote.details;

        // Convert quote items to invoice line items
        const laborLineItems = (details.labor_items || []).map((item: any) => ({
          description: item.description,
          quantity: '1',
          unit_price: item.price,
          total: parseFloat(item.price) || 0,
          type: 'labor'
        }));

        const materialLineItems = (details.material_items || []).map((item: any) => ({
          description: item.description,
          quantity: '1',
          unit_price: item.price,
          total: parseFloat(item.price) || 0,
          type: 'material'
        }));

        setLaborItems(laborLineItems.length > 0 ? laborLineItems : [{ description: '', quantity: '1', unit_price: '', total: 0 }]);
        setMaterialItems(materialLineItems.length > 0 ? materialLineItems : [{ description: '', quantity: '1', unit_price: '', total: 0 }]);

        if (details.notes) {
          setNotes(`Based on Quote #${quoteId.slice(0, 8)}\n\n${details.notes}`);
        }
      }
    } catch (error) {
      console.error('Error loading quote data:', error);
    }
  };

  const handleLineItemChange = (
    items: LineItem[],
    setItems: React.Dispatch<React.SetStateAction<LineItem[]>>,
    index: number,
    field: keyof LineItem,
    value: string
  ) => {
    const newItems = [...items];
    newItems[index] = { ...newItems[index], [field]: value };

    // Recalculate total for this line
    if (field === 'quantity' || field === 'unit_price') {
      const qty = parseFloat(newItems[index].quantity) || 0;
      const price = parseFloat(newItems[index].unit_price) || 0;
      newItems[index].total = qty * price;
    }

    setItems(newItems);
  };

  const addLineItem = (items: LineItem[], setItems: React.Dispatch<React.SetStateAction<LineItem[]>>) => {
    setItems([...items, { description: '', quantity: '1', unit_price: '', total: 0 }]);
  };

  const removeLineItem = (items: LineItem[], setItems: React.Dispatch<React.SetStateAction<LineItem[]>>, index: number) => {
    if (items.length > 1) {
      setItems(items.filter((_, i) => i !== index));
    }
  };

  const calculateTotals = () => {
    const laborTotal = laborItems.reduce((sum, item) => sum + (item.total || 0), 0);
    const materialTotal = materialItems.reduce((sum, item) => sum + (item.total || 0), 0);
    const subtotal = laborTotal + materialTotal;

    // BC Tax Rules:
    // GST (5%): Applied to ALL labor + materials
    // PST (7%): Applied to materials ONLY (labor is PST exempt in BC)
    const gst = subtotal * 0.05;
    const pst = materialTotal * 0.07;
    const totalTax = gst + pst;
    const total = subtotal + totalTax;

    return {
      laborTotal,
      materialTotal,
      subtotal,
      gst,
      pst,
      totalTax,
      total
    };
  };

  const handleSaveInvoice = async () => {
    const totals = calculateTotals();

    // Validation
    if (totals.subtotal === 0) {
      window.dispatchEvent(new CustomEvent('show-snackbar', {
        detail: { message: 'Please add at least one line item with a price.', severity: 'error' }
      }));
      return;
    }

    setIsSaving(true);

    try {
      // Prepare line items with type tags
      const allLineItems = [
        ...laborItems.filter(item => item.description && parseFloat(item.unit_price) > 0).map(item => ({ ...item, type: 'labor' })),
        ...materialItems.filter(item => item.description && parseFloat(item.unit_price) > 0).map(item => ({ ...item, type: 'material' }))
      ];

      const invoiceData = {
        request_id: requestId,
        line_items: allLineItems,
        subtotal: totals.subtotal,
        tax_amount: totals.totalTax,
        total: totals.total,
        due_date: dueDate,
        notes: notes,
        status: mode === 'create' ? 'sent' : invoice?.status || 'sent',
        payment_method: paymentMethod || null
      };

      let response;
      if (mode === 'create') {
        response = await apiClient.post(`/requests/${requestId}/invoices`, invoiceData);
      } else {
        response = await apiClient.patch(`/invoices/${invoice.id}`, invoiceData);
      }

      window.dispatchEvent(new CustomEvent('show-snackbar', {
        detail: {
          message: mode === 'create' ? 'Invoice created successfully!' : 'Invoice updated successfully!',
          severity: 'success'
        }
      }));

      onClose(true);
    } catch (error) {
      console.error('Error saving invoice:', error);
      window.dispatchEvent(new CustomEvent('show-snackbar', {
        detail: { message: 'Failed to save invoice. Please try again.', severity: 'error' }
      }));
    } finally {
      setIsSaving(false);
    }
  };

  const handleMarkAsPaid = async () => {
    if (!invoice || !paymentMethod) {
      window.dispatchEvent(new CustomEvent('show-snackbar', {
        detail: { message: 'Please select a payment method before marking as paid.', severity: 'error' }
      }));
      return;
    }

    setIsSaving(true);

    try {
      await apiClient.post(`/invoices/${invoice.id}/mark-paid`, {
        payment_method: paymentMethod
      });

      window.dispatchEvent(new CustomEvent('show-snackbar', {
        detail: { message: 'Invoice marked as paid!', severity: 'success' }
      }));

      onClose(true);
    } catch (error) {
      console.error('Error marking invoice as paid:', error);
      window.dispatchEvent(new CustomEvent('show-snackbar', {
        detail: { message: 'Failed to mark invoice as paid. Please try again.', severity: 'error' }
      }));
    } finally {
      setIsSaving(false);
    }
  };

  if (!isOpen) return null;

  const totals = calculateTotals();
  const invoiceNumber = invoice?.id ? `INV-${invoice.id.slice(0, 8).toUpperCase()}` : 'New Invoice';

  // Chip color for status badge
  const chipColor = invoice?.status === 'paid' ? 'success' : invoice?.status === 'overdue' ? 'error' : 'warning';

  // Header background color - always use default grey for consistency
  const headerBgColor = undefined; // Let ModalHeader use its default

  return (
    <Box
      sx={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        bgcolor: 'rgba(0, 0, 0, 0.8)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1300,
        p: 2
      }}
      onClick={() => onClose()}
    >
      <Box
        sx={{
          bgcolor: 'background.paper',
          borderRadius: 2,
          width: '100%',
          maxWidth: 900,
          maxHeight: '90vh',
          overflow: 'auto',
          boxShadow: 24
        }}
        onClick={(e) => e.stopPropagation()}
      >
        <ModalHeader
          title={invoiceNumber}
          onClose={onClose}
          statusColor={headerBgColor}
          actions={
            invoice?.status && (
              <Chip
                label={invoice.status.toUpperCase()}
                color={chipColor}
                size="small"
              />
            )
          }
        />

        <Box sx={{ p: 3, maxHeight: 'calc(90vh - 180px)', overflowY: 'auto' }}>
          <CustomerInfoSection
            mode="view"
            showCustomerInfo={true}
            request={request}
            initialAddress={request.service_address}
            isAdmin={false}
            onSave={async () => {}}
            onModeChange={() => {}}
          />

          <Divider sx={{ my: 3 }} />

          {/* Labor Items */}
          <Typography variant="h6" gutterBottom>
            Labor
          </Typography>
          {laborItems.map((item, index) => (
            <Grid container spacing={2} key={index} sx={{ mb: 2 }}>
              <Grid item xs={12} sm={5}>
                <TextField
                  fullWidth
                  size="small"
                  label="Description"
                  value={item.description}
                  onChange={(e) => handleLineItemChange(laborItems, setLaborItems, index, 'description', e.target.value)}
                  disabled={isReadOnly}
                  inputRef={index === 0 ? firstFieldRef : undefined}
                />
              </Grid>
              <Grid item xs={4} sm={2}>
                <TextField
                  fullWidth
                  size="small"
                  label="Qty"
                  type="number"
                  value={item.quantity}
                  onChange={(e) => handleLineItemChange(laborItems, setLaborItems, index, 'quantity', e.target.value)}
                  disabled={isReadOnly}
                />
              </Grid>
              <Grid item xs={4} sm={2}>
                <TextField
                  fullWidth
                  size="small"
                  label="Unit Price"
                  type="number"
                  value={item.unit_price}
                  onChange={(e) => handleLineItemChange(laborItems, setLaborItems, index, 'unit_price', e.target.value)}
                  disabled={isReadOnly}
                  InputProps={{
                    startAdornment: <InputAdornment position="start">$</InputAdornment>
                  }}
                />
              </Grid>
              <Grid item xs={3} sm={2}>
                <TextField
                  fullWidth
                  size="small"
                  label="Total"
                  value={item.total.toFixed(2)}
                  disabled
                  InputProps={{
                    startAdornment: <InputAdornment position="start">$</InputAdornment>
                  }}
                />
              </Grid>
              <Grid item xs={1} sm={1}>
                {!isReadOnly && laborItems.length > 1 && (
                  <Button
                    size="small"
                    color="error"
                    onClick={() => removeLineItem(laborItems, setLaborItems, index)}
                  >
                    ‚úï
                  </Button>
                )}
              </Grid>
            </Grid>
          ))}
          {!isReadOnly && (
            <Button size="small" onClick={() => addLineItem(laborItems, setLaborItems)}>
              + Add Labor Item
            </Button>
          )}

          <Divider sx={{ my: 3 }} />

          {/* Material Items */}
          <Typography variant="h6" gutterBottom>
            Materials
          </Typography>
          {materialItems.map((item, index) => (
            <Grid container spacing={2} key={index} sx={{ mb: 2 }}>
              <Grid item xs={12} sm={5}>
                <TextField
                  fullWidth
                  size="small"
                  label="Description"
                  value={item.description}
                  onChange={(e) => handleLineItemChange(materialItems, setMaterialItems, index, 'description', e.target.value)}
                  disabled={isReadOnly}
                />
              </Grid>
              <Grid item xs={4} sm={2}>
                <TextField
                  fullWidth
                  size="small"
                  label="Qty"
                  type="number"
                  value={item.quantity}
                  onChange={(e) => handleLineItemChange(materialItems, setMaterialItems, index, 'quantity', e.target.value)}
                  disabled={isReadOnly}
                />
              </Grid>
              <Grid item xs={4} sm={2}>
                <TextField
                  fullWidth
                  size="small"
                  label="Unit Price"
                  type="number"
                  value={item.unit_price}
                  onChange={(e) => handleLineItemChange(materialItems, setMaterialItems, index, 'unit_price', e.target.value)}
                  disabled={isReadOnly}
                  InputProps={{
                    startAdornment: <InputAdornment position="start">$</InputAdornment>
                  }}
                />
              </Grid>
              <Grid item xs={3} sm={2}>
                <TextField
                  fullWidth
                  size="small"
                  label="Total"
                  value={item.total.toFixed(2)}
                  disabled
                  InputProps={{
                    startAdornment: <InputAdornment position="start">$</InputAdornment>
                  }}
                />
              </Grid>
              <Grid item xs={1} sm={1}>
                {!isReadOnly && materialItems.length > 1 && (
                  <Button
                    size="small"
                    color="error"
                    onClick={() => removeLineItem(materialItems, setMaterialItems, index)}
                  >
                    ‚úï
                  </Button>
                )}
              </Grid>
            </Grid>
          ))}
          {!isReadOnly && (
            <Button size="small" onClick={() => addLineItem(materialItems, setMaterialItems)}>
              + Add Material Item
            </Button>
          )}

          <Divider sx={{ my: 3 }} />

          {/* Totals Summary */}
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 3 }}>
            <Box sx={{ minWidth: 300 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography>Labor Subtotal:</Typography>
                <Typography>${totals.laborTotal.toFixed(2)}</Typography>
              </Box>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography>Materials Subtotal:</Typography>
                <Typography>${totals.materialTotal.toFixed(2)}</Typography>
              </Box>
              <Divider sx={{ my: 1 }} />
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography>Subtotal:</Typography>
                <Typography fontWeight="bold">${totals.subtotal.toFixed(2)}</Typography>
              </Box>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="caption">GST (5% on all):</Typography>
                <Typography variant="caption">${totals.gst.toFixed(2)}</Typography>
              </Box>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="caption">PST (7% on materials):</Typography>
                <Typography variant="caption">${totals.pst.toFixed(2)}</Typography>
              </Box>
              <Divider sx={{ my: 1 }} />
              <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                <Typography variant="h6">Total:</Typography>
                <Typography variant="h6" color="primary">${totals.total.toFixed(2)}</Typography>
              </Box>
            </Box>
          </Box>

          {/* Due Date and Payment */}
          <Grid container spacing={2} sx={{ mb: 3 }}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Due Date"
                type="date"
                value={dueDate}
                onChange={(e) => setDueDate(e.target.value)}
                disabled={isReadOnly}
                InputLabelProps={{ shrink: true }}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                select
                label="Payment Method"
                value={paymentMethod}
                onChange={(e) => setPaymentMethod(e.target.value)}
                disabled={isReadOnly && invoice?.status === 'paid'}
              >
                <MenuItem value="">Not specified</MenuItem>
                <MenuItem value="stripe">Stripe (Online)</MenuItem>
                <MenuItem value="check">Check</MenuItem>
                <MenuItem value="cash">Cash</MenuItem>
                <MenuItem value="etransfer">E-Transfer</MenuItem>
                <MenuItem value="other">Other</MenuItem>
              </TextField>
            </Grid>
          </Grid>

          {/* Notes */}
          <TextField
            fullWidth
            multiline
            rows={4}
            label="Notes"
            value={notes}
            onChange={(e) => setNotes(e.target.value)}
            disabled={isReadOnly}
            placeholder="Add any notes or payment instructions for the customer..."
          />
        </Box>

        <ModalFooter>
          <Button onClick={() => onClose(false)}>
            {isReadOnly ? 'Close' : 'Cancel'}
          </Button>

          {!isReadOnly && (
            <Button
              variant="contained"
              onClick={handleSaveInvoice}
              disabled={isSaving || totals.subtotal === 0}
            >
              {isSaving ? 'Saving...' : mode === 'create' ? 'Create Invoice' : 'Save Changes'}
            </Button>
          )}

          {isAdmin && invoice?.status === 'sent' && (
            <Button
              variant="contained"
              color="success"
              onClick={handleMarkAsPaid}
              disabled={isSaving || !paymentMethod}
            >
              {isSaving ? 'Processing...' : 'Mark as Paid'}
            </Button>
          )}
        </ModalFooter>
      </Box>
    </Box>
  );
};

export default InvoiceFormModal;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/ModalFooter.tsx ---

// packages/frontend/src/features/requests/components/ModalFooter.tsx

import React from 'react';
import { Box } from '@mui/material';

interface ModalFooterProps {
  children: React.ReactNode; // This allows us to pass any buttons or content into the footer
}

const ModalFooter: React.FC<ModalFooterProps> = ({ children }) => {
  return (
    <Box
      sx={{
        p: { xs: 2, md: 3 },
        borderTop: 1,
        borderColor: 'divider',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        flexShrink: 0,
        bgcolor: 'grey.50' // Added a slight background color for consistency
      }}
    >
      {children}
    </Box>
  );
};

export default ModalFooter;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/ModalHeader.tsx ---

// packages/frontend/src/features/requests/components/ModalHeader.tsx

import React from 'react';
import { Box, Typography, IconButton } from '@mui/material';
import { X as XIcon } from 'lucide-react';

interface ModalHeaderProps {
  title: string;
  subtitle?: string;
  onClose: () => void;
  // The 'actions' prop allows us to pass in any button or component, like the "AI Triage" button
  actions?: React.ReactNode;
  // Optional status color to theme the header
  statusColor?: string;
}

const ModalHeader: React.FC<ModalHeaderProps> = ({ title, subtitle, onClose, actions, statusColor }) => {
  // Use status color if provided, otherwise default to grey
  const bgColor = statusColor || 'grey.800';

  return (
    <Box sx={{
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      bgcolor: bgColor,
      color: '#fff',
      px: 3,
      py: 2,
      flexShrink: 0
    }}>
      <Box>
        <Typography variant="h5" sx={{ fontWeight: 700 }}>
          {title}
        </Typography>
        {subtitle && (
          <Typography variant="caption" sx={{ color: 'rgba(255, 255, 255, 0.8)' }}>
            {subtitle}
          </Typography>
        )}
      </Box>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        {actions}
        <IconButton onClick={onClose} sx={{ color: '#fff' }}>
          <XIcon size={24} />
        </IconButton>
      </Box>
    </Box>
  );
};

export default ModalHeader;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/MyRequests.tsx ---

// packages/frontend/src/features/requests/components/MyRequests.tsx

import React, { useState, useCallback, useEffect } from 'react';
import { useAuth } from '../../auth/AuthContext';
import { Box, Typography, CircularProgress, Paper, Chip } from '@mui/material';
import RequestDetailModal from './RequestDetailModal';
import { QuoteRequest } from '../types';
import { getRequestStatusChipColor, getRequestStatusPinColor } from '../../../lib/statusColors';
import statusColors from '../../../lib/statusColors.json';
import { useRealtimeInvalidation } from '../../../hooks/useSupabaseRealtimeV3';
import { logger } from '../../../lib/logger';

interface MyRequestsProps {
  requests: QuoteRequest[];
  loading: boolean;
  error: string | null;
  refreshRequests: () => void;
}

const MyRequests: React.FC<MyRequestsProps> = ({ requests, loading, error, refreshRequests }) => {
  const { user } = useAuth();
  const [selectedRequest, setSelectedRequest] = useState<QuoteRequest | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);

  // Enable centralized real-time invalidation for user requests
  useRealtimeInvalidation(user?.id);

  useEffect(() => {
    logger.log('üìã MyRequests: requests prop updated', {
      requestCount: requests.length,
      requestIds: requests.map(r => ({ id: r.id, status: r.status }))
    });

    if (selectedRequest && requests.length > 0) {
      const newRequestData = requests.find(r => r.id === selectedRequest.id);
      if (newRequestData) {
        logger.log('üìã MyRequests: updating selectedRequest', {
          id: newRequestData.id,
          oldStatus: selectedRequest.status,
          newStatus: newRequestData.status
        });
        setSelectedRequest(newRequestData);
      }
    }
  }, [requests, selectedRequest?.id]);

  const handleOpenModal = (req: QuoteRequest) => {
    setSelectedRequest(req);
    setIsModalOpen(true);
  };

  const handleModalUpdate = useCallback(() => {
    refreshRequests();
  }, [refreshRequests]);

  const handleCloseModal = () => {
    setIsModalOpen(false);
    setSelectedRequest(null);
  };

  if (loading && requests.length === 0) return <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}><CircularProgress /></Box>;
  if (error) return <Box sx={{ p: 4 }}><Typography color="error">{error}</Typography></Box>;

  return (
    <>
      <section id="my-requests" className="py-16 bg-gray-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <Typography variant="h4" gutterBottom sx={{ fontWeight: 'bold', mb: 4, textAlign: 'center' }}>
            My Quote Requests
          </Typography>

          {requests.length > 0 ? (
            <Box sx={{ maxWidth: '800px', margin: 'auto', display: 'flex', flexDirection: 'column', gap: 2 }}>
              {requests.map((req) => {
                const mostRecentQuote = req.quotes?.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0];
                return (
                  <button key={`${req.id}-${req.status}-${req.quotes?.length || 0}`} data-request-id={req.id} onClick={() => handleOpenModal(req)} className="w-full bg-white p-4 rounded-lg shadow-md flex items-center justify-between text-left hover:bg-gray-50 transition-colors duration-200">
                    <Box>
                      <Typography variant="h6" component="div" sx={{ textTransform: 'capitalize' }}>
                        {req.problem_category.replace(/_/g, " ")}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        Submitted: {new Date(req.created_at).toLocaleDateString()}
                      </Typography>
                    </Box>
                    <Box sx={{ textAlign: 'right', display: 'flex', alignItems: 'center', gap: 2 }}>
                      {mostRecentQuote && (
                        <Typography variant="h6" sx={{ fontWeight: 'bold' }}>
                          ${mostRecentQuote.quote_amount.toFixed(2)}
                        </Typography>
                      )}
                      <Chip
                        label={req.status}
                        size="small"
                        sx={{
                          textTransform: 'capitalize',
                          fontWeight: 'bold',
                          backgroundColor: statusColors[req.status as keyof typeof statusColors] || statusColors.default,
                          // Set text color to black for yellow/orange, otherwise white
                          color: ['#FBC02D', '#F57C00'].includes(statusColors[req.status as keyof typeof statusColors]) ? '#000' : '#fff',
                        }}
                      />
                    </Box>
                  </button>
                );
              })}
            </Box>
          ) : (
            <Paper sx={{ p: 4, textAlign: 'center', maxWidth: '800px', margin: 'auto' }}>
              <Typography variant="h6" color="text.secondary">
                You have no quote requests yet. Request a quote now!
              </Typography>
            </Paper>
          )}
        </div>
      </section>

      {selectedRequest && (
        <RequestDetailModal
          isOpen={isModalOpen}
          onClose={handleCloseModal}
          request={selectedRequest}
          onUpdateRequest={handleModalUpdate}
        />
      )}
    </>
  );
};

export default MyRequests;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/PipelineView.tsx ---

// packages/frontend/src/features/requests/components/PipelineView.tsx

import React from 'react';
import { Box, Typography, Paper, Badge, Chip, Collapse } from '@mui/material';
import { Inbox, DollarSign, Calendar, Wrench, FileText, CheckCircle, AlertTriangle } from 'lucide-react';
import { QuoteRequest } from '../types';
import statusColors from '../../../lib/statusColors.json';

interface PipelineStage {
  id: string;
  label: string;
  statuses: string[];
  icon: React.ReactNode;
  color: string;
  textColor: string;
}

interface PipelineViewProps {
  requests: QuoteRequest[];
  activeStage: string | null;
  onStageClick: (stageId: string, statuses: string[]) => void;
  activeFilterStatus?: string;
  onStatusClick?: (status: string) => void;
}

const PipelineView: React.FC<PipelineViewProps> = ({
  requests,
  activeStage,
  onStageClick,
  activeFilterStatus = 'all',
  onStatusClick
}) => {
  const stages: PipelineStage[] = [
    {
      id: 'intake',
      label: 'Intake',
      statuses: ['new'],
      icon: <Inbox size={18} />,
      color: '#3B82F6', // Blue
      textColor: '#fff'
    },
    {
      id: 'quoting',
      label: 'Quoting',
      statuses: ['viewed', 'quoted'],
      icon: <DollarSign size={18} />,
      color: '#8B5CF6', // Purple
      textColor: '#fff'
    },
    {
      id: 'scheduled',
      label: 'Scheduled',
      statuses: ['accepted', 'scheduled'],
      icon: <Calendar size={18} />,
      color: '#10B981', // Green
      textColor: '#fff'
    },
    {
      id: 'active',
      label: 'Active',
      statuses: ['in_progress'],
      icon: <Wrench size={18} />,
      color: '#F59E0B', // Orange
      textColor: '#fff'
    },
    {
      id: 'billing',
      label: 'Billing',
      statuses: ['completed', 'invoiced'],
      icon: <FileText size={18} />,
      color: '#14B8A6', // Teal
      textColor: '#fff'
    },
    {
      id: 'paid',
      label: 'Paid',
      statuses: ['paid'],
      icon: <CheckCircle size={18} />,
      color: '#22C55E', // Success Green
      textColor: '#fff'
    },
    {
      id: 'issues',
      label: 'Issues',
      statuses: ['overdue', 'disputed'],
      icon: <AlertTriangle size={18} />,
      color: '#EF4444', // Red
      textColor: '#fff'
    }
  ];

  // Calculate count for each stage
  const getStageCount = (statuses: string[]) => {
    return requests.filter(req => statuses.includes(req.status)).length;
  };

  // Helper to create light tint of a color (15% opacity)
  const getLightTint = (hexColor: string) => {
    // Convert hex to rgba with 15% opacity
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, 0.15)`;
  };

  return (
    <Paper sx={{ mb: 3, overflow: 'hidden' }}>
      <Box sx={{ p: 2, bgcolor: 'background.default' }}>
        <Typography variant="overline" color="text.secondary" sx={{ fontWeight: 'bold' }}>
          Pipeline Overview
        </Typography>
      </Box>
      <Box sx={{ display: 'flex', position: 'relative' }}>
        {stages.map((stage, idx) => {
          const count = getStageCount(stage.statuses);
          const isActive = activeStage === stage.id;
          const isInactive = count === 0 && !isActive;

          return (
            <Box
              key={stage.id}
              onClick={() => onStageClick(stage.id, stage.statuses)}
              sx={{
                flex: 1,
                py: 2,
                px: 2,
                bgcolor: isActive ? stage.color : isInactive ? 'grey.100' : getLightTint(stage.color),
                color: isActive ? stage.textColor : stage.color,
                position: 'relative',
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                borderRight: idx < stages.length - 1 ? '1px solid' : 'none',
                borderColor: 'divider',
                // Chevron shape using pseudo-elements
                '&::after': idx < stages.length - 1 ? {
                  content: '""',
                  position: 'absolute',
                  right: '-12px',
                  top: '50%',
                  transform: 'translateY(-50%)',
                  width: 0,
                  height: 0,
                  borderTop: '24px solid transparent',
                  borderBottom: '24px solid transparent',
                  borderLeft: `12px solid ${isActive ? stage.color : isInactive ? '#f5f5f5' : getLightTint(stage.color)}`,
                  zIndex: 1,
                  filter: 'drop-shadow(1px 0 1px rgba(0, 0, 0, 0.15))',
                } : {},
                // Add subtle shadow to the entire box for depth
                boxShadow: '0 1px 3px rgba(0, 0, 0, 0.08)',
                '&:hover': {
                  bgcolor: stage.color,
                  color: stage.textColor,
                  opacity: 0.9,
                  '&::after': {
                    borderLeftColor: stage.color,
                  }
                },
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, justifyContent: 'center' }}>
                {stage.icon}
                <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                  {stage.label}
                </Typography>
              </Box>
              <Typography
                variant="h5"
                sx={{
                  textAlign: 'center',
                  fontWeight: 'bold',
                  mt: 0.5,
                  opacity: isInactive ? 0.5 : 1
                }}
              >
                {count}
              </Typography>
            </Box>
          );
        })}
      </Box>

      {/* Expandable Status Chips for Active Stage */}
      {activeStage && onStatusClick && (
        <Collapse in={!!activeStage}>
          <Box sx={{
            p: 2,
            bgcolor: 'grey.50',
            borderTop: '1px solid',
            borderColor: 'divider',
            display: 'flex',
            alignItems: 'center',
            gap: 1,
            flexWrap: 'wrap'
          }}>
            <Typography variant="caption" sx={{ color: 'text.secondary', fontWeight: 'bold', mr: 1 }}>
              Filter {stages.find(s => s.id === activeStage)?.label}:
            </Typography>
            {stages.find(s => s.id === activeStage)?.statuses.map(status => (
              <Chip
                key={status}
                label={status.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}
                size="small"
                onClick={() => onStatusClick(status)}
                variant={activeFilterStatus === status ? 'filled' : 'outlined'}
                sx={{
                  textTransform: 'capitalize',
                  fontWeight: activeFilterStatus === status ? 'bold' : 'normal',
                  borderColor: statusColors[status as keyof typeof statusColors] || 'grey.400',
                  ...(activeFilterStatus === status && {
                    bgcolor: statusColors[status as keyof typeof statusColors],
                    color: ['#FBC02D', '#F57C00'].includes(statusColors[status as keyof typeof statusColors]) ? '#000' : '#fff',
                  }),
                  ...( activeFilterStatus !== status && {
                    color: statusColors[status as keyof typeof statusColors],
                  }),
                }}
              />
            ))}
          </Box>
        </Collapse>
      )}
    </Paper>
  );
};

export default PipelineView;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/QuoteAgentModal.tsx ---

// packages/frontend/src/features/requests/components/QuoteAgentModal.tsx
// YAML-driven quote intake modal with conversational interface
// date: october 20, 2025 9:19pm
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import {
  Alert,
  Box,
  Button,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  Paper,
  TextField,
  Typography,
} from "@mui/material";
import {
  Send,
  X as CloseIcon,
  Wrench,
  AlertCircle,
  Home,
  Calendar,
  ClipboardList,
  MessageCircle,
  User
} from "lucide-react";
import { useAuth } from "../../auth/AuthContext";
import CustomerInfoSection from "./CustomerInfoSection";
import AttachmentSection from "./AttachmentSection";
import apiClient, { uploadAttachments } from "../../../lib/apiClient";
import { useSubmitQuoteRequest } from "../../../hooks";
import { services as SERVICE_DEFINITIONS } from "../../../lib/serviceDefinitions";
import { logger } from '../../../lib/logger';

interface QuoteAgentModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmissionSuccess: (newRequest: any) => void;
  preselectedService?: string | null;
}

type AgentMessage = {
  role: string;
  content?: unknown;
  text?: string;
  type?: string;
  inputType?: string;
  options?: Array<{ label?: string; value?: string } | string>;
};

type SummaryAnswer = {
  question: string;
  answer: string;
};

type SummaryPayload = {
  service?: {
    label?: string;
    key?: string;
  };
  emergency?: boolean | string;
  answers: SummaryAnswer[];
};

type AddressPayload = {
  service_address: string;
  latitude: number | null;
  longitude: number | null;
  geocoded_address: string | null;
};

const safeParseJson = (input: string): any => {
  try {
    return JSON.parse(input);
  } catch {
    return null;
  }
};

const isLocalHost =
  typeof window !== "undefined" &&
  window.location.hostname &&
  (window.location.hostname === "localhost" ||
    window.location.hostname === "127.0.0.1" ||
    window.location.hostname === "::1");

// Local dev: Express proxy route, Production: Netlify function
const AGENT_ENDPOINT = isLocalHost
  ? "/api/agents/quote/run"
  : "/.netlify/functions/quote-agent";
const REVIEW_STAGE = "review_summary";

const sanitizeText = (value: unknown): string => {
  if (!value) return "";
  if (typeof value === "string") return value;
  if (Array.isArray(value)) {
    return value
      .map((item) => sanitizeText(item))
      .filter(Boolean)
      .join("\n");
  }
  if (typeof value === "object" && "text" in (value as any)) {
    return sanitizeText((value as any).text);
  }
  return JSON.stringify(value);
};

// Helper function to determine contextual icon based on message content
const getContextualIcon = (text: string) => {
  const lowerText = text.toLowerCase();

  if (lowerText.includes('emergency')) {
    return <AlertCircle size={18} style={{ color: '#dc2626' }} />;
  }
  if (lowerText.includes('property') || lowerText.includes('home')) {
    return <Home size={18} style={{ color: '#3182CE' }} />;
  }
  if (lowerText.includes('when') || lowerText.includes('date') || lowerText.includes('time')) {
    return <Calendar size={18} style={{ color: '#3182CE' }} />;
  }
  if (lowerText.includes('review') || lowerText.includes('confirm') || lowerText.includes('summary')) {
    return <ClipboardList size={18} style={{ color: '#3182CE' }} />;
  }

  // Default wrench icon for service-related questions
  return <Wrench size={18} style={{ color: '#3182CE' }} />;
};

const resolveServiceKey = (summaryService?: SummaryPayload["service"]) => {
  if (!summaryService) return undefined;
  const providedKey =
    summaryService.key?.toLowerCase().replace(/[^a-z0-9_]+/g, "_")?.replace(/_+/g, "_")?.replace(/^_|_$/g, "") ||
    undefined;
  if (providedKey) {
    const directMatch = SERVICE_DEFINITIONS.find(
      (service) => service.key.toLowerCase() === providedKey
    );
    if (directMatch) return directMatch.key;
  }

  const label = summaryService.label?.toLowerCase().trim();
  if (label) {
    const labelMatch = SERVICE_DEFINITIONS.find(
      (service) => service.title.toLowerCase() === label
    );
    if (labelMatch) return labelMatch.key;
  }

  if (providedKey) return providedKey;
  if (label) {
    return label.replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
  }

  return undefined;
};

const buildServiceAddressPayload = (
  useProfileAddress: boolean,
  profile: any,
  manualAddress: Partial<AddressPayload>
): AddressPayload => {
  if (useProfileAddress) {
    if (
      !profile?.address ||
      !profile?.city ||
      !profile?.province ||
      !profile?.postal_code
    ) {
      throw new Error(
        "Your profile address is incomplete. Please update it or choose a different service address."
      );
    }
    return {
      service_address: `${profile.address}, ${profile.city}, ${profile.province} ${profile.postal_code}`,
      latitude: profile.latitude ?? null,
      longitude: profile.longitude ?? null,
      geocoded_address: profile.geocoded_address ?? null,
    };
  }

  if (!manualAddress?.service_address) {
    throw new Error(
      "Please enter the service address and click Verify Address before submitting."
    );
  }

  if (
    manualAddress.latitude === null ||
    manualAddress.latitude === undefined ||
    manualAddress.longitude === null ||
    manualAddress.longitude === undefined
  ) {
    throw new Error(
      "Service address verification is required. Please verify the address and try again."
    );
  }

  return {
    service_address: manualAddress.service_address,
    latitude: manualAddress.latitude,
    longitude: manualAddress.longitude,
    geocoded_address:
      manualAddress.geocoded_address ?? manualAddress.service_address,
  };
};

export const QuoteAgentModal: React.FC<QuoteAgentModalProps> = ({
  isOpen,
  onClose,
  onSubmissionSuccess,
  preselectedService,
}) => {
  const { profile, user } = useAuth();
  const submitQuoteMutation = useSubmitQuoteRequest();

  const [conversation, setConversation] = useState<AgentMessage[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isInitializing, setIsInitializing] = useState(false);
  const [stage, setStage] = useState<"chat" | "summary">("chat");
  const [summary, setSummary] = useState<SummaryPayload | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [attachments, setAttachments] = useState<File[]>([]);
  const [useProfileAddress, setUseProfileAddress] = useState(true);
  const [addressData, setAddressData] = useState<Partial<AddressPayload>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const scrollAnchorRef = useRef<HTMLDivElement | null>(null);
  const sessionIdRef = useRef<string>('');

  const resetState = useCallback(() => {
    setConversation([]);
    setInputValue("");
    setIsLoading(false);
    setIsInitializing(false);
    setStage("chat");
    setSummary(null);
    setError(null);
    setAttachments([]);
    setUseProfileAddress(true);
    setAddressData({});
    setIsSubmitting(false);
    sessionIdRef.current = '';
  }, []);

  useEffect(() => {
    let isCancelled = false;

    if (!isOpen) {
      resetState();
      return () => {
        isCancelled = true;
      };
    }

    // Prevent re-initialization if we already have a conversation
    if (conversation.length > 0) {
      return () => {
        isCancelled = true;
      };
    }

    sessionIdRef.current =
      typeof crypto !== "undefined" && typeof crypto.randomUUID === "function"
        ? crypto.randomUUID()
        : `session-${Date.now()}-${Math.random().toString(36).slice(2)}`;

    const initializeConversation = async () => {
      setIsInitializing(true);
      setError(null);
      try {
        if (!sessionIdRef.current) {
          throw new Error("Unable to initialize agent session.");
        }

        // Use apiClient so dev requests go to backend on port 3000
        const resp = await apiClient.post('/agents/quote/run', {
          messages: [],
          context: {
            sessionId: sessionIdRef.current,
            preselectedService,
            userId: user?.id,
            profile: profile
              ? {
                  name: profile.name,
                  email: profile.email,
                  phone: profile.phone,
                  address: profile.address,
                  city: profile.city,
                  province: profile.province,
                  postal_code: profile.postal_code,
                }
              : null,
          },
        });

        const data = resp.data;
        if (!isCancelled) {
          handleAgentResponse(data);
        }
      } catch (err) {
        if (!isCancelled) {
          console.error("QuoteAgentModal: init error", err);
          setError(
            err instanceof Error
              ? err.message
              : "Failed to start the quote assistant. Please try again."
          );
        }
      } finally {
        if (!isCancelled) {
          setIsInitializing(false);
        }
      }
    };

    initializeConversation();

    return () => {
      isCancelled = true;
    };
  }, [isOpen, preselectedService, profile, resetState, user, conversation.length]);

  useEffect(() => {
    if (scrollAnchorRef.current) {
      scrollAnchorRef.current.scrollIntoView({ behavior: "smooth" });
    }
  }, [conversation, stage]);

  const handleAgentResponse = (data: any) => {
    logger.log('[QuoteAgentModal] handleAgentResponse called', { data });
    const returnedMessages = Array.isArray(data?.messages)
      ? (data.messages as AgentMessage[])
      : [];
    logger.log('[QuoteAgentModal] Setting conversation to:', returnedMessages.length, 'messages');
    setConversation(returnedMessages);

    if (data?.stage === REVIEW_STAGE && data?.summary) {
      logger.log('[QuoteAgentModal] Setting stage to summary');
      setSummary(data.summary as SummaryPayload);
      setStage("summary");
    } else {
      logger.log('[QuoteAgentModal] Setting stage to chat');
      setStage("chat");
      setSummary(null);
    }
  };

  const callAgent = useCallback(
    async (messagesPayload: AgentMessage[]) => {
      setIsLoading(true);
      setError(null);

      try {
        if (!sessionIdRef.current) {
          throw new Error("Agent session is not initialized.");
        }

        const resp = await apiClient.post('/agents/quote/run', {
          messages: messagesPayload,
          context: {
            sessionId: sessionIdRef.current,
            preselectedService,
            userId: user?.id,
          },
        });

        const data = resp.data;
        handleAgentResponse(data);
      } catch (err) {
        console.error("QuoteAgentModal: callAgent error", err);
        setError(
          err instanceof Error
            ? err.message
            : "The assistant is unavailable. Please try again."
        );
      } finally {
        setIsLoading(false);
      }
    },
    [preselectedService, user?.id]
  );

  const submitReply = useCallback(
    async (reply?: string | AgentMessage) => {
      logger.log('[QuoteAgentModal] submitReply called', { reply, isLoading, stage });
      if (isLoading || stage !== "chat") {
        logger.log('[QuoteAgentModal] submitReply blocked', { isLoading, stage });
        return;
      }

      let userMessage: AgentMessage;
      if (typeof reply === "object" && reply !== null) {
        // reply is already an AgentMessage
        userMessage = reply;
        logger.log('[QuoteAgentModal] Using provided AgentMessage');
      } else {
        // reply is a string, create AgentMessage
        const candidate = typeof reply === "string" ? reply : inputValue;
        const trimmed = candidate?.trim();
        if (!trimmed) {
          logger.log('[QuoteAgentModal] submitReply blocked - empty trimmed');
          return;
        }

        logger.log('[QuoteAgentModal] submitReply proceeding', { reply: trimmed });
        userMessage = {
          role: "user",
          content: trimmed,
          text: trimmed,
        };
      }

      // Calculate next messages BEFORE updating state
      const nextMessages = [...conversation, userMessage];
      logger.log('[QuoteAgentModal] Calculated nextMessages, length:', nextMessages.length);

      // Update conversation state
      setConversation(nextMessages);
      logger.log('[QuoteAgentModal] setConversation called, new length:', nextMessages.length);

      logger.log('[QuoteAgentModal] About to call callAgent with messages:', nextMessages.length);
      await callAgent(nextMessages);
      logger.log('[QuoteAgentModal] callAgent completed');

      // Clear input after successful send
      setInputValue('');
    },
    [callAgent, inputValue, isLoading, stage, conversation]
  );

  const handleSendMessage = async (value?: string | AgentMessage) => {
    logger.log('[QuoteAgentModal] handleSendMessage called with:', value);
    await submitReply(value);
  };

  const handleFinalSubmit = async () => {
    if (!summary) return;

    setIsSubmitting(true);
    setError(null);

    try {
      const clarifyingAnswers = summary.answers.map((item) => ({
        question: item.question,
        answer: item.answer,
      }));

      const answerLookup = (needle: string) => {
        const lowered = needle.toLowerCase();
        const match = summary.answers.find((answer) =>
          answer.question.toLowerCase().includes(lowered)
        );
        return match?.answer;
      };

      const serviceKey = resolveServiceKey(summary.service) ?? "other";
      const isEmergencyValue =
        typeof summary.emergency === "boolean"
          ? summary.emergency
          : typeof summary.emergency === "string"
          ? summary.emergency.toLowerCase().startsWith("y")
          : false;

      const serviceAddressPayload = buildServiceAddressPayload(
        useProfileAddress,
        profile,
        addressData
      );

      const payload: Record<string, any> = {
        clarifyingAnswers,
        contactInfo: profile,
        category: serviceKey,
        isEmergency: isEmergencyValue,
        property_type: answerLookup("property") ?? undefined,
        is_homeowner: answerLookup("own this property") ?? answerLookup("homeowner") ?? undefined,
        preferred_timing: answerLookup("when would you like") ?? undefined,
        additional_notes:
          answerLookup("additional details") ??
          answerLookup("anything else") ??
          undefined,
        ...serviceAddressPayload,
      };

      const result = await submitQuoteMutation.mutateAsync(payload);
      const newRequest = result?.request;

      if (attachments.length > 0 && newRequest?.id) {
        await uploadAttachments(newRequest.id, attachments);
      }

      onSubmissionSuccess(newRequest);
      onClose();
    } catch (err) {
      console.error("QuoteAgentModal: submission error", err);
      setError(
        err instanceof Error
          ? err.message
          : "Failed to submit your request. Please try again."
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const visibleMessages = useMemo(() => {
    const messages = conversation
      .map((message) => {
        const text =
          typeof message.text === "string"
            ? message.text
            : sanitizeText(message.content);
        return { ...message, text };
      })
      .filter(
        (message) =>
          !(message.role === "assistant" && message.type === "summary")
      );

    logger.log('[QuoteAgentModal] visibleMessages:', messages.length, 'messages');
    messages.forEach((msg, i) => {
      logger.log(`  Message ${i}: role=${msg.role}, type=${msg.type}, hasOptions=${!!(msg as any).options}`);
    });

    return messages;
  }, [conversation]);

  const serviceDefinition = useMemo(() => {
    if (!summary?.service) return null;
    const normalizedLabel = summary.service.label?.toLowerCase();
    const resolvedKey = resolveServiceKey(summary.service);
    return (
      SERVICE_DEFINITIONS.find(
        (service) =>
          service.title.toLowerCase() === normalizedLabel ||
          service.key === resolvedKey
      ) ?? null
    );
  }, [summary]);

  const emergencyFlag =
    typeof summary?.emergency === "boolean"
      ? summary.emergency
      : typeof summary?.emergency === "string"
      ? summary.emergency.toLowerCase().startsWith("y")
      : false;

  const profileAddressString = profile
    ? `${profile.address}, ${profile.city}, ${profile.province} ${profile.postal_code}`
    : "";

  const handleAttachmentRemove = (index: number) => {
    setAttachments((prev) => prev.filter((_, i) => i !== index));
  };

  const handleDialogClose = () => {
    if (isSubmitting || isLoading) return;
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100vw',
        height: '100vh',
        background: 'rgba(0,0,0,0.4)',
        zIndex: 1000,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      <div
        style={{
          background: '#fff',
          borderRadius: '12px',
          boxShadow: '0 8px 32px rgba(0,0,0,0.18)',
          maxWidth: '500px',
          width: '95%',
          maxHeight: '90vh',
          display: 'flex',
          flexDirection: 'column'
        }}
      >
        {/* Header */}
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '16px 20px',
            borderBottom: '1px solid #e0e0e0'
          }}
        >
          <h2 style={{ fontWeight: 'bold', color: '#1976d2', margin: 0 }}>
            Request a Quote
          </h2>
          <button
            onClick={handleDialogClose}
            disabled={isSubmitting || isLoading}
            style={{
              background: 'none',
              border: 'none',
              fontSize: '24px',
              cursor: 'pointer',
              color: '#666',
              padding: '4px'
            }}
          >
            √ó
          </button>
        </div>

        {/* Content */}
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
          {error && (
            <div style={{ padding: '16px', background: '#ffebee', borderBottom: '1px solid #e0e0e0' }}>
              <div style={{ color: '#c62828', fontSize: '14px' }}>{error}</div>
            </div>
          )}

          {stage === "chat" && (
            <ChatPanel
              messages={visibleMessages}
              inputValue={inputValue}
              onInputChange={setInputValue}
              onSendMessage={handleSendMessage}
              isLoading={isLoading || isInitializing}
              scrollAnchorRef={scrollAnchorRef}
            />
          )}

          {stage === "summary" && summary && (
            <SummaryPanel
              summary={summary}
              emergency={emergencyFlag}
              serviceDefinition={serviceDefinition}
              attachments={attachments}
              onAddAttachments={(files) =>
                setAttachments((prev) => [...prev, ...files])
              }
              onRemoveAttachment={handleAttachmentRemove}
              profile={profile}
              profileAddress={profileAddressString}
              useProfileAddress={useProfileAddress}
              onUseProfileAddressChange={setUseProfileAddress}
              onAddressDataChange={(data) =>
                setAddressData((prev) => ({ ...prev, ...data }))
              }
              isSubmitting={isSubmitting || submitQuoteMutation.isPending}
              onSubmit={handleFinalSubmit}
            />
          )}
        </div>
      </div>
    </div>
  );
};


interface ChatPanelProps {
  messages: AgentMessage[];
  inputValue: string;
  onInputChange: (value: string) => void;
  onSendMessage: (text?: string | AgentMessage) => void;
  isLoading: boolean;
  scrollAnchorRef: React.RefObject<HTMLDivElement>;
}

const ChatPanel: React.FC<ChatPanelProps> = ({
  messages,
  inputValue,
  onInputChange,
  onSendMessage,
  isLoading,
  scrollAnchorRef,
}) => {
  const inputRef = useRef<HTMLInputElement | null>(null);

  // Auto-focus whenever new messages arrive or loading finishes
  useEffect(() => {
    if (!isLoading) {
      inputRef.current?.focus();
    }
  }, [messages, isLoading]);

  const handleOptionClick = (option: string) => {
    onSendMessage(option);
  };

  const handleOptionKeyDown = (event: React.KeyboardEvent, option: string) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleOptionClick(option);
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      {/* Conversation bubbles */}
      <div
        style={{
          flex: 1,
          overflowY: 'auto',
          padding: '16px',
          display: 'flex',
          flexDirection: 'column',
          gap: '12px',
        }}
      >
        {messages.map((message, index) => {
          logger.log(`[ChatPanel] Processing message ${index}:`, {
            role: message.role,
            type: message.type,
            hasOptions: !!(message as any).options,
            text: message.text?.substring(0, 50)
          });

          const isUser = message.role === "user";
          const parsed =
            !isUser && typeof message.text === "string"
              ? safeParseJson(message.text)
              : null;

          const rawOptions =
            (message as any).options ??
            (message.content && (message.content as any).options) ??
            (parsed?.options && Array.isArray(parsed.options)
              ? parsed.options
              : null);

          const normalizedOptions = Array.isArray(rawOptions)
            ? rawOptions
                .map((option: any) => {
                  if (typeof option === "string") {
                    return {
                      label: option,
                      value: option,
                    };
                  }
                  if (option && typeof option === "object") {
                    const label =
                      option.label ??
                      option.value ??
                      sanitizeText(option);
                    const value =
                      option.value ??
                      option.label ??
                      sanitizeText(option);
                    return { label, value };
                  }
                  return null;
                })
                .filter((option): option is { label: string; value: string } =>
                  Boolean(option?.value)
                )
            : [];

          logger.log('[ChatPanel] Message options:', {
            messageRole: message.role,
            hasOptions: normalizedOptions.length > 0,
            optionCount: normalizedOptions.length,
            rawOptions,
            normalizedOptions
          });

          const promptText =
            (parsed?.prompt as string | undefined) ??
            (typeof message.text === "string"
              ? message.text
              : sanitizeText(message.content));

          // Dynamic rendering based on message type
          const shouldShowChoiceButtons = message.type === 'choice' && normalizedOptions.length > 0;
          const shouldShowTextInput = message.type === 'input' || (!shouldShowChoiceButtons && !isUser);

          logger.log('[ChatPanel] Message rendering decision:', {
            messageRole: message.role,
            messageType: message.type,
            hasOptions: normalizedOptions.length > 0,
            shouldShowChoiceButtons,
            shouldShowTextInput,
            optionCount: normalizedOptions.length
          });

          return (
            <div key={`${message.role}-${index}`}>
              {/* Message bubble */}
              <div
                style={{
                  display: 'flex',
                  alignItems: 'flex-start',
                  justifyContent: isUser ? 'flex-end' : 'flex-start',
                  marginBottom: '12px',
                }}
              >
                {!isUser && (
                  <div
                    style={{
                      width: '36px',
                      height: '36px',
                      borderRadius: '50%',
                      background: '#E0F0FF',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      marginRight: '10px',
                      flexShrink: 0,
                    }}
                  >
                    {getContextualIcon(promptText)}
                  </div>
                )}
                <div
                  style={{
                    maxWidth: '75%',
                    background: isUser ? '#2563EB' : '#F8F9FA',
                    color: isUser ? 'white' : '#1F2937',
                    padding: '12px 16px',
                    borderRadius: '16px',
                    boxShadow: '0 1px 2px rgba(0,0,0,0.08)',
                    whiteSpace: 'pre-wrap',
                    lineHeight: '1.5',
                  }}
                >
                  <div style={{ fontSize: '14px' }}>
                    {promptText}
                  </div>
                </div>
                {isUser && (
                  <div
                    style={{
                      width: '36px',
                      height: '36px',
                      borderRadius: '50%',
                      background: '#2563EB',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      marginLeft: '10px',
                      flexShrink: 0,
                    }}
                  >
                    <User size={18} style={{ color: 'white' }} />
                  </div>
                )}
              </div>

              {/* Dynamic UI based on message type */}
              {shouldShowChoiceButtons && (
                <Box
                  sx={{
                    display: 'flex',
                    flexWrap: 'wrap',
                    gap: 1,
                    marginLeft: '46px',
                    marginRight: 'auto',
                    maxWidth: '400px',
                    mt: 1
                  }}
                >
                  {normalizedOptions.map((option, idx) => {
                    logger.log(`[ChatPanel] Rendering button ${idx}:`, option.label, option.value);
                    return (
                      <Button
                        key={`${option.value}-${option.label}-${idx}`}
                        variant="outlined"
                        size="small"
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          const value = option.value || option.label;
                          logger.log('[ChatPanel] Button clicked, sending option:', value);

                          const userMessage: AgentMessage = {
                            role: "user",
                            text: value,
                            content: value,
                          };

                          logger.log('[ChatPanel] Created userMessage:', userMessage);
                          onSendMessage(userMessage);
                          logger.log('[ChatPanel] Called onSendMessage');
                        }}
                        sx={{
                          borderRadius: '24px',
                          textTransform: 'none',
                          px: 2.5,
                          py: 1,
                          fontSize: '0.9rem',
                          fontWeight: 500,
                          border: '1.5px solid',
                          borderColor: '#3182CE',
                          color: '#3182CE',
                          bgcolor: 'white',
                          transition: 'all 0.2s ease-in-out',
                          boxShadow: '0 1px 3px rgba(0,0,0,0.08)',
                          '&:hover': {
                            bgcolor: '#E0F0FF',
                            borderColor: '#2563EB',
                            color: '#2563EB',
                            transform: 'translateY(-1px)',
                            boxShadow: '0 4px 12px rgba(37, 99, 235, 0.2)'
                          },
                          '&:active': {
                            bgcolor: '#2563EB',
                            color: 'white',
                            borderColor: '#2563EB',
                            transform: 'translateY(0)',
                            boxShadow: '0 1px 3px rgba(0,0,0,0.12)'
                          }
                        }}
                        tabIndex={0}
                      >
                        {option.label}
                      </Button>
                    );
                  })}
                </Box>
              )}
            </div>
          );
        })}

        {isLoading && (
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '10px',
              marginBottom: '12px',
            }}
          >
            <div
              style={{
                width: '36px',
                height: '36px',
                borderRadius: '50%',
                background: '#E0F0FF',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                flexShrink: 0,
              }}
            >
              <MessageCircle size={18} style={{ color: '#3182CE' }} />
            </div>
            <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
              <CircularProgress size={16} sx={{ color: '#3182CE' }} />
              <span style={{ fontSize: '14px', color: '#6B7280' }}>Assistant is typing‚Ä¶</span>
            </div>
          </div>
        )}
        <div ref={scrollAnchorRef} />
      </div>

      {/* Input area */}
      <div
        style={{
          borderTop: '1px solid #e0e0e0',
          padding: '16px',
          background: '#fafafa',
        }}
      >
        <form
          onSubmit={(event) => {
            event.preventDefault();
            if (inputValue.trim()) {
              onSendMessage(inputValue.trim());
            }
          }}
          style={{ display: 'flex', gap: '8px' }}
        >
          <input
            ref={inputRef}
            value={inputValue}
            onChange={(event) => onInputChange(event.target.value)}
            placeholder="Type your reply‚Ä¶"
            style={{
              flex: 1,
              border: '1px solid #ddd',
              borderRadius: '8px',
              padding: '12px 16px',
              fontSize: '14px',
              outline: 'none',
            }}
            disabled={isLoading}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (inputValue.trim()) {
                  onSendMessage(inputValue.trim());
                }
              }
            }}
          />
          <button
            type="submit"
            disabled={isLoading || !inputValue.trim()}
            style={{
              background: '#1976d2',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              padding: '12px 20px',
              fontSize: '14px',
              cursor: inputValue.trim() && !isLoading ? 'pointer' : 'not-allowed',
              opacity: inputValue.trim() && !isLoading ? 1 : 0.6,
              display: 'flex',
              alignItems: 'center',
              gap: '4px',
            }}
          >
            <Send size={16} />
            Send
          </button>
        </form>
      </div>
    </div>
  );
};


interface SummaryPanelProps {
  summary: SummaryPayload;
  emergency: boolean;
  serviceDefinition: typeof SERVICE_DEFINITIONS[number] | null;
  attachments: File[];
  onAddAttachments: (files: File[]) => void;
  onRemoveAttachment: (index: number) => void;
  profile: any;
  profileAddress?: string;
  useProfileAddress: boolean;
  onUseProfileAddressChange: (value: boolean) => void;
  onAddressDataChange: (data: Partial<AddressPayload>) => void;
  isSubmitting: boolean;
  onSubmit: () => void;
}

const SummaryPanel: React.FC<SummaryPanelProps> = ({
  summary,
  emergency,
  serviceDefinition,
  attachments,
  onAddAttachments,
  onRemoveAttachment,
  profile,
  profileAddress,
  useProfileAddress,
  onUseProfileAddressChange,
  onAddressDataChange,
  isSubmitting,
  onSubmit,
}) => {
  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        gap: 2,
        overflowY: "auto",
        p: 3,
        pt: 2,
      }}
    >
      <Box sx={{ textAlign: "center", mb: 1 }}>
        <Typography variant="h6" sx={{ fontWeight: 600 }}>
          Please review your request
        </Typography>
        {emergency && (
          <Box
            sx={{
              mt: 1,
              display: "inline-flex",
              bgcolor: "error.main",
              color: "error.contrastText",
              px: 2,
              py: 0.75,
              borderRadius: 2,
              fontWeight: 600,
            }}
          >
            üö® Emergency Request
          </Box>
        )}
      </Box>

      <Paper variant="outlined" sx={{ p: 2 }}>
        <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
          Service Details
        </Typography>
        <Typography variant="body1" sx={{ fontWeight: 500 }}>
          {serviceDefinition?.title ?? summary.service?.label ?? "Plumbing Service"}
        </Typography>
      </Paper>

      <Paper variant="outlined" sx={{ p: 2 }}>
        <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
          Your Answers
        </Typography>
        <Box sx={{ display: "flex", flexDirection: "column", gap: 1.5 }}>
          {summary.answers.map((item, index) => (
            <Box
              key={`${item.question}-${index}`}
              sx={{
                bgcolor: "grey.50",
                borderRadius: 1,
                border: "1px solid",
                borderColor: "grey.200",
                p: 1.5,
              }}
            >
              <Typography
                variant="body2"
                sx={{ fontWeight: 600, color: "text.primary", mb: 0.5 }}
              >
                {item.question}
              </Typography>
              <Typography variant="body2" sx={{ color: "text.secondary" }}>
                {item.answer || "Not provided"}
              </Typography>
            </Box>
          ))}
        </Box>
      </Paper>

      <CustomerInfoSection
        mode="create"
        isAdmin={false}
        initialAddress={profileAddress}
        profileAddress={profileAddress}
        onModeChange={onUseProfileAddressChange}
        onDataChange={onAddressDataChange}
      />

      {profile && (
        <Paper variant="outlined" sx={{ p: 2 }}>
          <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
            Contact Information
          </Typography>
          <Box sx={{ display: "flex", flexDirection: "column", gap: 0.5 }}>
            <Typography variant="body2">
              <strong>Name:</strong> {profile.name || "‚Äî"}
            </Typography>
            <Typography variant="body2">
              <strong>Email:</strong> {profile.email || "‚Äî"}
            </Typography>
            <Typography variant="body2">
              <strong>Phone:</strong> {profile.phone || "‚Äî"}
            </Typography>
            <Typography variant="body2">
              <strong>Address:</strong>{" "}
              {profileAddress || "Add your address in your profile"}
            </Typography>
          </Box>
        </Paper>
      )}

      <Paper
        variant="outlined"
        sx={{ p: 2, bgcolor: "grey.50", borderStyle: "dashed" }}
      >
        <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
          Attachments (optional)
        </Typography>
        <Typography variant="body2" sx={{ mb: 2, color: "text.secondary" }}>
          Add photos or documents related to your plumbing issue.
        </Typography>
        <AttachmentSection
          requestId="new-request"
          attachments={[]}
          pendingFiles={attachments}
          editable
          onUpdate={() => {}}
          onNewFiles={onAddAttachments}
          onRemovePendingFile={onRemoveAttachment}
        />
      </Paper>

      <Button
        variant="contained"
        color="primary"
        size="large"
        disabled={isSubmitting}
        onClick={onSubmit}
        sx={{ mt: 1 }}
      >
        {isSubmitting ? "Submitting‚Ä¶" : "Confirm & Submit Request"}
      </Button>
    </Box>
  );
};

export default QuoteAgentModal;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/QuoteFormModal.tsx ---

// packages/frontend/src/features/requests/components/QuoteFormModal.tsx

import React, { useState, useEffect, useRef } from 'react';
import { Box, Typography, Paper, TextField, Button, Divider, InputAdornment, Chip, Grid, CircularProgress } from '@mui/material';
import { useAuth } from '../../auth/AuthContext';
import apiClient from '../../../lib/apiClient';
import { getQuoteStatusChipColor } from '../../../lib/statusColors';
import { QuoteRequest, QuoteAttachment } from '../types';
import { useCreateQuote, useUpdateQuote, useDeleteQuote } from '../../../hooks';

// Import all our reusable components
import ModalHeader from './ModalHeader';
import ModalFooter from './ModalFooter';
import CustomerInfoSection from './CustomerInfoSection';
import AttachmentSection from './AttachmentSection';

interface QuoteFormModalProps {
  isOpen: boolean;
  onClose: (updated?: boolean) => void;
  quote?: any;
  mode: 'create' | 'update' | 'change_order' | 'view';
  request: QuoteRequest;
  requestId: string;
}

interface Item {
  description: string;
  price: string;
}

const QuoteFormModal: React.FC<QuoteFormModalProps> = ({ isOpen, onClose, quote, mode, request, requestId }) => {
    const { profile } = useAuth();
    const firstFieldRef = useRef<HTMLInputElement>(null);
    const [goodUntil, setGoodUntil] = useState('');
    const [laborItems, setLaborItems] = useState<Item[]>([{ description: '', price: '' }]);
    const [materialItems, setMaterialItems] = useState<Item[]>([{ description: '', price: '' }]);
    const [notes, setNotes] = useState('');
    const [newAttachments, setNewAttachments] = useState<File[]>([]);

    const isAdmin = profile?.role === 'admin';
    const editable = mode !== 'view';

    const createQuoteMutation = useCreateQuote();
    const updateQuoteMutation = useUpdateQuote();
    const deleteQuoteMutation = useDeleteQuote();

  // Handle address updates
  const handleAddressUpdate = async (addressData: { service_address: string; latitude: number | null; longitude: number | null; geocoded_address: string | null }): Promise<void> => {
    try {
      await apiClient.patch(`/requests/${requestId}`, addressData);
      const event = new CustomEvent('show-snackbar', {
        detail: { message: 'Service address updated successfully!', severity: 'success' }
      });
      window.dispatchEvent(event);
    } catch (error) {
      console.error('Failed to update service address:', error);
      const event = new CustomEvent('show-snackbar', {
        detail: { message: 'Failed to update service address. Please try again.', severity: 'error' }
      });
      window.dispatchEvent(event);
      throw error;
    }
  };

  useEffect(() => {
    if (isOpen) {
      setNewAttachments([]);

      if (quote) {
        let detailsObj: any = {};
        try {
          detailsObj = typeof quote.details === 'string' ? JSON.parse(quote.details) : (quote.details || {});
        } catch (e) {
          console.error("Failed to parse quote details:", e);
          detailsObj = {};
        }
        setLaborItems(detailsObj.labor_items?.length > 0 ? detailsObj.labor_items : [{ description: '', price: '' }]);
        setMaterialItems(detailsObj.material_items?.length > 0 ? detailsObj.material_items : [{ description: '', price: '' }]);
        setNotes(detailsObj.notes || '');
        setGoodUntil(detailsObj.good_until || '');
      } else {
        setLaborItems([{ description: '', price: '' }]);
        setMaterialItems([{ description: '', price: '' }]);
        setNotes('');
        // Default "good until" to 1 month from today
        const oneMonthFromNow = new Date();
        oneMonthFromNow.setMonth(oneMonthFromNow.getMonth() + 1);
        setGoodUntil(oneMonthFromNow.toISOString().split('T')[0]);
      }

      // Auto-focus the first field when modal opens
      setTimeout(() => {
        if (firstFieldRef.current) {
          firstFieldRef.current.focus();
        }
      }, 100);
    }
  }, [quote, isOpen]);


  const handleSaveQuote = async () => {
    if (!laborItems.some(item => item.description && parseFloat(item.price) > 0) && !materialItems.some(item => item.description && parseFloat(item.price) > 0)) {
      // Show validation error
      const event = new CustomEvent('show-snackbar', {
        detail: { message: 'Please add at least one labor or material item with a price.', severity: 'error' }
      });
      window.dispatchEvent(event);
      return;
    }

    const laborTotal = laborItems.reduce((sum, item) => sum + (parseFloat(item.price) || 0), 0);
    const materialTotal = materialItems.reduce((sum, item) => sum + (parseFloat(item.price) || 0), 0);
    const subtotal = laborTotal + materialTotal;

    // BC Tax Rules:
    // GST (5%): Applied to ALL labor + materials
    // PST (7%): Applied to materials ONLY (labor is PST exempt in BC)
    const gst = subtotal * 0.05;
    const pst = materialTotal * 0.07; // PST only on materials
    const totalPrice = subtotal + gst + pst;

    const payload = {
      quote_amount: Number(totalPrice.toFixed(2)),
      details: JSON.stringify({
        labor_items: laborItems.filter(item => item.description),
        material_items: materialItems.filter(item => item.description),
        notes,
        good_until: goodUntil,
        tax_details: { gst: Number(gst.toFixed(2)), pst: Number(pst.toFixed(2)) },
      }),
    };

    if (mode === 'change_order') {
      // Create a new change order quote
      const changeOrderPayload = {
        ...payload,
        status: 'change_order',
        details: JSON.stringify({
          ...JSON.parse(payload.details),
          is_change_order: true,
          original_quote_id: quote.id,
          change_reason: 'Additional work requested'
        })
      };

      const { data: savedQuote } = await apiClient.post(`/requests/${requestId}/quotes`, changeOrderPayload);

      // Change orders don't change the main request status
      // They remain as separate quotes that need acceptance

      if (newAttachments.length > 0 && savedQuote?.id) {
        const formData = new FormData();
        formData.append('request_id', requestId);
        formData.append('quote_id', savedQuote.id);
        newAttachments.forEach(file => formData.append('attachment', file));
        await apiClient.post('/requests/attachments', formData, { headers: { 'Content-Type': 'multipart/form-data' } });
      }

      // Show success message
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Change order created successfully!', severity: 'success' }
      });
      window.dispatchEvent(event);

      // Close modal after successful save
      onClose(true);
    } else if (quote?.id && mode === 'update') {
      // Update existing quote
      await updateQuoteMutation.mutateAsync({ requestId, quoteId: quote.id, quote: payload });

      // Show success message
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Quote updated successfully!', severity: 'success' }
      });
      window.dispatchEvent(event);

      // Close modal after successful save
      onClose(true);
    } else if (mode === 'create') {
      // Create new quote
      const savedQuote = await createQuoteMutation.mutateAsync({ requestId, quote: payload });

      // If admin created a new quote, reset request status to "quoted" to restart the lifecycle
      if (isAdmin) {
        try {
          await apiClient.put(`/requests/${requestId}/status`, { status: 'quoted' });
        } catch (statusError) {
          console.error('Failed to update request status to quoted:', statusError);
          // Don't fail the quote creation if status update fails
        }
      }

      if (newAttachments.length > 0 && savedQuote?.id) {
        const formData = new FormData();
        formData.append('request_id', requestId);
        formData.append('quote_id', savedQuote.id);
        newAttachments.forEach(file => formData.append('attachment', file));
        await apiClient.post('/requests/attachments', formData, { headers: { 'Content-Type': 'multipart/form-data' } });
      }

      // Show success message
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Quote saved successfully!', severity: 'success' }
      });
      window.dispatchEvent(event);

      // Close modal after successful save
      onClose(true);
    }
  };

  if (!isOpen) return null;

  const laborTotal = laborItems.reduce((sum, item) => sum + (parseFloat(item.price) || 0), 0);
  const materialTotal = materialItems.reduce((sum, item) => sum + (parseFloat(item.price) || 0), 0);
  const subtotal = laborTotal + materialTotal;
  const gst = subtotal * 0.05;
  const pst = subtotal * 0.07;
  const totalPrice = subtotal + gst + pst;

  const quoteAttachments = request?.quote_attachments?.filter((att: QuoteAttachment) => att.quote_id === quote?.id) || [];
  const headerTitle = mode === 'change_order'
    ? `Create Change Order for ${request?.problem_category?.replace(/_/g, ' ')}`
    : quote?.id
    ? `Update Quote #${quote.quote_number}`
    : `Create New Quote for ${request?.problem_category?.replace(/_/g, ' ')}`;

  return (
    <div style={{ position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: 'rgba(0,0,0,0.6)', zIndex: 1200, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '8px' }}>
      <Paper elevation={24} sx={{
        width: '100%',
        maxWidth: '700px',
        p: 0,
        position: 'relative',
        display: 'flex',
        flexDirection: 'column',
        bgcolor: '#f4f6f8',
        height: { xs: 'calc(100vh - 16px)', md: 'auto' },
        maxHeight: { xs: 'calc(100vh - 16px)', md: '90vh' },
        overflow: 'hidden'
      }}>

        <ModalHeader title={headerTitle} onClose={() => onClose()} />

        <Box sx={{ flex: '1 1 auto', overflowY: 'auto', p: 3 }}>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>

            <CustomerInfoSection
              mode="view"
              initialAddress={request.service_address}
              isAdmin={isAdmin}
              onSave={handleAddressUpdate}
              onModeChange={() => {}}
              isUpdating={false}
              request={request}
              showCustomerInfo={true}
            />

            <Paper variant="outlined" sx={{p: 2, bgcolor: 'grey.50'}}>
              <Typography variant="subtitle1" sx={{ fontWeight: 'bold', mb: 1 }}>Itemized Labor</Typography>
              {laborItems.map((item, idx) => (
                <Grid container spacing={1} key={`labor-${idx}`} sx={{ mb: 1 }}>
                  <Grid item xs={8}>
                    {idx === 0 ? (
                      <TextField inputRef={firstFieldRef} label="Description" value={item.description} onChange={e => { const newItems = [...laborItems]; newItems[idx].description = e.target.value; setLaborItems(newItems); }} fullWidth disabled={!editable} size="small" />
                    ) : (
                      <TextField label="Description" value={item.description} onChange={e => { const newItems = [...laborItems]; newItems[idx].description = e.target.value; setLaborItems(newItems); }} fullWidth disabled={!editable} size="small" />
                    )}
                  </Grid>
                  <Grid item xs={4}><TextField label="Price" value={item.price} onChange={e => { const newItems = [...laborItems]; newItems[idx].price = e.target.value; setLaborItems(newItems); }} fullWidth disabled={!editable} size="small" type="number" InputProps={{ startAdornment: <InputAdornment position="start">$</InputAdornment> }} /></Grid>
                </Grid>
              ))}
              {editable && <Button onClick={() => setLaborItems([...laborItems, { description: '', price: '' }])} sx={{ mb: 2, mt: 1 }}>Add Labor Item</Button>}
            </Paper>

            <Paper variant="outlined" sx={{p: 2, bgcolor: 'grey.50'}}>
              <Typography variant="subtitle1" sx={{ fontWeight: 'bold', mb: 1 }}>Itemized Materials</Typography>
              {materialItems.map((item, idx) => (
                <Grid container spacing={1} key={`material-${idx}`} sx={{ mb: 1 }}>
                  <Grid item xs={8}><TextField label="Description" value={item.description} onChange={e => { const newItems = [...materialItems]; newItems[idx].description = e.target.value; setMaterialItems(newItems); }} fullWidth disabled={!editable} size="small" /></Grid>
                  <Grid item xs={4}><TextField label="Price" value={item.price} onChange={e => { const newItems = [...materialItems]; newItems[idx].price = e.target.value; setMaterialItems(newItems); }} fullWidth disabled={!editable} size="small" type="number" InputProps={{ startAdornment: <InputAdornment position="start">$</InputAdornment> }} /></Grid>
                </Grid>
              ))}
              {editable && <Button onClick={() => setMaterialItems([...materialItems, { description: '', price: '' }])} sx={{ mb: 2, mt: 1 }}>Add Material Item</Button>}
            </Paper>

            <Paper variant="outlined" sx={{p: 2, bgcolor: 'grey.50'}}>
              <TextField label="Notes / Clarifications" value={notes} onChange={e => setNotes(e.target.value)} fullWidth multiline rows={3} disabled={!editable} />
            </Paper>

            <AttachmentSection
              requestId={requestId}
              quoteId={quote?.id}
              attachments={quoteAttachments}
              pendingFiles={newAttachments}
              editable={editable}
              onUpdate={() => onClose(true)}
              onNewFiles={(files) => setNewAttachments(prev => [...prev, ...files])}
              onRemovePendingFile={(index) => setNewAttachments(prev => prev.filter((_, i) => i !== index))}
            />

            {/* Good Until Date - moved to bottom */}
            <Paper variant="outlined" sx={{ p: 2 }}>
              <TextField
                fullWidth
                label="Good Until"
                type="date"
                value={goodUntil}
                onChange={(e) => setGoodUntil(e.target.value)}
                disabled={!editable}
                InputLabelProps={{ shrink: true }}
                helperText="Quote expiration date"
              />
            </Paper>

            {/* Summary Bar - Always visible pricing breakdown */}
            <Box sx={{
              p: 2,
              bgcolor: 'grey.50',
              borderRadius: 1,
              border: 1,
              borderColor: 'grey.200',
              mt: 2
            }}>
              <Box sx={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                flexWrap: 'wrap',
                gap: 2
              }}>
                <Box sx={{ display: 'flex', gap: 3, flexWrap: 'wrap' }}>
                  <Typography variant="body2" color="text.secondary">
                    Labor: ${laborTotal.toFixed(2)}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Materials: ${materialTotal.toFixed(2)}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    GST (5%): ${gst.toFixed(2)}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    PST (7% on materials): ${pst.toFixed(2)}
                  </Typography>
                </Box>
                <Typography variant="h5" sx={{ fontWeight: 'bold', color: 'primary.main' }}>
                  Total: ${totalPrice.toFixed(2)}
                </Typography>
              </Box>
            </Box>
          </Box>
        </Box>

        <ModalFooter>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              {quote?.status && <Chip label={`Status: ${quote.status}`} color={getQuoteStatusChipColor(quote.status)} sx={{ textTransform: 'capitalize' }} />}
              {isAdmin && quote?.id && quote?.status !== 'accepted' && (
                <Button
                  variant="outlined"
                  color="error"
                  onClick={() => {
                    if (window.confirm('Are you sure you want to delete this quote? This action cannot be undone.')) {
                      deleteQuoteMutation.mutate({ requestId, quoteId: quote.id });
                    }
                  }}
                  disabled={deleteQuoteMutation.isPending}
                >
                  {deleteQuoteMutation.isPending ? 'Deleting...' : 'Delete Quote'}
                </Button>
              )}
            </Box>
            {editable && (
              <Box>
                <Button
                  variant="contained"
                  color="primary"
                  onClick={handleSaveQuote}
                  disabled={createQuoteMutation.isPending || updateQuoteMutation.isPending}
                  startIcon={(createQuoteMutation.isPending || updateQuoteMutation.isPending) ? <CircularProgress size={16} color="inherit" /> : null}
                >
                  {(createQuoteMutation.isPending || updateQuoteMutation.isPending) ? 'Saving...' : (quote?.id ? 'Update Quote' : 'Save Quote')}
                </Button>
              </Box>
            )}
          </ModalFooter>
      </Paper>
    </div>
  );
};

export default QuoteFormModal;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/QuoteList.tsx ---

// packages/frontend/src/features/requests/components/QuoteList.tsx

import React, { useState, useCallback } from 'react';
import { useAuth } from '../../auth/AuthContext';
import { Box, Typography, Paper, Button, List, ListItem, ListItemText, Chip } from '@mui/material';
import { FilePlus } from 'lucide-react';
import { QuoteRequest } from '../types';
import QuoteFormModal from './QuoteFormModal';
import { getQuoteStatusChipColor } from '../../../lib/statusColors';
import { logger } from '../../../lib/logger';

interface QuoteListProps {
  request: QuoteRequest;
  isReadOnly: boolean;
  isUpdating: boolean;
  onAcceptQuote: (quoteId: string) => void;
  onUpdateRequest: () => void;
}

const QuoteList: React.FC<QuoteListProps> = ({ request, isReadOnly, isUpdating, onAcceptQuote, onUpdateRequest }) => {
  const { profile } = useAuth();
  const [showQuoteForm, setShowQuoteForm] = useState(false);
  const [quoteModalMode, setQuoteModalMode] = useState<'create' | 'update' | 'change_order' | 'view'>('create');
  const [selectedQuote, setSelectedQuote] = useState<any | null>(null);

  const isAdmin = profile?.role === 'admin';

  const handleOpenQuoteForm = (mode: 'create' | 'update' | 'change_order' | 'view', quote?: any) => {
    setQuoteModalMode(mode);
    setSelectedQuote(quote || null);
    setShowQuoteForm(true);
  };

  const handleQuoteFormClose = useCallback((updated?: boolean) => {
    setShowQuoteForm(false);
    setSelectedQuote(null);
    if (updated) {
      onUpdateRequest();
    }
  }, [onUpdateRequest]);

  return (
    <>
      <Paper variant="outlined" sx={{ p: 2 }}>
        <Typography variant="overline" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <FilePlus size={16} /> Quotes
        </Typography>

        {request.quotes.length === 0 ? (
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', py: 6, gap: 2 }}>
            <FilePlus size={38} />
            <Typography variant="h6">No quotes have been added yet</Typography>
            <Typography variant="body2" color="text.secondary">Once a contractor adds a quote it'll appear here.</Typography>
            {isAdmin ? (
              <Button variant="contained" startIcon={<FilePlus />} sx={{ mt: 1 }} onClick={() => handleOpenQuoteForm('create')}>
                + Add First Quote
              </Button>
            ) : null}
          </Box>
        ) : (
          <List>
            {request.quotes.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()).map((quote) => (
              <ListItem key={quote.id} disablePadding secondaryAction={
                <Box sx={{ display: 'flex', gap: 1 }}>
                  {!isAdmin && quote.status !== 'accepted' && quote.status !== 'rejected' && request.status !== 'accepted' && (
                    <Button variant="contained" size="small" color="success" onClick={() => { logger.log('Accepting quote:', quote.id); onAcceptQuote(quote.id); }} disabled={isUpdating}>
                      Accept
                    </Button>
                  )}
                  {isAdmin && !isReadOnly && quote.status !== 'accepted' && (
                    <Button variant="outlined" size="small" onClick={() => handleOpenQuoteForm('update', quote)}>
                      Update
                    </Button>
                  )}
                  {isAdmin && !isReadOnly && quote.status === 'accepted' && (
                    <Button variant="outlined" size="small" color="warning" onClick={() => handleOpenQuoteForm('change_order', quote)}>
                      Change Order
                    </Button>
                  )}
                  {!isAdmin && (quote.status === 'accepted' || quote.status === 'rejected') && (
                    <Button variant="outlined" size="small" onClick={() => handleOpenQuoteForm('view', quote)}>
                      View Details
                    </Button>
                  )}
                </Box>
              }>
                <ListItemText
                  primaryTypographyProps={{ component: 'div' }}
                  secondaryTypographyProps={{ component: 'div' }}
                  primary={`${quote.status === 'change_order' ? 'Change Order' : 'Quote'} #${quote.quote_number} - $${quote.quote_amount.toFixed(2)}`}
                  secondary={
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mt: 0.5 }}>
                      <Chip
                        label={quote.status === 'change_order' ? 'Change Order' : (quote.status || 'N/A')}
                        color={getQuoteStatusChipColor(quote.status)}
                        size="small"
                        sx={{ textTransform: 'capitalize' }}
                      />
                      <Box component="span" sx={{ fontSize: '0.75rem', color: 'text.secondary' }}>
                        | Created: {new Date(quote.created_at).toLocaleDateString()}
                      </Box>
                    </Box>
                  }
                />
              </ListItem>
            ))}
          </List>
        )}

        {isAdmin && !isReadOnly && (
          <Button variant="contained" startIcon={<FilePlus />} sx={{ mt: 2 }} onClick={() => handleOpenQuoteForm('create')}>
            Add New Quote
          </Button>
        )}
      </Paper>

      <QuoteFormModal
        isOpen={showQuoteForm}
        onClose={handleQuoteFormClose}
        quote={selectedQuote}
        mode={quoteModalMode}
        request={request}
        requestId={request.id}
      />
    </>
  );
};

export default QuoteList;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/RequestActions.tsx ---

// packages/frontend/src/features/requests/components/RequestActions.tsx

import React from 'react';
import { Box, Typography, Select, MenuItem, FormControl, InputLabel, Button, Chip } from '@mui/material';
import { Phone, CheckCircle } from 'lucide-react';
import { QuoteRequest } from '../types';
import { getRequestStatusChipColor, getRequestStatusPinColor } from '../../../lib/statusColors';

interface RequestActionsProps {
  request: QuoteRequest;
  isAdmin: boolean;
  currentStatus: string;
  isUpdating: boolean;
  onStatusChange: (newStatus: string) => void;
  scheduledDateChanged?: boolean;
  onSaveAndSchedule?: () => void;
  onMarkCompleted?: () => void;
}

const RequestActions: React.FC<RequestActionsProps> = ({
  request,
  isAdmin,
  currentStatus,
  isUpdating,
  onStatusChange,
  scheduledDateChanged = false,
  onSaveAndSchedule,
  onMarkCompleted
}) => {
  return (
    <>
      <Typography component="div" variant="body2" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        Status: <Chip label={currentStatus} color={getRequestStatusChipColor(currentStatus)} size="small" sx={{ textTransform: 'capitalize', fontWeight: 'bold' }} />
      </Typography>

      {isAdmin && (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          {currentStatus === 'scheduled' ? (
            // STATE 1: Scheduled job - show "Start Job" button to mark as in_progress
            <Button
              variant="contained"
              color="primary"
              onClick={() => onStatusChange('in_progress')}
              disabled={isUpdating}
              startIcon={<CheckCircle size={16} />}
            >
              Start Job
            </Button>
          ) : currentStatus === 'in_progress' ? (
            // STATE 2: In progress job - show "Mark as Completed" button
            <Button
              variant="contained"
              color="success"
              onClick={onMarkCompleted}
              disabled={isUpdating}
              startIcon={<CheckCircle size={16} />}
            >
              Mark as Completed
            </Button>
          ) : scheduledDateChanged ? (
            // STATE 3: Date has been changed, show the primary action button
            <Button
              variant="contained"
              color="success"
              onClick={onSaveAndSchedule}
              disabled={isUpdating}
            >
              Save & Schedule
            </Button>
          ) : (
            // STATE 4: Default view with status dropdown (for new, viewed, quoted, accepted, etc.)
            <FormControl size="small" sx={{ minWidth: 150 }}>
              <InputLabel>Update Status</InputLabel>
              <Select
                value={currentStatus}
                label="Update Status"
                onChange={(e) => onStatusChange(e.target.value as string)}
                disabled={isUpdating || request.status === 'completed'}
              >
                <MenuItem value="new">New</MenuItem>
                <MenuItem value="viewed">Viewed</MenuItem>
                <MenuItem value="quoted">Quoted</MenuItem>
                <MenuItem value="accepted">Accepted</MenuItem>
                <MenuItem value="scheduled">Scheduled</MenuItem>
                <MenuItem value="in_progress">In Progress</MenuItem>
                <MenuItem value="completed">Completed</MenuItem>
              </Select>
            </FormControl>
          )}
          <Button
            variant="outlined"
            component="a"
            href={`tel:${request.user_profiles?.phone}`}
            disabled={!request.user_profiles?.phone}
            startIcon={<Phone />}
          >
            Call Customer
          </Button>
        </Box>
      )}
    </>
  );
};

export default RequestActions;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/RequestDetailModal.tsx ---

// packages/frontend/src/features/requests/components/RequestDetailModal.tsx

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../../auth/AuthContext';
import { Box, Paper, Button, Snackbar, Alert, Grid, Typography, CircularProgress } from '@mui/material';
import { Zap, RefreshCw } from 'lucide-react';
import { QuoteRequest } from '../types';
import AttachmentSection from './AttachmentSection';
import apiClient from '../../../lib/apiClient';
import CommunicationLog from './CommunicationLog';
import QuoteList from './QuoteList';
import RequestProblemDetails from './RequestProblemDetails';
import AITriageSummary from './AITriageSummary';
import ModalHeader from './ModalHeader';
import ModalFooter from './ModalFooter';
import RequestActions from './RequestActions';
import CompleteJobModal from './CompleteJobModal';
import InvoiceFormModal from './InvoiceFormModal';
import CustomerInfoSection from './CustomerInfoSection';
import ScheduleJobSection from './ScheduleJobSection';
import { useUpdateRequestStatus, useAcceptQuote, useTriageRequest, useUpdateAddressMutation, useMarkRequestAsViewed, useInvoiceById } from '../../../hooks';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useRequestById } from '../../../hooks';
import statusColors from '../../../lib/statusColors.json';

interface RequestDetailModalProps {
  isOpen: boolean;
  onClose: () => void;
  request: QuoteRequest | null;
  onUpdateRequest: () => void;
}

const RequestDetailModal: React.FC<RequestDetailModalProps> = ({ isOpen, onClose, request: initialRequest, onUpdateRequest }) => {
  const { profile } = useAuth();

  const requestId = initialRequest?.id;
  const { data: requestArray, loading, error, refetch } = useRequestById(requestId || '', {
    enabled: !!requestId && isOpen
  });
  const request = requestArray?.[0] || initialRequest;

  const refreshRequestData = () => {
    refetch();
  };

  useEffect(() => {
    if (!isOpen || !requestId) return;
    const interval = setInterval(() => refetch(), 30000);
    return () => clearInterval(interval);
  }, [isOpen, requestId, refetch]);

  useEffect(() => {
    if (!isOpen || !requestId) return;
    const handleFocus = () => refetch();
    window.addEventListener('focus', handleFocus);
    return () => window.removeEventListener('focus', handleFocus);
  }, [isOpen, requestId, refetch]);

  const updateStatusMutation = useUpdateRequestStatus();
  const acceptQuoteMutation = useAcceptQuote();
  const triageMutation = useTriageRequest();
  const updateAddressMutation = useUpdateAddressMutation();
  const markAsViewedMutation = useMarkRequestAsViewed();
  const queryClient = useQueryClient();

  const completeJobMutation = useMutation({
    mutationFn: async ({ requestId, data }: { requestId: string; data: { actual_cost: number; completion_notes: string } }) => {
      const response = await apiClient.patch(`/requests/${requestId}/complete`, data);
      return response.data;
    },
  });

  // Load invoice data using the same pattern as request data
  const invoiceId = (request as any)?.invoice_id;
  const { data: invoiceArray } = useInvoiceById(invoiceId || '', {
    enabled: !!invoiceId && isOpen
  });
  const invoiceData = invoiceArray?.[0];

  const [scheduledStartDate, setScheduledStartDate] = useState('');
  const [scheduledDateChanged, setScheduledDateChanged] = useState(false);
  const [isCompleteModalOpen, setCompleteModalOpen] = useState(false);
  const [isInvoiceModalOpen, setInvoiceModalOpen] = useState(false);
  const [invoiceMode, setInvoiceMode] = useState<'create' | 'edit' | 'view'>('create');
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState<'success' | 'error' | 'info'>('success');
  const viewedMarker = useRef<string | null>(null);

  useEffect(() => {
    if (request) {
      setScheduledStartDate(request.scheduled_start_date ? new Date(request.scheduled_start_date).toISOString().split('T')[0] : '');
      setScheduledDateChanged(false);
    }
  }, [request?.scheduled_start_date]);

  useEffect(() => {
    const handleSnackbarEvent = (event: CustomEvent) => {
      setSnackbarMessage(event.detail.message);
      setSnackbarSeverity(event.detail.severity);
      setSnackbarOpen(true);
    };
    window.addEventListener('show-snackbar', handleSnackbarEvent as EventListener);
    return () => window.removeEventListener('show-snackbar', handleSnackbarEvent as EventListener);
  }, []);

  const handleStatusUpdate = async (newStatus: string, date?: string | null) => {
    if (!request) return;
    await updateStatusMutation.mutateAsync({ requestId: request.id, status: newStatus, scheduledStartDate: date ?? null });
  };

  const handleAcceptQuote = (quoteId: string) => {
    if (!request) return;
    acceptQuoteMutation.mutate({ requestId: request.id, quoteId });
  };

  const handleTriageRequest = async () => {
    if (!request) return;

    // Show notification that triage is starting and will take time
    setSnackbarMessage('AI triage analysis in progress... This may take up to 60 seconds. Please don\'t refresh the page.');
    setSnackbarSeverity('info');
    setSnackbarOpen(true);

    triageMutation.mutate({ requestId: request.id }, {
      onSuccess: () => {
        refreshRequestData();
        setSnackbarMessage('AI triage analysis completed successfully!');
        setSnackbarSeverity('success');
        setSnackbarOpen(true);
      },
      onError: (error) => {
        setSnackbarMessage('AI triage analysis failed. Please try again.');
        setSnackbarSeverity('error');
        setSnackbarOpen(true);
      }
    });
  };

  const handleSaveScheduledDate = async () => {
    if (!request || !scheduledStartDate) return;
    const utcDate = new Date(scheduledStartDate);
    await handleStatusUpdate('scheduled', utcDate.toISOString());
  };

  const handleDateChange = useCallback((date: string) => {
    setScheduledStartDate(date);
    setScheduledDateChanged(true);
  }, []);

  const handleCreateInvoice = () => {
    setInvoiceMode('create');
    setInvoiceModalOpen(true);
  };

  const handleEditInvoice = () => {
    if (!invoiceData) {
      setSnackbarMessage('Invoice data not available. Please try again.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
      return;
    }
    setInvoiceMode('edit');
    setInvoiceModalOpen(true);
  };

  const handleViewInvoice = () => {
    if (!invoiceData) {
      setSnackbarMessage('Invoice data not available. Please try again.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
      return;
    }
    setInvoiceMode('view');
    setInvoiceModalOpen(true);
  };

  const handleInvoiceModalClose = (updated?: boolean) => {
    setInvoiceModalOpen(false);
    if (updated) {
      refreshRequestData();
      onUpdateRequest();
    }
  };

  const handleSaveAndSchedule = useCallback(async () => {
    if (!request || !scheduledStartDate) return;
    const utcDate = new Date(scheduledStartDate);
    try {
      await handleStatusUpdate('scheduled', utcDate.toISOString());
      setScheduledDateChanged(false);
      setTimeout(() => onClose(), 1500);
    } catch (error) {
      // Error handled by mutation hook
    }
  }, [request, scheduledStartDate, handleStatusUpdate, onClose]);

  const handleOpenCompleteModal = useCallback(() => setCompleteModalOpen(true), []);

  const handleConfirmCompletion = useCallback(async (data: { actual_cost: number; completion_notes: string }) => {
    if (!request) return;
    try {
      await updateStatusMutation.mutateAsync({ requestId: request.id, status: 'completed' });
      setSnackbarMessage('‚úÖ Job successfully marked as completed!');
      setSnackbarSeverity('success');
      setSnackbarOpen(true);
      onClose();
      onUpdateRequest();
    } catch (error) {
      setSnackbarMessage('‚ùå Failed to complete job. Please try again.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
    }
  }, [request, updateStatusMutation, onClose, onUpdateRequest]);

  const handleAddressUpdate = useCallback(async (addressData: { service_address: string; latitude: number | null; longitude: number | null; geocoded_address: string | null }): Promise<void> => {
    if (!request) return;
    try {
      await apiClient.patch(`/requests/${request.id}`, addressData);
      queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      setSnackbarMessage('Service address updated successfully!');
      setSnackbarSeverity('success');
      setSnackbarOpen(true);
    } catch (error) {
      console.error('Failed to update service address:', error);
      setSnackbarMessage('Failed to update service address. Please try again.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
      throw error;
    }
  }, [request, queryClient]);

  useEffect(() => {
    // --- THE FIX: Use a ref to prevent re-firing the mutation ---
    if (isOpen && request && profile?.role !== 'admin' && request.status === 'quoted' && viewedMarker.current !== request.id) {
      viewedMarker.current = request.id; // Mark as viewed for this session
      markAsViewedMutation.mutate(request.id);
    }
    // Reset when modal closes
    if (!isOpen) {
      viewedMarker.current = null;
    }
  }, [isOpen, request, profile, markAsViewedMutation]);

  if (!isOpen || !request) return null;

  const isAdmin = profile?.role === 'admin';
  const isReadOnly = ['completed'].includes(request.status);
  const hasAcceptedQuotes = request.quotes?.some(q => q.status === 'accepted') || false;
  const isEditable = !isReadOnly && (isAdmin || !hasAcceptedQuotes);
  const canEditAttachments = !isReadOnly;
  // Allow admin or request owner to edit address
  const isRequestOwner = profile?.user_id === (request as any).user_id;
  const canEditAddress = isAdmin || isRequestOwner;


  const headerTitle = `Job Docket: ${request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
  const headerSubtitle = `ID: ${request.id} | Received: ${new Date(request.created_at).toLocaleString()}`;

  const headerActions = (
    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
      {loading && <RefreshCw size={14} className="animate-spin" />}

      {/* Invoice Button Logic */}
      {isAdmin && request.status === 'completed' && !request.invoice_id && (
        <Button
          variant="contained"
          color="primary"
          size="small"
          onClick={handleCreateInvoice}
        >
          Create Invoice
        </Button>
      )}

      {isAdmin && request.status === 'invoiced' && request.invoice_id && (
        <Button
          variant="contained"
          color="primary"
          size="small"
          onClick={handleEditInvoice}
        >
          Edit Invoice
        </Button>
      )}

      {(['invoiced', 'paid', 'overdue', 'disputed'].includes(request.status) && request.invoice_id) && (
        <Button
          variant="outlined"
          color="primary"
          size="small"
          onClick={handleViewInvoice}
        >
          View Invoice
        </Button>
      )}

      {isAdmin && !request.triage_summary && (
        <Button variant="contained" color="secondary" size="small" onClick={handleTriageRequest} disabled={triageMutation.isPending} startIcon={<Zap />}>
          {triageMutation.isPending ? 'Triaging...' : 'AI Triage'}
        </Button>
      )}
    </Box>
  );

  return (
    <div style={{ position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: 'rgba(0,0,0,0.6)', zIndex: 1100, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      <Paper elevation={24} sx={{ width: '95%', maxWidth: '800px', height: '90vh', p: 0, position: 'relative', display: 'flex', flexDirection: 'column', bgcolor: '#f4f6f8', overflow: 'hidden' }}>

        <ModalHeader
          title={headerTitle}
          subtitle={headerSubtitle}
          onClose={onClose}
          actions={headerActions}
          statusColor={statusColors[request.status as keyof typeof statusColors] || statusColors.default}
        />

        <Box sx={{ flexGrow: 1, overflowY: 'auto', p: { xs: 2, md: 3 } }}>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
            <CustomerInfoSection
              mode="view"
              showCustomerInfo={true}
              request={request}
              initialAddress={request.service_address}
              isAdmin={isAdmin}
              canEdit={canEditAddress}
              onSave={handleAddressUpdate}
              onModeChange={() => {}}
              isUpdating={updateAddressMutation.isPending}
            />

            <Grid container spacing={3}>
              <Grid item xs={12} sm={6}>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                  <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>Status</Typography>
                  <Typography variant="body1" sx={{ textTransform: 'capitalize' }}>{request.status}</Typography>
                </Box>
              </Grid>
              <Grid item xs={12} sm={6}>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                  <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>Service Type</Typography>
                  <Typography variant="body1">{request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</Typography>
                </Box>
              </Grid>
            </Grid>
            {isAdmin && <AITriageSummary request={request} />}
            <RequestProblemDetails request={request} />
            <AttachmentSection requestId={request.id} attachments={request.quote_attachments || []} editable={canEditAttachments} onUpdate={refreshRequestData} />
            <CommunicationLog requestId={request.id} onNoteAdded={refreshRequestData} />
            <QuoteList
              request={request}
              isReadOnly={isReadOnly}
              isUpdating={acceptQuoteMutation.isPending}
              onAcceptQuote={handleAcceptQuote}
              onUpdateRequest={refreshRequestData}
            />
            {isAdmin && request.status === 'accepted' && !request.scheduled_start_date && (
              <ScheduleJobSection scheduledDate={scheduledStartDate} onDateChange={setScheduledStartDate} onSaveSchedule={handleSaveAndSchedule} isUpdating={updateStatusMutation.isPending} dateChanged={scheduledDateChanged} />
            )}
          </Box>
        </Box>

        <ModalFooter>
          <RequestActions
            request={request}
            isAdmin={isAdmin}
            currentStatus={request.status}
            isUpdating={updateStatusMutation.isPending}
            onStatusChange={(newStatus) => handleStatusUpdate(newStatus)}
            scheduledDateChanged={scheduledDateChanged}
            onSaveAndSchedule={handleSaveAndSchedule}
            onMarkCompleted={handleOpenCompleteModal}
          />
        </ModalFooter>
      </Paper>

      <CompleteJobModal isOpen={isCompleteModalOpen} onClose={() => setCompleteModalOpen(false)} onConfirm={handleConfirmCompletion} isSubmitting={completeJobMutation.isPending} jobTitle={request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} />

      <InvoiceFormModal
        isOpen={isInvoiceModalOpen}
        onClose={handleInvoiceModalClose}
        invoice={invoiceData}
        mode={invoiceMode}
        request={request}
        requestId={request.id}
      />

      <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={() => setSnackbarOpen(false)} anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}>
        <Alert onClose={() => setSnackbarOpen(false)} severity={snackbarSeverity} sx={{ width: '100%' }}>{snackbarMessage}</Alert>
      </Snackbar>
      <style>{`.animate-spin { animation: spin 1s linear infinite; } @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }`}</style>
    </div>
  );
};

export default RequestDetailModal;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/RequestProblemDetails.tsx ---

// packages/frontend/src/features/requests/components/RequestProblemDetails.tsx

import React from 'react';
import { Box, Typography, Paper, Divider, Grid } from '@mui/material';
import { AlertTriangle } from 'lucide-react';
import { QuoteRequest } from '../types';

// This sub-component now lives inside the component that uses it.
const AnswerItem: React.FC<{ question: string; answer: string }> = ({ question, answer }) => (
  <Grid container spacing={1} sx={{ mb: 1 }}>
    <Grid item xs={12} sm={5}>
      <Typography variant="body2" sx={{ fontWeight: 'bold', color: 'text.secondary' }}>{question}</Typography>
    </Grid>
    <Grid item xs={12} sm={7}>
      <Typography variant="body1">{answer || 'N/A'}</Typography>
    </Grid>
  </Grid>
);

interface RequestProblemDetailsProps {
  request: QuoteRequest;
}

const RequestProblemDetails: React.FC<RequestProblemDetailsProps> = ({ request }) => {
  // Logic to separate the main description from other Q&A
  // Look for various description questions (most workflows have one)
  const answers = request.answers || [];

  const problemDescriptionAnswer = answers.find((a: { question: string; answer: string }) => {
    const q = a.question.toLowerCase();
    return q.includes('describe') || q.includes('detail') || q.includes('issue') || q.includes('problem');
  });

  const otherAnswers = answers.filter((a: { question: string; answer: string }) =>
    a !== problemDescriptionAnswer
  );

  return (
    <Paper variant="outlined">
      <Box sx={{ p: 2, borderLeft: 4, borderColor: 'orange.400', bgcolor: 'orange.50' }}>
        <Typography variant="overline" color="text.secondary" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <AlertTriangle size={16} /> Reported Problem
        </Typography>
        <Typography variant="body1" sx={{ fontStyle: 'italic', mt: 1 }}>
          "{problemDescriptionAnswer?.answer || 'N/A'}"
        </Typography>
      </Box>
      <Divider />
      <Box sx={{ p: 2 }}>
        <Grid container spacing={2}>
          {otherAnswers.map((ans: { question: string; answer: string }) => (
            <AnswerItem key={ans.question} question={ans.question} answer={ans.answer} />
          ))}
        </Grid>
      </Box>
    </Paper>
  );
};

export default RequestProblemDetails;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/components/ScheduleJobSection.tsx ---

// packages/frontend/src/features/requests/components/ScheduleJobSection.tsx

import React from 'react';
import { Box, Typography, TextField, Button, Paper, Alert } from '@mui/material';
import { Calendar, Save } from 'lucide-react';

interface ScheduleJobSectionProps {
  scheduledDate: string;
  onDateChange: (date: string) => void;
  onSaveSchedule: () => void;
  isUpdating: boolean;
  dateChanged: boolean;
}

const ScheduleJobSection: React.FC<ScheduleJobSectionProps> = ({
  scheduledDate,
  onDateChange,
  onSaveSchedule,
  isUpdating,
  dateChanged
}) => {
  return (
    <Paper sx={{ p: 3, borderRadius: 2, border: '1px solid', borderColor: 'divider', bgcolor: 'grey.50' }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
        <Calendar size={20} />
        <Typography variant="h6" sx={{ fontWeight: 600, color: 'primary.main' }}>
          Schedule Job
        </Typography>
      </Box>

      <Typography variant="body2" sx={{ mb: 3, color: 'text.secondary' }}>
        Set the date when this job should be scheduled. The customer will be notified of the scheduled date.
      </Typography>

      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
        <TextField
          label="Scheduled Date"
          type="date"
          value={scheduledDate}
          onChange={(e) => onDateChange(e.target.value)}
          fullWidth
          size="small"
          InputLabelProps={{
            shrink: true,
          }}
          disabled={isUpdating}
        />

        {scheduledDate && (
          <Alert severity="info" sx={{ mb: 1 }}>
            Ready to schedule job for {new Date(scheduledDate).toLocaleDateString()}. Click "Schedule Job" to confirm.
          </Alert>
        )}

        <Box sx={{ display: 'flex', justifyContent: 'flex-end', gap: 1 }}>
          <Button
            variant="contained"
            color="primary"
            onClick={onSaveSchedule}
            disabled={isUpdating || !scheduledDate}
            startIcon={<Save size={16} />}
            sx={{ minWidth: 140 }}
          >
            {isUpdating ? 'Scheduling...' : 'Schedule Job'}
          </Button>
        </Box>
      </Box>
    </Paper>
  );
};

export default ScheduleJobSection;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/pages/RequestView.tsx ---

import React from 'react';
import { Box, Typography, CircularProgress, Grid, Paper } from '@mui/material';
import { useRequestById } from '../../../hooks';
import { useAuth } from '../../auth/AuthContext';
import CustomerInfoSection from '../components/CustomerInfoSection';
import RequestProblemDetails from '../components/RequestProblemDetails';
import QuoteList from '../components/QuoteList';
import ModalHeader from '../components/ModalHeader';
import RequestActions from '../components/RequestActions';
import { logger } from '../../../lib/logger';

interface RequestViewProps {
  requestId: string;
}

const RequestView: React.FC<RequestViewProps> = ({ requestId }) => {
  const { data: requestArray, loading, error } = useRequestById(requestId, { enabled: !!requestId });
  const request = Array.isArray(requestArray) ? requestArray[0] : requestArray;
  const { profile } = useAuth();
  const isAdmin = profile?.role === 'admin';

  if (!requestId) {
    return <Typography color="error">Request id is missing from the URL.</Typography>;
  }

  if (loading) {
    return (
      <Box className="p-8 text-center">
        <CircularProgress />
        <Typography mt={2}>Loading request...</Typography>
      </Box>
    );
  }

  if (error) {
    return <Typography color="error">Failed to load request: {String(error)}</Typography>;
  }

  if (!request) {
    return <Typography>No request found with id {requestId}</Typography>;
  }

  return (
    <Box sx={{ px: 2, py: 4 }}>
      <Paper sx={{ maxWidth: 1024, mx: 'auto', bgcolor: '#f9fafb', borderRadius: 2, boxShadow: 3, overflow: 'hidden' }}>
        <ModalHeader
          title={`Job Docket: ${request.problem_category ? request.problem_category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Request'}`}
          subtitle={`ID: ${request.id}`}
          onClose={() => { window.history.back(); }}
          actions={<RequestActions request={request} isAdmin={isAdmin} currentStatus={request.status} isUpdating={false} onStatusChange={() => {}} />}
          statusColor={undefined}
        />

        <Box sx={{ p: { xs: 2, md: 3 } }}>
          <Grid container spacing={2}>
            <Grid item xs={12} md={6}>
              <CustomerInfoSection
                mode="view"
                initialAddress={request.service_address}
                isAdmin={isAdmin}
                request={request}
                showCustomerInfo={true}
                canEdit={isAdmin}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <RequestProblemDetails request={request} />
            </Grid>
            <Grid item xs={12}>
              <QuoteList
                request={request}
                isReadOnly={!isAdmin}
                isUpdating={false}
                onAcceptQuote={() => { logger.log('Accept quote called from RequestView (noop)'); }}
                onUpdateRequest={() => { /* noop for read-only view */ }}
              />
            </Grid>
          </Grid>
        </Box>
      </Paper>
    </Box>
  );
};

export default RequestView;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/requests/types/index.ts ---

// packages/frontend/src/features/requests/types/index.ts

export interface Quote {
  id: string;
  quote_number: number;
  quote_amount: number;
  details: string;
  status: string;
  created_at: string;
}


export interface RequestNote {
  id: string;
  note: string;
  author_role: 'admin' | 'customer';
  created_at: string;
}

export interface QuoteAttachment {
  id: string;
  file_name: string;
  file_url: string;
  mime_type: string;
  quote_id?: string;
}

export interface QuoteRequest {
  id: string;
  created_at: string;
  customer_name: string;
  problem_category: string;
  status: string;
  is_emergency: boolean;
  answers: { question: string; answer: string }[];
  quote_attachments: QuoteAttachment[];
  user_profiles: { name: string; email: string; phone: string; [key: string]: any; } | null;
  service_address: string;
  quotes: Quote[];
  request_notes: RequestNote[];
  scheduled_start_date: string | null;
  triage_summary: string | null;
  priority_score: number | null;
  priority_explanation: string | null;
  profitability_score: number | null;
  profitability_explanation: string | null;
  required_expertise: {
    skill_level: 'apprentice' | 'journeyman' | 'master';
    specialized_skills: string[];
    reasoning: string;
  } | null;
  latitude: number | null;
  longitude: number | null;
  geocoded_address: string | null;
  actual_cost: number | null;
  completion_notes: string | null;
  invoice_id: string | null;
  accepted_quote_id: string | null;
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/features/services/ServiceDetailPage.tsx ---

import React from 'react';
import { services, ServiceDefinition } from '../../lib/serviceDefinitions';
import { ArrowLeft } from 'lucide-react';

interface ServiceDetailPageProps {
  serviceKey: string;
}

const ServiceDetailPage: React.FC<ServiceDetailPageProps> = ({ serviceKey }) => {
  const service = services.find(s => s.key === serviceKey);

  if (!service) {
    return (
      <div className="text-center p-8">
        <h2 className="text-2xl font-bold">Service Not Found</h2>
        <a href="/#" className="text-blue-600 hover:underline mt-4 inline-block">‚Üê Back to Home</a>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
      <a href="/#" className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-800 mb-6">
        <ArrowLeft size={18} />
        Back to All Services
      </a>
      <h1 className="text-4xl font-bold text-gray-900 mb-4">{service.title}</h1>
      <p className="text-lg text-gray-600 mb-8">{service.description}</p>

      {/* Placeholder for more content */}
      <div className="bg-gray-100 p-6 rounded-lg">
        <h3 className="text-2xl font-semibold mb-4">More Details Coming Soon</h3>
        <p>This page will include project photos, customer testimonials for this specific service, and a detailed breakdown of our process.</p>
        <button
            onClick={() => {/* This will need to be wired up to open the quote modal */}}
            className="mt-6 bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-700 transition-colors"
        >
            Request a Quote for {service.title}
        </button>
      </div>
    </div>
  );
};

export default ServiceDetailPage;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/hooks/index.ts ---

// packages/frontend/src/hooks/index.ts

/**
 * =============================================================================
 * hooks/index.ts - Central Hook Exports & Documentation
 * =============================================================================
 *
 * WHAT IS THIS FILE?
 * ------------------
 * This is the central export file for all custom React hooks in the plumbing
 * application. It provides a clean, organized API for importing hooks throughout
 * the codebase, following a modular architecture pattern.
 *
 * HOOK ARCHITECTURE OVERVIEW:
 * ---------------------------
 * The hooks are organized in a layered architecture:
 *
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ                    SPECIALIZED HOOKS (High-Level)           ‚îÇ
 * ‚îÇ  useUserRequests, useAllRequests, useAdminDashboard, etc.  ‚îÇ
 * ‚îÇ  - Business logic focused                                    ‚îÇ
 * ‚îÇ  - User role aware                                           ‚îÇ
 * ‚îÇ  - Pre-configured for common use cases                      ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                                ‚îÇ
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ                    CORE HOOKS (Mid-Level)                    ‚îÇ
 * ‚îÇ  useTableQuery, useSupabaseRealtimeV3                       ‚îÇ
 * ‚îÇ  - Generic data fetching with real-time                     ‚îÇ
 * ‚îÇ  - Configurable for any table/query pattern                 ‚îÇ
 * ‚îÇ  - Handles caching, real-time, and invalidation            ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                                ‚îÇ
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ                    UTILITIES (Low-Level)                     ‚îÇ
 * ‚îÇ  Supabase client, API client, status colors, etc.           ‚îÇ
 * ‚îÇ  - Raw data access and utilities                            ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *
 * IMPORT PATTERNS:
 * ----------------
 *
 * // Recommended: Import specific hooks you need
 * import { useUserRequests, useAllRequests } from '../hooks';
 * import { useAdminDashboard, useStatistics } from '../hooks';
 *
 * // Advanced: Import core hooks for custom implementations
 * import { useTableQuery } from '../hooks';
 *
 * // Full API: Import everything (not recommended for production)
 * import * as Hooks from '../hooks';
 *
 * HOOK CATEGORIES:
 * ----------------
 *
 * üîµ USER & PROFILE HOOKS:
 * - useUserProfile: Current user's profile data
 * - useAllUsers: All users (admin only)
 * - useAllUserProfiles: All user profiles (admin only)
 *
 * üü¢ REQUEST & QUOTE HOOKS:
 * - useUserRequests: Current user's plumbing requests
 * - useAllRequests: All requests (admin dashboard)
 * - useRequestById: Specific request details
 * - useRequestQuotes: Quotes for a specific request
 * - useAllQuotes: All quotes (admin only)
 * - useRequestNotes: Notes for a specific request
 * - useQuoteAttachments: Attachments for a specific quote
 *
 * üü° ADMIN DASHBOARD HOOKS:
 * - useAdminDashboard: Combined admin data (requests, users, quotes)
 * - useStatistics: Real-time business statistics
 *
 * üî¥ MUTATION HOOKS:
 * - useSubmitQuoteRequest: Submit new plumbing requests
 * - useUpdateRequestStatus: Change request status (admin)
 * - useAcceptQuote: Customer accepts quotes
 * - useCreateQuote: Create new quotes
 * - useUpdateQuote: Modify existing quotes
 * - useTriageRequest: AI analysis of requests
 * - useUpdateAddressMutation: Update service addresses
 *
 * ÔøΩ CORE SYSTEM HOOKS:
 * - useTableQuery: Generic table query with real-time (advanced)
 * - useSupabaseRealtimeV3: Real-time subscription management
 *
 * REAL-TIME FEATURES:
 * -------------------
 * All data hooks automatically include real-time updates:
 * - UI updates instantly when database changes
 * - Cross-user synchronization (admin ‚Üî user updates)
 * - No manual refresh needed
 * - Optimized for performance with smart caching
 *
 * USAGE GUIDELINES:
 * -----------------
 * 1. Use specialized hooks for common patterns (recommended)
 * 2. Use core hooks only for custom/advanced use cases
 * 3. All hooks handle loading states, errors, and real-time updates
 * 4. Import only what you need for better tree-shaking
 * 5. Hooks are memoized and optimized for performance
 *
 * MIGRATION NOTES:
 * ----------------
 * - All hooks now use the unified real-time system
 * - Legacy feature-specific hooks have been consolidated
 * - Real-time is automatic - no manual setup required
 */

// Core real-time system
export { useTableQuery, useQuotesQuery, useProfileQuery, useUsersQuery } from './useTableQuery';
export { useRealtimeInvalidation } from './useSupabaseRealtimeV3';

// Specialized queries for all tables
export {
  // User & Profile
  useUserProfile,
  useAllUsers,
  useAllUserProfiles,

  // Requests & Quotes
  useUserRequests,
  useAllRequests,
  useRequestById,
  useRequestQuotes,
  useAllQuotes,
  useRequestNotes,
  useQuoteAttachments,

  // Invoices
  useInvoiceById,

  // Admin Dashboard
  useAdminDashboard,
  useStatistics,
} from './useSpecializedQueries';

// Mutation hooks for write operations
export {
  useSubmitQuoteRequest,
  useUpdateRequestStatus,
  useMarkRequestAsViewed,
  useAcceptQuote,
  useCreateQuote,
  useUpdateQuote,
  useDeleteQuote,
  useTriageRequest,
  useUpdateAddressMutation,
} from './useRequestMutations';

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/hooks/useRequestMutations.ts ---

// packages/frontend/src/hooks/useRequestMutations.ts

import { useMutation, useQueryClient } from '@tanstack/react-query';
import apiClient from '../lib/apiClient';
import { QuoteRequest } from '../features/requests/types';
import { useAuth } from '../features/auth/AuthContext';
import { logger } from '../lib/logger';

export function useUpdateRequestStatus() {
  const queryClient = useQueryClient();
  const { user } = useAuth();

  return useMutation({
    mutationFn: async ({
      requestId,
      status,
      scheduledStartDate,
    }: {
      requestId: string;
      status: string;
      scheduledStartDate?: string | null;
    }) => {
      const payload: { status: string; scheduled_start_date?: string | null } = {
        status,
      };
      if (scheduledStartDate !== undefined)
        payload.scheduled_start_date = scheduledStartDate;
      logger.log('useUpdateRequestStatus: Calling API', {
        requestId,
        status,
        scheduledStartDate,
        payload,
      });
      await apiClient.patch(`/requests/${requestId}/status`, payload);
    },
    onMutate: async (variables) => {
      const { requestId, status, scheduledStartDate } = variables;
      logger.log('useUpdateRequestStatus: Optimistic update', { requestId, status, scheduledStartDate });

      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['requests'] });
      await queryClient.cancelQueries({ queryKey: ['request', requestId] });

      // Snapshot previous values
      const previousRequests = queryClient.getQueryData<QuoteRequest[]>(['requests']);
      const previousUserRequests = user ? queryClient.getQueryData<QuoteRequest[]>(['requests', user.id]) : null;
      const previousRequestDetail = queryClient.getQueryData<QuoteRequest[]>(['request', requestId]);

      // Optimistically update the cache
      queryClient.setQueryData<QuoteRequest[]>(['requests'], (old = []) =>
        old.map(req =>
          req.id === requestId
            ? {
                ...req,
                status,
                scheduled_start_date: scheduledStartDate ?? req.scheduled_start_date,
              }
            : req
        )
      );

      if (user) {
        queryClient.setQueryData<QuoteRequest[]>(['requests', user.id], (old = []) =>
          old.map(req =>
            req.id === requestId
              ? {
                  ...req,
                  status,
                  scheduled_start_date: scheduledStartDate ?? req.scheduled_start_date,
                }
              : req
          )
        );
      }

      if (previousRequestDetail) {
        queryClient.setQueryData(['request', requestId], (old: any) => {
          if (!old || old.length === 0) return old;
          const first = old[0];
          return [
            {
              ...first,
              status,
              scheduled_start_date: scheduledStartDate ?? first.scheduled_start_date,
            },
          ];
        });
      }

      return { previousRequests, previousUserRequests, previousRequestDetail };
    },
    onError: (err, variables, context) => {
      logger.error('useUpdateRequestStatus: Error, rolling back', { err, variables });
      // Rollback optimistic updates
      if (context?.previousRequests) {
        queryClient.setQueryData(['requests'], context.previousRequests);
      }
      if (context?.previousUserRequests && user) {
        queryClient.setQueryData(['requests', user.id], context.previousUserRequests);
      }
      if (context?.previousRequestDetail) {
        queryClient.setQueryData(['request', variables.requestId], context.previousRequestDetail);
      }
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to update request status. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
    onSuccess: async (data, variables) => {
      logger.log('useUpdateRequestStatus: Success', { data, variables });
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      await queryClient.invalidateQueries({
        queryKey: ['request', variables.requestId],
      });
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: `‚úÖ Request status updated to ${variables.status}!`,
          severity: 'success',
        },
      });
      window.dispatchEvent(event);
    },
  });
}

export function useAcceptQuote() {
  const queryClient = useQueryClient();
  const { user } = useAuth();

  return useMutation({
    mutationFn: async ({
      requestId,
      quoteId,
    }: {
      requestId: string;
      quoteId: string;
    }) => {
      const response = await apiClient.post(
        `/requests/${requestId}/quotes/${quoteId}/accept`
      );
      return response.data;
    },
    onMutate: async (variables) => {
      const { requestId, quoteId } = variables;
      logger.log('‚ö° Optimistic Update: Starting for acceptQuote', {
        requestId,
        quoteId,
      });
      await queryClient.cancelQueries({ queryKey: ['requests'] });
      await queryClient.cancelQueries({ queryKey: ['request', requestId] });

      const previousRequests = queryClient.getQueryData<QuoteRequest[]>(['requests']);
      const previousUserRequests = user ? queryClient.getQueryData<QuoteRequest[]>(['requests', user.id]) : null;
      const previousRequestDetail = queryClient.getQueryData<QuoteRequest[]>(['request', requestId]);
      logger.log('üì∏ Snapshot created:', { hasAllRequests: !!previousRequests, hasUserRequests: !!previousUserRequests, hasDetail: !!previousRequestDetail });

      // Update admin's all requests query
      queryClient.setQueryData<QuoteRequest[]>(['requests'], (oldData = []) =>
        oldData.map(req =>
          req.id === requestId
            ? {
                ...req,
                status: 'accepted',
                quotes: req.quotes.map(q =>
                  q.id === quoteId ? { ...q, status: 'accepted' } : { ...q, status: 'rejected' }
                ),
              }
            : req
        )
      );

      // Update user's requests query if user exists
      if (user) {
        queryClient.setQueryData<QuoteRequest[]>(['requests', user.id], (oldData = []) =>
          oldData.map(req =>
            req.id === requestId
              ? {
                  ...req,
                  status: 'accepted',
                  quotes: req.quotes.map(q =>
                    q.id === quoteId ? { ...q, status: 'accepted' } : { ...q, status: 'rejected' }
                  ),
                }
              : req
          )
        );
      }

      if (previousRequestDetail) {
        queryClient.setQueryData<QuoteRequest[]>(['request', requestId], oldData => {
            if (!oldData || oldData.length === 0) return [];
            return [{
                ...oldData[0],
                status: 'accepted',
                quotes: oldData[0].quotes.map(q =>
                    q.id === quoteId ? { ...q, status: 'accepted' } : { ...q, status: 'rejected' }
                )
            }];
        });
      }

      logger.log('‚úÖ UI updated optimistically to "accepted" state.');
      return { previousRequests, previousUserRequests, previousRequestDetail };
    },
    onError: (err, variables, context) => {
      logger.error('‚ùå Optimistic Update Failed. Rolling back.', { err });
      if (context?.previousRequests) {
        queryClient.setQueryData(['requests'], context.previousRequests);
      }
      if (context?.previousUserRequests && user) {
        queryClient.setQueryData(['requests', user.id], context.previousUserRequests);
      }
      if (context?.previousRequestDetail) {
        queryClient.setQueryData(['request', variables.requestId], context.previousRequestDetail);
      }
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to accept quote. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
    onSuccess: async (data, variables) => {
      logger.log('useAcceptQuote: Success', { data, variables });
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      await queryClient.invalidateQueries({
        queryKey: ['request', variables.requestId],
      });
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Quote accepted!', severity: 'success' },
      });
      window.dispatchEvent(event);
    },
  });
}

export function useCreateQuote() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      requestId,
      quote,
    }: {
      requestId: string;
      quote: any;
    }) => {
      const response = await apiClient.post(
        `/requests/${requestId}/quotes`,
        quote
      );
      return response.data;
    },
    onSuccess: async (data, variables) => {
      logger.log('useCreateQuote: Success', { data, variables });
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      await queryClient.invalidateQueries({
        queryKey: ['request', variables.requestId],
      });
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Quote created!', severity: 'success' },
      });
      window.dispatchEvent(event);
    },
    onError: (error, variables) => {
      logger.error('useCreateQuote: Error', error);
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to create quote. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
  });
}

export function useUpdateQuote() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      requestId,
      quoteId,
      quote,
    }: {
      requestId: string;
      quoteId: string;
      quote: any;
    }) => {
      const response = await apiClient.put(
        `/requests/${requestId}/quotes/${quoteId}`,
        quote
      );
      return response.data;
    },
    onSuccess: async (data, variables) => {
      logger.log('useUpdateQuote: Success', { data, variables });
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      await queryClient.invalidateQueries({
        queryKey: ['request', variables.requestId],
      });
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Quote updated!', severity: 'success' },
      });
      window.dispatchEvent(event);
    },
    onError: (error, variables) => {
      logger.error('useUpdateQuote: Error', error, variables);
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to update quote. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
  });
}

export function useSubmitQuoteRequest() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (payload: any) => {
      const response = await apiClient.post('/requests/submit', payload);
      return response.data;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Request submitted!', severity: 'success' },
      });
      window.dispatchEvent(event);
    },
    onError: (error) => {
      logger.error('useSubmitQuoteRequest: Error', error);
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to submit request. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
  });
}

export function useTriageRequest() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ requestId }: { requestId: string }) => {
      const response = await apiClient.post(`/triage/${requestId}`);
      return response.data;
    },
    onSuccess: async (data, variables) => {
      logger.log('useTriageRequest: Success', { data, variables });
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      await queryClient.invalidateQueries({
        queryKey: ['request', variables.requestId],
      });
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Request triaged!', severity: 'success' },
      });
      window.dispatchEvent(event);
    },
    onError: (error, variables) => {
      logger.error('useTriageRequest: Error', { error, variables });
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to triage request. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
  });
}

/**
 * Centralized hook: mark a request as viewed (user opened the quoted modal).
 * - Optimistic update: only flip quoted -> viewed
 * - Rolls back on error
 * - Invalidates both the list(s) and the request detail
 */
export function useMarkRequestAsViewed() {
  const queryClient = useQueryClient();
  const { user } = useAuth();

  return useMutation({
    mutationFn: async (requestId: string) => {
      // backend endpoint: PATCH /requests/:id/viewed
      const res = await apiClient.patch(`/requests/${requestId}/viewed`);
      return res.data;
    },
    onMutate: async (requestId: string) => {
      await queryClient.cancelQueries({ queryKey: ['requests'] });
      await queryClient.cancelQueries({ queryKey: ['request', requestId] });

      const previousAll = queryClient.getQueryData<QuoteRequest[]>(['requests']);
      const previousUser = user
        ? queryClient.getQueryData<QuoteRequest[]>(['requests', user.id])
        : null;
      const previousDetail = queryClient.getQueryData<QuoteRequest[]>(['request', requestId]);

      // optimistic: mark 'quoted' -> 'viewed' only
      queryClient.setQueryData<QuoteRequest[]>(
        ['requests'],
        (old = []) =>
          old.map((r) =>
            r.id === requestId ? { ...r, status: r.status === 'quoted' ? 'viewed' : r.status } : r
          )
      );

      if (user) {
        queryClient.setQueryData<QuoteRequest[]>(
          ['requests', user.id],
          (old = []) =>
            old.map((r) =>
              r.id === requestId ? { ...r, status: r.status === 'quoted' ? 'viewed' : r.status } : r
            )
        );
      }

      if (previousDetail) {
        queryClient.setQueryData(['request', requestId], (old: any) => {
          if (!old || old.length === 0) return old;
          const first = old[0];
          return [
            {
              ...first,
              status: first.status === 'quoted' ? 'viewed' : first.status,
            },
          ];
        });
      }

      return { previousAll, previousUser, previousDetail };
    },
    onError: (_err, requestId, context) => {
      logger.error('‚ùå Mark as viewed error:', _err);
      logger.error('Request ID:', requestId);
      logger.error('Error details:', JSON.stringify(_err, null, 2));

      if (context?.previousAll) queryClient.setQueryData(['requests'], context.previousAll);
      if (context?.previousUser && user) queryClient.setQueryData(['requests', user.id], context.previousUser);
      if (context?.previousDetail) queryClient.setQueryData(['request', requestId], context.previousDetail);
      window.dispatchEvent(
        new CustomEvent('show-snackbar', {
          detail: { message: '‚ùå Failed to mark viewed. Please refresh.', severity: 'error' },
        })
      );
    },
    onSettled: (_data, _err, requestId) => {
      // Ensure server truth overrides eventual state
      queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      queryClient.invalidateQueries({ queryKey: ['request', requestId] });
    },
    onSuccess: () => {
      // silent success is fine; invalidate already runs
    },
  });
}

export function useDeleteQuote() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      requestId,
      quoteId,
    }: {
      requestId: string;
      quoteId: string;
    }) => {
      const response = await apiClient.delete(
        `/requests/${requestId}/quotes/${quoteId}`
      );
      return response.data;
    },
    onSuccess: async (data, variables) => {
      logger.log('useDeleteQuote: Success', { data, variables });
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      await queryClient.invalidateQueries({
        queryKey: ['request', variables.requestId],
      });
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Quote deleted successfully!', severity: 'success' },
      });
      window.dispatchEvent(event);
    },
    onError: (error, variables) => {
      logger.error('useDeleteQuote: Error', { error, variables });
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to delete quote. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
  });
}

export function useUpdateAddressMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      requestId,
      address,
    }: {
      requestId: string;
      address: any;
    }) => {
      const response = await apiClient.patch(
        `/requests/${requestId}/address`,
        address
      );
      return response.data;
    },
    onSuccess: async (data, variables) => {
      logger.log('useUpdateAddressMutation: Success', { data, variables });
      await queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      await queryClient.invalidateQueries({
        queryKey: ['request', variables.requestId],
      });
      const event = new CustomEvent('show-snackbar', {
        detail: { message: '‚úÖ Address updated!', severity: 'success' },
      });
      window.dispatchEvent(event);
    },
    onError: (error, variables) => {
      logger.error('useUpdateAddressMutation: Error', { error, variables });
      const event = new CustomEvent('show-snackbar', {
        detail: {
          message: '‚ùå Failed to update address. Please try again.',
          severity: 'error',
        },
      });
      window.dispatchEvent(event);
    },
  });
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/hooks/useSpecializedQueries.ts ---

// packages/frontend/src/hooks/useSpecializedQueries.ts

/**
 * =============================================================================
 * useSpecializedQueries.ts - Specialized Data Query Hooks
 * =============================================================================
 *
 * WHAT IS THIS FILE?
 * ------------------
 * This file contains specialized query hooks that build on top of the core
 * useTableQuery hook. These hooks provide convenient, pre-configured interfaces
 * for common data access patterns in the plumbing application.
 *
 * WHY SPECIALIZED HOOKS?
 * ----------------------
 * - Provides semantic, business-logic-focused APIs
 * - Handles complex relationships between tables
 * - Includes user role-based access control
 * - Combines multiple queries for dashboard views
 * - Abstracts away technical query configuration
 *
 * HOOK CATEGORIES:
 * ----------------
 * 1. USER & PROFILE QUERIES - User management and profiles
 * 2. REQUEST & QUOTE QUERIES - Core business data (plumbing requests)
 * 3. ADMIN DASHBOARD QUERIES - Combined views for administrators
 * 4. UTILITY HOOKS - Statistics and computed data
 *
 * REAL-TIME FEATURES:
 * -------------------
 * All hooks automatically include real-time updates via useTableQuery
 * - User requests update when new quotes are added
 * - Admin dashboards update when users create requests
 * - Statistics update in real-time as data changes
 *
 * USAGE PATTERNS:
 * ---------------
 * - Admin Dashboard: useAdminDashboard() - All admin data in one hook
 * - User Profile: useUserRequests(userId) - User's plumbing requests
 * - Statistics: useStatistics() - Real-time business metrics
 * - Quotes: useRequestQuotes(requestId) - Quotes for specific request
 *
 * DEPENDENCIES:
 * -------------
 * - useTableQuery: Core query functionality with real-time
 * - QuoteRequest, Quote, etc.: TypeScript interfaces from types/
 */

import { useTableQuery } from './useTableQuery';

/**
 * Specialized query hooks for all database tables
 * These hooks provide real-time updates and standardized patterns
 */

// ========== USER & PROFILE QUERIES ==========

interface UserProfile {
  id: string;
  user_id: string;
  role: 'admin' | 'user';
  name?: string;
  email?: string;
  phone?: string;
  created_at: string;
  updated_at: string;
}

interface User {
  id: string;
  email: string;
  created_at: string;
  last_sign_in_at?: string;
}

/**
 * Get current user's profile with real-time updates
 */
export function useUserProfile(userId: string) {
  return useTableQuery<UserProfile>('user_profiles', {
    userId,
    endpoint: '/user/profile',
    queryKey: ['profile', userId],
    additionalTables: ['users'], // Listen for user table changes too
  });
}

/**
 * Get all users (admin only) with real-time updates
 */
export function useAllUsers() {
  return useTableQuery<User>('users', {
    endpoint: '/admin/users',
    additionalTables: ['user_profiles'], // Listen for profile changes
  });
}

/**
 * Get all user profiles (admin only) with real-time updates
 */
export function useAllUserProfiles() {
  return useTableQuery<UserProfile>('user_profiles', {
    endpoint: '/admin/user-profiles',
    additionalTables: ['users'],
  });
}

// ========== REQUEST & QUOTE QUERIES ==========

// Import the correct types from the main types file
import { QuoteRequest, RequestNote, Quote, QuoteAttachment } from '../features/requests/types';

/**
 * Get user's requests with real-time updates
 */
export function useUserRequests(userId: string) {
  return useTableQuery<QuoteRequest>('requests', {
    userId,
    endpoint: '/requests',
    queryKey: ['requests', userId],
    additionalTables: ['quotes', 'request_notes', 'quote_attachments'],
  });
}

/**
 * Get all requests (admin only) with real-time updates
 */
export function useAllRequests() {
  return useTableQuery<QuoteRequest>('requests', {
    endpoint: '/requests', // Backend handles admin vs user filtering
    queryKey: ['requests'], // No userId for admin
    additionalTables: ['quotes', 'request_notes', 'quote_attachments', 'user_profiles'],
  });
}

/**
 * Get specific request by ID with real-time updates
 */
export function useRequestById(requestId: string, options?: { enabled?: boolean }) {
  return useTableQuery<QuoteRequest>('requests', {
    endpoint: `/requests/${requestId}`,
    queryKey: ['request', requestId],
    additionalTables: ['quotes', 'request_notes', 'quote_attachments'],
    enableRealtime: true,
    enabled: options?.enabled,
  });
}

/**
 * Get quotes for a specific request with real-time updates
 */
export function useRequestQuotes(requestId: string) {
  return useTableQuery<Quote>('quotes', {
    endpoint: `/requests/${requestId}/quotes`,
    queryKey: ['quotes', requestId],
    additionalTables: ['quote_attachments', 'requests'],
  });
}

/**
 * Get all quotes (admin only) with real-time updates
 */
export function useAllQuotes() {
  return useTableQuery<Quote>('quotes', {
    endpoint: '/admin/quotes',
    queryKey: ['quotes'],
    additionalTables: ['quote_attachments', 'requests'],
  });
}

/**
 * Get notes for a specific request with real-time updates
 */
export function useRequestNotes(requestId: string) {
  return useTableQuery<RequestNote>('request_notes', {
    endpoint: `/requests/${requestId}/notes`,
    queryKey: ['notes', requestId],
    additionalTables: ['requests'], // Listen for request changes
  });
}

/**
 * Get attachments for a specific quote with real-time updates
 */
export function useQuoteAttachments(quoteId: string) {
  return useTableQuery<QuoteAttachment>('quote_attachments', {
    endpoint: `/quotes/${quoteId}/attachments`,
    queryKey: ['attachments', quoteId],
    additionalTables: ['quotes'], // Listen for quote changes
  });
}

// ========== ADMIN DASHBOARD QUERIES ==========

/**
 * Get dashboard data for admin with real-time updates
 * This combines multiple queries for the admin dashboard
 */
export function useAdminDashboard() {
  const requests = useAllRequests();
  const users = useAllUsers();
  const quotes = useAllQuotes();

  return {
    requests: requests.data,
    users: users.data,
    quotes: quotes.data,
    loading: requests.loading || users.loading || quotes.loading,
    error: requests.error || users.error || quotes.error,
    refetch: () => {
      requests.refetch();
      users.refetch();
      quotes.refetch();
    }
  };
}

// ========== UTILITY HOOKS ==========

/**
 * Get specific invoice by ID
 */
export function useInvoiceById(invoiceId: string, options?: { enabled?: boolean }) {
  return useTableQuery<any>('invoices', {
    endpoint: `/invoices/${invoiceId}`,
    queryKey: ['invoice', invoiceId],
    additionalTables: [],
    enableRealtime: false,
    enabled: options?.enabled,
  });
}

/**
 * Get real-time statistics with automatic updates
 */
export function useStatistics() {
  const requests = useAllRequests();

  const stats = {
    totalRequests: requests.data.length,
    newRequests: requests.data.filter(r => r.status === 'new').length,
    quotedRequests: requests.data.filter(r => r.status === 'quoted').length,
    completedRequests: requests.data.filter(r => r.status === 'completed').length,
    emergencyRequests: requests.data.filter(r => r.status === 'emergency').length,
  };

  return {
    stats,
    loading: requests.loading,
    error: requests.error,
    refetch: requests.refetch
  };
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/hooks/useSupabaseRealtimeV3.ts ---

// packages/frontend/src/hooks/useSupabaseRealtimeV3.ts

/**
 * =============================================================================
 * useSupabaseRealtimeV3.ts - Advanced Supabase Real-Time Hook
 * =============================================================================
 *
 * WHAT IS THIS HOOK?
 * ------------------
 * This is the core real-time synchronization hook that establishes WebSocket
 * connections to Supabase for live database updates. It intelligently manages
 * multiple table subscriptions and triggers React Query cache invalidation
 * when database changes occur.
 *
 * WHY "V3"?
 * ---------
 * This is the third iteration of the real-time system, featuring:
 * - Advanced table configuration with filtering
 * - Smart query invalidation targeting
 * - Comprehensive error handling and logging
 * - Performance optimizations
 * - Type-safe configuration
 *
 * HOW IT WORKS:
 * -------------
 * 1. SUBSCRIPTION: Creates WebSocket channels for specified tables
 * 2. LISTENING: Monitors INSERT/UPDATE/DELETE events via PostgreSQL changes
 * 3. FILTERING: Applies row-level or table-level filters if specified
 * 4. INVALIDATION: Triggers React Query cache updates for affected data
 * 5. CLEANUP: Properly unsubscribes when component unmounts
 *
 * KEY FEATURES:
 * -------------
 * - Multi-table subscriptions in single hook
 * - Row-level filtering (e.g., user-specific data)
 * - Event-specific listening (INSERT, UPDATE, DELETE)
 * - Smart query invalidation (targets specific cache keys)
 * - Connection status monitoring
 * - Automatic cleanup and error recovery
 *
 * CONFIGURATION:
 * --------------
 * Table configs must be memoized with useMemo() to prevent re-subscription:
 *
 * const tableConfigs = useMemo(() => [
 *   {
 *     table: 'requests',
 *     events: ['INSERT', 'UPDATE'],
 *     invalidateQueries: [['requests'], ['requests', userId]]
 *   }
 * ], [userId]);
 *
 * REAL-TIME ARCHITECTURE:
 * -----------------------
 * Component ‚Üí useTableQuery ‚Üí useSupabaseRealtimeV3 ‚Üí Supabase WebSocket
 *     ‚Üì              ‚Üì                    ‚Üì                      ‚Üì
 *   Data Display  Cache Mgmt      Event Listening      DB Changes
 *   Updates       Invalidation    Query Targeting      Live Sync
 *
 * PERFORMANCE:
 * ------------
 * - Minimal subscriptions (only specified tables/events)
 * - Targeted invalidation (only affected queries)
 * - Connection pooling and reuse
 * - Automatic cleanup prevents memory leaks
 *
 * ERROR HANDLING:
 * ---------------
 * - Channel connection errors logged and handled gracefully
 * - Subscription timeouts managed automatically
 * - Continues operation even if real-time fails
 * - Comprehensive logging for debugging
 *
 * DEPENDENCIES:
 * -------------
 * - Supabase Client: For WebSocket connections
 * - React Query: For cache invalidation
 * - Custom table configs: Provided by calling hooks
 */

import { useEffect, useRef } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { supabase } from '../lib/supabaseClient';
import { logger } from '../lib/logger';

interface TableConfig {
  table: string;
  events?: ('INSERT' | 'UPDATE' | 'DELETE')[];
  schema?: string;
  filter?: string; // e.g., "id=eq.123" for row-level filtering
  invalidateQueries: (string | (string | undefined)[])[]; // Query keys to invalidate
}

interface RealtimeOptions {
  enabled?: boolean;
  onEvent?: (event: string, table: string, payload: any) => void;
}

/**
 * Advanced Supabase Realtime hook following official patterns
 * Handles specific table changes with targeted query invalidation
 *
 * ‚ö†Ô∏è IMPORTANT: The `tableConfigs` array MUST be memoized using `useMemo` in the calling component
 * to prevent re-subscribing on every render. See example below.
 *
 * @param tableConfigs - Array of table configurations (MUST be memoized with useMemo)
 * @param options - Hook options
 *
 * @example
 * import { useMemo } from 'react';
 *
 * function MyComponent() {
 *   const tableConfigs = useMemo(() => [
 *     {
 *       table: 'requests',
 *       events: ['INSERT', 'UPDATE', 'DELETE'],
 *       invalidateQueries: [['requests'], ['requests', userId]]
 *     },
 *     {
 *       table: 'quotes',
 *       events: ['INSERT', 'UPDATE'],
 *       invalidateQueries: [['quotes'], ['requests']] // Quotes affect requests
 *     }
 *   ], [userId]); // Only re-create if dependencies change
 *
 *   useSupabaseRealtimeV3(tableConfigs, { enabled: true });
 *   // ...
 * }
 */
export function useSupabaseRealtimeV3(
  tableConfigs: TableConfig[],
  options: RealtimeOptions = {}
) {
  const { enabled = true, onEvent } = options;
  const queryClient = useQueryClient();
  const channelRef = useRef<any>(null);

  useEffect(() => {
    if (!enabled) {
      return;
    }

    // CRITICAL: tableConfigs must be memoized in the calling component using useMemo
    // to prevent re-subscribing on every render. Example:
    // const tableConfigs = useMemo(() => [{ table: 'requests', ... }], [dependencies]);

    logger.log('üîå Setting up Supabase Realtime v3 for tables:', tableConfigs.map(c => c.table));

    // Create a descriptive channel name for better debugging
    const tables = tableConfigs.map(c => c.table).join('-');
    const channelName = `realtime-v3-${tables}`;
    const channel = supabase.channel(channelName);

    // Set up listeners for each table configuration
    tableConfigs.forEach(config => {
      const events = config.events || ['INSERT', 'UPDATE', 'DELETE'];
      const schema = config.schema || 'public';

      events.forEach(event => {
        channel.on(
          'postgres_changes',
          {
            event,
            schema,
            table: config.table,
            ...(config.filter && { filter: config.filter })
          } as any,
          (payload: any) => {
            logger.log(`üîÑ Realtime v3: ${event} on ${config.table}`, {
              recordId: payload.new?.id || payload.old?.id,
              event,
              table: config.table,
              payloadKeys: Object.keys(payload)
            });

            // Call custom event handler if provided
            onEvent?.(event, config.table, payload);

            // Invalidate specified queries
            config.invalidateQueries.forEach(queryKey => {
              const key = Array.isArray(queryKey) ? queryKey.filter(Boolean) : [queryKey];
              logger.log(`üóëÔ∏è Invalidating queries with key:`, key);
              queryClient.invalidateQueries({ queryKey: key, exact: false });
            });

            // Special handling for request_notes - also invalidate the specific request query
            if (config.table === 'request_notes' && payload.new?.request_id) {
              const requestQueryKey = ['request', payload.new.request_id];
              logger.log(`üóëÔ∏è Special invalidation for request_notes:`, requestQueryKey);
              queryClient.invalidateQueries({ queryKey: requestQueryKey, exact: true });
            }

            // Special handling for quotes - also invalidate the specific parent request query
            // This ensures the request's details (like status) are fresh when its quotes change.
            if (config.table === 'quotes' && (payload.new?.request_id || payload.old?.request_id)) {
              const requestId = payload.new?.request_id || payload.old?.request_id;
              const requestQueryKey = ['request', requestId];
              logger.log(`üóëÔ∏è Special invalidation for quotes affecting parent request:`, requestQueryKey);
              queryClient.invalidateQueries({ queryKey: requestQueryKey, exact: true });
            }
          }
        );
      });
    });

    // Subscribe to the channel
    channel.subscribe((status, err) => {
      // Suppress noisy "mismatch between server and client bindings" errors
      // These are harmless WebSocket protocol warnings that don't affect functionality
      const isBindingMismatch = err?.message?.includes('mismatch between server and client bindings');

      if (status === 'SUBSCRIBED') {
        logger.log('‚úÖ Realtime v3 channel subscribed successfully');
        logger.log('üéß Listening for changes on tables:', tableConfigs.map(c => c.table));
      } else if (status === 'CHANNEL_ERROR') {
        // Only log non-binding-mismatch errors
        if (!isBindingMismatch) {
          logger.error('‚ùå Realtime v3 channel error:', status, err);
          logger.warn('‚ö†Ô∏è Continuing without realtime due to channel error');
        }
      } else if (status === 'TIMED_OUT') {
        logger.error('‚è∞ Realtime v3 channel timed out');
        logger.warn('‚ö†Ô∏è Continuing without realtime due to timeout');
      } else if (status === 'CLOSED') {
        logger.log('üîå Realtime v3 channel closed');
      }
    });

    // Store channel reference for cleanup
    channelRef.current = channel;

    // Cleanup function
    return () => {
      logger.log('üßπ Cleaning up Realtime v3 channel');
      if (channelRef.current) {
        supabase.removeChannel(channelRef.current);
        channelRef.current = null;
      }
    };
  }, [enabled, tableConfigs, queryClient, onEvent]);
}

/**
 * Centralized real-time invalidation hook for critical tables
 * Ensures all clients receive updates for requests and quotes changes
 */
export function useRealtimeInvalidation(userId?: string) {
  const queryClient = useQueryClient();

  useEffect(() => {
    logger.log('üîå Setting up centralized realtime invalidation');

    // Helper to invalidate all relevant query keys
    const invalidateAll = (requestId?: string) => {
      queryClient.invalidateQueries({ queryKey: ['requests'], exact: false });
      if (requestId) {
        queryClient.invalidateQueries({ queryKey: ['request', requestId] });
      }
      if (userId) {
        queryClient.invalidateQueries({ queryKey: ['requests', userId] });
      }
    };

    // Subscribe to requests table (all events)
    const reqChannel = supabase
      .channel('public:requests')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'requests' },
        (payload: any) => {
          logger.log('[realtime] requests payload', payload);
          const newRow = payload.new ?? payload.record ?? null;
          const requestId = newRow?.id ?? null;
          invalidateAll(requestId);
        }
      )
      .subscribe();

    // Subscribe to quotes table (status changes affect requests)
    const quotesChannel = supabase
      .channel('public:quotes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'quotes' },
        (payload: any) => {
          logger.log('[realtime] quotes payload', payload);
          const newRow = payload.new ?? payload.record ?? null;
          const requestId = newRow?.request_id ?? null;
          invalidateAll(requestId);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(reqChannel);
      supabase.removeChannel(quotesChannel);
    };
  }, [queryClient, userId]);
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/hooks/useTableQuery.ts ---

// packages/frontend/src/hooks/useTableQuery.ts

/**
 * =============================================================================
 * useTableQuery.ts - Advanced Database Query Hook with Real-Time Updates
 * =============================================================================
 *
 * WHAT IS A HOOK?
 * ---------------
 * In React, a "hook" is a special function that lets you use React features
 * (like state, lifecycle methods, and context) in functional components.
 * Hooks are the modern way to manage component logic and side effects.
 *
 * WHAT DOES THIS HOOK DO?
 * -----------------------
 * This is an advanced, reusable hook that combines:
 * 1. Data fetching from database tables via REST API
 * 2. Automatic real-time updates via Supabase WebSocket subscriptions
 * 3. Smart query caching and invalidation using TanStack Query
 * 4. Cross-component synchronization for multi-user applications
 *
 * KEY FEATURES:
 * - Generic: Works with any database table
 * - Real-time: Automatically updates UI when database changes
 * - Cached: Prevents unnecessary API calls
 * - User-aware: Supports user-specific data filtering
 * - Type-safe: Full TypeScript support
 * - Optimized: Smart invalidation prevents unnecessary refetches
 *
 * HOW IT WORKS:
 * -------------
 * 1. FETCH: Makes HTTP request to API endpoint (e.g., /requests)
 * 2. CACHE: Stores data in TanStack Query cache with unique key
 * 3. SUBSCRIBE: Sets up WebSocket listeners for database changes
 * 4. INVALIDATE: When DB changes occur, invalidates relevant cache entries
 * 5. REFRESH: Automatically refetches fresh data and updates UI
 *
 * REAL-TIME SYNCHRONIZATION:
 * --------------------------
 * - Listens for INSERT/UPDATE/DELETE events on specified tables
 * - Invalidates TanStack Query cache when changes detected
 * - Triggers automatic UI updates across all components using same data
 * - Supports cross-user synchronization (admin ‚Üî user updates)
 *
 * ARCHITECTURE BENEFITS:
 * ----------------------
 * - Eliminates manual refresh buttons
 * - Prevents stale data issues
 * - Enables instant collaboration features
 * - Reduces server load through smart caching
 * - Provides consistent UX across different user roles
 *
 * USAGE PATTERNS:
 * ---------------
 * - Admin dashboards (see all requests)
 * - User-specific lists (my requests only)
 * - Detail views with related data
 * - Real-time collaborative features
 *
 * DEPENDENCIES:
 * -------------
 * - @tanstack/react-query: For caching and query management
 * - Supabase: For real-time database subscriptions
 * - Custom API client: For HTTP requests
 */

import { useQuery, UseQueryOptions, useQueryClient } from '@tanstack/react-query';
import { useMemo } from 'react';
import apiClient from '../lib/apiClient';
import { useSupabaseRealtimeV3 } from './useSupabaseRealtimeV3';
import { logger } from '../lib/logger';

interface TableQueryOptions<T> extends Omit<UseQueryOptions<T[], Error>, 'queryKey' | 'queryFn'> {
  // Real-time subscription options
  enableRealtime?: boolean;
  additionalTables?: string[]; // Additional tables to subscribe to for updates
  userId?: string; // For user-specific queries

  // Query customization
  endpoint?: string; // Custom API endpoint (defaults to table name)
  queryKey?: (string | undefined)[]; // Custom query key parts
}

/**
 * Generic hook for querying database tables with automatic real-time updates
 *
 * @param table - Primary table name
 * @param options - Configuration options
 *
 * @example
 * // Basic usage for requests
 * const { data: requests, loading, error } = useTableQuery<QuoteRequest>('requests');
 *
 * @example
 * // User-specific requests with real-time updates
 * const { data: requests, loading, error } = useTableQuery<QuoteRequest>('requests', {
 *   userId,
 *   enableRealtime: true,
 *   additionalTables: ['quotes', 'request_notes'] // Also listen for quote/note changes
 * });
 *
 * @example
 * // Admin view with custom endpoint
 * const { data: allRequests } = useTableQuery<QuoteRequest>('requests', {
 *   endpoint: '/admin/requests',
 *   enableRealtime: true,
 *   additionalTables: ['quotes', 'users']
 * });
 */
export function useTableQuery<T = any>(
  table: string,
  options: TableQueryOptions<T> = {}
) {
  const {
    enableRealtime = true,
    additionalTables = [],
    userId,
    endpoint,
    queryKey: customQueryKey,
    ...queryOptions
  } = options;

  const queryClient = useQueryClient();

  // Build query key
  const queryKey = customQueryKey || [table, userId].filter(Boolean);

  // Build API endpoint
  const apiEndpoint = endpoint || `/${table}`;

  // Query function
  const queryFn = async (): Promise<T[]> => {
    logger.log(`üîç Fetching ${table} data from ${apiEndpoint}`);

    try {
      const response = await apiClient.get<T | T[]>(apiEndpoint);
      const responseData = response.data;

      // Handle both single object and array responses
      const data = Array.isArray(responseData) ? responseData : [responseData];
      logger.log(`‚úÖ Fetched ${data.length} ${table} records`);
      return data;
    } catch (error) {
      logger.error(`‚ùå Error fetching ${table}:`, error);
      throw error;
    }
  };

  // Set up the query
  const query = useQuery({
    queryKey,
    queryFn,
    staleTime: 0, // Always fresh for real-time updates
    refetchOnWindowFocus: false,
    ...queryOptions
  });

  // --- START OF THE FIX ---

  // This logic is now simplified and more robust. It is no longer dependent on the specific `userId`,
  // ensuring that an invalidation event from any user will correctly refresh data for all other users.
  const tableConfigs = useMemo(() => {
    const allSubscribedTables = [table, ...additionalTables];
    return allSubscribedTables.map(tableName => {
        // Define the ROOT query keys to invalidate when this table changes.
        // By invalidating the root ['requests'], TanStack Query (with exact: false)
        // will correctly invalidate both the admin's ['requests'] query and the
        // user's ['requests', 'user-id-123'] query.
        let queriesToInvalidate: string[][] = [];

        // Any change on a critical table should invalidate all 'requests' queries.
        if (tableName === 'requests' || ['quotes', 'request_notes', 'quote_attachments'].includes(tableName)) {
            queriesToInvalidate.push(['requests']); // Root for all request lists.
            queriesToInvalidate.push(['request']);  // Root for all single request detail views.
            if (userId) {
                queriesToInvalidate.push(['requests', userId]); // Specific user requests
            }
        }

        // Always invalidate the queries for the table that actually changed (e.g., ['quotes']).
        queriesToInvalidate.push([tableName]);

        // Remove duplicates just in case
        queriesToInvalidate = queriesToInvalidate.filter((arr, index, self) =>
            index === self.findIndex((t) => JSON.stringify(t) === JSON.stringify(arr))
        );

        return {
            table: tableName,
            invalidateQueries: queriesToInvalidate
        };
    });
  }, [table, additionalTables]); // IMPORTANT: The `userId` dependency has been removed.

  // The `onEvent` handler has been removed. We now rely exclusively on the `invalidateQueries`
  // array passed to the hook, creating a single, clear source of truth for real-time logic.
  useSupabaseRealtimeV3(tableConfigs, {
    enabled: enableRealtime,
  });

  // --- END OF THE FIX ---

  return {
    data: query.data || [],
    loading: query.isLoading,
    error: query.error?.message || null,
    refetch: query.refetch,
    isError: query.isError,
    isFetching: query.isFetching
  };
}

/**
 * Specialized hooks for common table patterns
 */

// Requests with related data
export function useRequestsQuery(userId?: string, options?: Omit<TableQueryOptions<any>, 'userId'>) {
  return useTableQuery('requests', {
    ...options,
    userId,
    additionalTables: ['quotes', 'request_notes', 'quote_attachments'],
    enableRealtime: true,
    queryKey: ['requests', userId].filter(Boolean)
  });
}

// Quotes for a specific request
export function useQuotesQuery(requestId: string, options?: TableQueryOptions<any>) {
  return useTableQuery('quotes', {
    ...options,
    endpoint: `/requests/${requestId}/quotes`,
    queryKey: ['quotes', requestId],
    additionalTables: ['quote_attachments', 'requests'] // Listen for request changes too
  });
}

// User profile data
export function useProfileQuery(userId: string, options?: TableQueryOptions<any>) {
  return useTableQuery('profiles', {
    ...options,
    endpoint: `/users/${userId}/profile`,
    queryKey: ['profile', userId],
    additionalTables: ['users']
  });
}

// All users (admin only)
export function useUsersQuery(options?: TableQueryOptions<any>) {
  return useTableQuery('users', {
    ...options,
    endpoint: '/admin/users',
    additionalTables: ['profiles']
  });
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/lib/apiClient.ts ---

// /lib/apiClient.ts
import axios from 'axios';
import { supabase } from './supabaseClient';
import { logger } from './logger';

const apiClient = axios.create({
  // For development, use direct backend URL
  // In production, Vite proxy handles '/api' routing
  baseURL: import.meta.env.DEV ? 'http://localhost:3000/api' : '/api',
});

// Axios interceptor to automatically add the auth token to every request
apiClient.interceptors.request.use(
  async (config) => {
    logger.log('üöÄ API Client: Interceptor triggered for:', config.url);

    try {
      logger.log('üîç API Client: Getting session...');
      const { data: { session }, error } = await supabase.auth.getSession();

      if (error) {
        logger.error('‚ùå API Client: Session retrieval error:', error);
        return config;
      }

      logger.log('üìã API Client: Session result:', {
        hasSession: !!session,
        hasAccessToken: !!session?.access_token,
        userId: session?.user?.id,
        expiresAt: session?.expires_at,
        currentTime: Math.floor(Date.now() / 1000)
      });

      if (session?.access_token) {
        logger.log('‚úÖ API Client: Adding JWT token to request');
        config.headers.Authorization = `Bearer ${session.access_token}`;
        logger.log('üì§ API Client: Headers now include:', !!config.headers.Authorization);
      } else {
        logger.warn('‚ö†Ô∏è API Client: No session or access token found - request may fail with 401');
        // Don't try to refresh here as it can cause issues
        // Let the request proceed and handle 401 errors in the response interceptor if needed
      }
    } catch (error) {
      logger.error('‚ùå API Client: Exception getting session:', error);
    }

    return config;
  },
  (error) => {
    logger.error('‚ùå API Client: Request interceptor error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor to handle 401 errors
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      logger.warn('‚ö†Ô∏è API Client: Received 401 Unauthorized - session may be expired');
      // Don't automatically retry or redirect, just log and pass the error through
      // The component can handle this appropriately
    }
    return Promise.reject(error);
  }
);

export const uploadAttachments = async (requestId: string, files: File[], quoteId?: string) => {
  const formData = new FormData();
  formData.append('request_id', requestId);
  if (quoteId) {
    formData.append('quote_id', quoteId);
  }
  files.forEach(file => {
    formData.append('attachment', file);
  });

  return apiClient.post('/requests/attachments', formData, {
    headers: { 'Content-Type': 'multipart/form-data' },
  });
};

export default apiClient;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/lib/logger.ts ---

/**
 * Centralized logging utility with environment-based control
 * Only logs when VITE_ENABLE_CONSOLE_LOGGING is set to 'true'
 */

const isLoggingEnabled = import.meta.env.VITE_ENABLE_CONSOLE_LOGGING === 'true';

export const logger = {
  log: (...args: any[]) => {
    if (isLoggingEnabled) {
      console.log(...args);
    }
  },

  error: (...args: any[]) => {
    if (isLoggingEnabled) {
      console.error(...args);
    }
  },

  warn: (...args: any[]) => {
    if (isLoggingEnabled) {
      console.warn(...args);
    }
  },

  info: (...args: any[]) => {
    if (isLoggingEnabled) {
      console.info(...args);
    }
  },

  debug: (...args: any[]) => {
    if (isLoggingEnabled) {
      console.debug(...args);
    }
  }
};

// Export individual functions for convenience
export const log = logger.log;
export const error = logger.error;
export const warn = logger.warn;
export const info = logger.info;
export const debug = logger.debug;

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/lib/serviceDefinitions.ts ---

// THE NEW SINGLE SOURCE OF TRUTH FOR ALL SERVICE DEFINITIONS

export interface ServiceDefinition {
  key: string;
  title: string;
  icon: string;
  description: string;
  features: string[];
  questions: string[];
  exampleAnswers?: string[];
  // New agent-based configuration
  agentConfig?: {
    instructions: string;
    tools?: AgentTool[];
    handoffs?: AgentHandoff[];
    outputType?: any;
  };
}

export interface AgentTool {
  name: string;
  description: string;
  parameters: any;
  execute: (input: any) => Promise<any>;
}

export interface AgentHandoff {
  name: string;
  description: string;
  agent: any; // Will be Agent instance
}

// General Plumbing Agent that can hand off to specialists
export const createGeneralPlumbingAgent = () => {
  // This will be implemented when we integrate with the OpenAI Agents SDK
  return {
    name: 'General Plumbing Assistant',
    instructions: `You are a general plumbing assistant who helps customers identify their plumbing needs and connects them with the right specialist.

Start by understanding their general issue, then hand off to the appropriate specialist agent based on their specific problem:
- Leak issues ‚Üí Leak Specialist
- Water heater problems ‚Üí Water Heater Specialist
- Drain clogs ‚Üí Drain Cleaning Specialist
- Pipe installation/repair ‚Üí Pipe Specialist

Be conversational and helpful. Ask clarifying questions when needed, but don't overwhelm with too many questions at once.`,
    handoffs: [] // Will be populated with specialist agents
  };
};

export interface GenericQuestion {
  key: string;
  question: string;
  choices?: string[];
  textarea?: boolean;
  exampleAnswer?: string;
}

export const GENERIC_QUESTIONS: GenericQuestion[] = [
  {
    key: 'property_type',
    question: 'What type of property is this service for?',
    choices: ['Residential', 'Apartment', 'Commercial', 'Other'],
    exampleAnswer: 'Residential' // Button selection
  },
  {
    key: 'is_homeowner',
    question: 'Do you own this property?',
    choices: ['Yes', 'No'],
    exampleAnswer: 'Yes' // Button selection
  },
  {
    key: 'preferred_timing',
    question: 'When would you like this service to be scheduled?',
    exampleAnswer: 'This week' // Text input
  },
];

export const services: ServiceDefinition[] = [
  {
    key: "leak_repair",
    title: "Leak Detection & Repair",
    icon: "Droplets",
    description: "Fast detection and repair of water leaks to prevent damage and save water.",
    features: ["Emergency leak repair", "Pipe inspection", "Slab leak detection"],
    questions: [
      "Where is the leak located (e.g., under a sink, in a wall/ceiling, outside)?",
      "Is water actively leaking right now, and have you been able to shut off the main water valve?",
      "How severe is the leak (e.g., slow drip, steady stream)?",
      "When did you first notice the leak?",
    ],
    exampleAnswers: [
      "Under the kitchen sink, appears to be from the supply line connection",
      "Yes, water is dripping steadily, and I've shut off the valve under the sink",
      "Slow but steady drip, about 1 drop per second",
      "I noticed it yesterday morning when I was doing dishes"
    ],
    agentConfig: {
      instructions: `You are an expert plumbing assistant specializing in leak detection and repair. Your goal is to gather all necessary information to provide an accurate quote for leak repair services.

You have access to tools to help gather information. Ask questions naturally and use the information gathering tools when appropriate.

Key information you need:
- Location of the leak (under sink, wall, ceiling, outside, etc.)
- Current leak status (active dripping, water flow stopped, etc.)
- Severity assessment (drip rate, water damage extent)
- Timeline (when noticed, how long it's been leaking)
- Property details (type, age if relevant)
- Emergency status

Be conversational but thorough. Use the available tools to validate information when possible.`,
      tools: [
        {
          name: 'assess_leak_severity',
          description: 'Assess the severity of a leak based on description',
          parameters: {
            type: 'object',
            properties: {
              leak_description: { type: 'string', description: 'Description of the leak' },
              drip_rate: { type: 'string', description: 'How fast is water dripping/leaking' }
            },
            required: ['leak_description']
          },
          execute: async (input: { leak_description: string; drip_rate?: string }) => {
            const severity = input.drip_rate?.includes('steady stream') ? 'high' :
                           input.drip_rate?.includes('drip') ? 'medium' : 'low';
            return {
              severity,
              urgency: severity === 'high' ? 'immediate' : severity === 'medium' ? 'within 24 hours' : 'schedule soon',
              estimated_cost_range: severity === 'high' ? '$200-500' : severity === 'medium' ? '$100-300' : '$50-150'
            };
          }
        },
        {
          name: 'check_emergency_status',
          description: 'Determine if a leak situation qualifies as an emergency',
          parameters: {
            type: 'object',
            properties: {
              leak_location: { type: 'string', description: 'Where the leak is located' },
              water_flow: { type: 'string', description: 'Is water actively flowing' },
              property_type: { type: 'string', description: 'Type of property' }
            },
            required: ['leak_location', 'water_flow']
          },
          execute: async (input: { leak_location: string; water_flow: string; property_type?: string }) => {
            const isEmergency = input.water_flow.includes('actively') ||
                              input.leak_location.includes('ceiling') ||
                              input.leak_location.includes('wall');
            return {
              is_emergency: isEmergency,
              recommended_response_time: isEmergency ? 'within 2 hours' : 'schedule appointment',
              reason: isEmergency ? 'Risk of significant water damage' : 'Can be scheduled normally'
            };
          }
        }
      ]
    }
  },
  {
    key: "pipe_installation",
    title: "Pipe Installation & Repiping",
    icon: "Wrench",
    description: "Professional installation and replacement for new construction or aging systems.",
    features: ["Full home repiping", "New construction plumbing", "System upgrades"],
    questions: [
        "Is this for a new construction, a renovation, or a repair of an existing pipe?",
        "What type of piping material are you considering (e.g., PEX, copper, PVC)?",
        "What is the approximate length of pipe that needs to be installed or replaced?",
    ],
  },
  {
    key: "drain_cleaning",
    title: "Drain Cleaning",
    icon: "Wind",
    description: "Clear clogged drains and prevent future blockages with our expert services.",
    features: ["Kitchen & bathroom drains", "Main line sewer cleaning", "Hydro-jetting"],
    questions: [
        "Which fixture is clogged (e.g., kitchen sink, toilet, shower)?",
        "Is the drain completely blocked or just draining slowly?",
        "Have you tried any chemical drain cleaners yourself?",
    ],
  },
  {
    key: "water_heater",
    title: "Water Heater Services",
    icon: "Thermometer",
    description: "Reliable installation and repair for tankless and traditional water heaters.",
    features: ["New installations", "24/7 emergency repairs", "Regular maintenance"],
    questions: [
      "Is your current water heater gas or electric?",
      "Are you looking to repair your existing unit or install a new one?",
      "If installing a new one, are you considering a traditional tank or a tankless system?",
    ],
    agentConfig: {
      instructions: `You are a water heater specialist. Help customers determine their water heater needs and gather information for accurate quotes.

Focus on:
- Current system assessment (gas/electric, tank/tankless, age)
- Problem diagnosis (no hot water, leaking, strange noises, etc.)
- Replacement vs repair decision
- Energy efficiency considerations
- Safety concerns (gas leaks, electrical issues)

Be knowledgeable about different water heater types and their pros/cons. Guide customers toward the best solution for their situation.`,
      tools: [
        {
          name: 'analyze_water_heater_issue',
          description: 'Analyze water heater problems and recommend solutions',
          parameters: {
            type: 'object',
            properties: {
              symptoms: { type: 'string', description: 'What problems are you experiencing' },
              system_age: { type: 'number', description: 'How old is the water heater in years' },
              system_type: { type: 'string', description: 'Gas, electric, tankless, etc.' }
            },
            required: ['symptoms']
          },
          execute: async (input: { symptoms: string; system_age?: number; system_type?: string }) => {
            const age = input.system_age || 0;
            const shouldReplace = age > 10 || input.symptoms.includes('no hot water') || input.symptoms.includes('leaking');

            return {
              recommended_action: shouldReplace ? 'replacement' : 'repair',
              estimated_cost: shouldReplace ? '$800-2500' : '$200-800',
              reasoning: shouldReplace ?
                'Age and symptoms suggest replacement is more cost-effective' :
                'Issue appears repairable for now'
            };
          }
        },
        {
          name: 'compare_heater_types',
          description: 'Compare different water heater types and recommend best option',
          parameters: {
            type: 'object',
            properties: {
              household_size: { type: 'number', description: 'Number of people in household' },
              hot_water_usage: { type: 'string', description: 'High, medium, or low usage' },
              energy_preference: { type: 'string', description: 'Gas or electric preference' }
            },
            required: ['household_size']
          },
          execute: async (input: { household_size: number; hot_water_usage?: string; energy_preference?: string }) => {
            const size = input.household_size;
            const usage = input.hot_water_usage || 'medium';

            if (size <= 2 && usage === 'low') {
              return { recommended: 'tankless', reason: 'Energy efficient for small households' };
            } else if (size <= 4) {
              return { recommended: 'hybrid_heat_pump', reason: 'Good balance of efficiency and capacity' };
            } else {
              return { recommended: 'traditional_tank', reason: 'Best capacity for larger households' };
            }
          }
        }
      ]
    }
  },
  {
    key: "fixture_install",
    title: "Fixture Repair & Installation",
    icon: "ShowerHead",
    description: "We service all types of plumbing fixtures for your home or business.",
    features: ["Faucets & sinks", "Toilets & bidets", "Showers & tubs"],
     questions: [
      "What type of fixture do you need installed or repaired (e.g., faucet, toilet, shower head)?",
      "Do you already have the new fixture, or should we supply one?",
      "Is this a simple replacement or does it require moving plumbing lines?",
    ],
  },
  {
    key: "gas_line_services",
    title: "Gas Line Services",
    icon: "Settings",
    description: "Safe and certified installation and repair of natural gas lines.",
    features: ["New appliance hookups", "Leak detection & repair", "System installations"],
    questions: [
        "Is this for a new gas line installation, an extension, or a repair?",
        "What appliance is the gas line for (e.g., BBQ, stove, fireplace)?",
        "Do you currently have natural gas service at your property?",
    ],
  },
  {
    key: "perimeter_drains",
    title: "Perimeter Drains",
    icon: "Wind", // Using the drain icon for consistency
    description: "Protect your foundation with expert installation and repair of perimeter drainage systems.",
    features: ["Camera inspection & diagnosis", "Sump pump solutions", "Foundation water-proofing"],
    questions: [
      "Have you experienced flooding or pooling water near the foundation?",
      "What is the ground surface around the foundation (e.g., grass, concrete)?",
      "Do you have a sump pump, or does the system drain to a city storm connection?",
    ],
  },
  // --- THESE CATEGORIES ARE FOR THE MODAL ONLY AND WILL NOT RENDER ON THE HOMEPAGE ---
  {
    key: "bathroom_reno",
    title: "Bathroom Renovation",
    icon: "Wrench", // Placeholder icon
    description: "Full-scale bathroom plumbing renovations.",
    features: [],
    questions: [
      "Are you changing the plumbing layout (e.g., moving the toilet, sink, or shower location)?",
      "Are you replacing the main shower/tub valve that is inside the wall?",
    ],
  },
  {
    key: "main_line_repair",
    title: "Main Line (Sewer/Water) Repair",
    icon: "Wrench", // Placeholder icon
    description: "Repair and replacement of main water and sewer lines.",
    features: [],
    questions: [
      "What issues are you experiencing (e.g., slow drains everywhere, water in the yard, backup)?",
      "Do you know the approximate age of your home?",
    ],
  },
  {
    key: "emergency_service",
    title: "Emergency Service",
    icon: "Droplets", // Placeholder icon
    description: "Urgent response for plumbing emergencies.",
    features: [],
    questions: [
      "Please describe the nature of your plumbing emergency in detail.",
      "Is water currently shut off to the affected area or the whole house?",
    ],
  },
  {
    key: "other",
    title: "Other (Describe Your Request)",
    icon: "Wrench", // Placeholder icon
    description: "For any other plumbing needs not listed.",
    features: [],
    questions: ["Please describe your plumbing request or issue in detail."],
  },
];

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/lib/statusColors.json ---

{
  "new": "#3B82F6",
  "viewed": "#8B5CF6",
  "quoted": "#8B5CF6",
  "accepted": "#10B981",
  "scheduled": "#10B981",
  "in_progress": "#F59E0B",
  "completed": "#14B8A6",
  "invoiced": "#14B8A6",
  "paid": "#22C55E",
  "overdue": "#EF4444",
  "disputed": "#EF4444",
  "cancelled": "#9E9E9E",
  "default": "#757575"
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/lib/statusColors.ts ---

// packages/frontend/src/lib/statusColors.ts

import statusColors from './statusColors.json';

// A type-safe helper for Material UI Chip component colors
type ChipColor = 'primary' | 'info' | 'warning' | 'success' | 'default' | 'error';

/**
 * Returns a Material UI Chip color that is SEMANTICALLY CONSISTENT
 * with our new color palette in statusColors.json.
 */
export const getRequestStatusChipColor = (status: string): ChipColor => {
  const colorMap: { [key: string]: ChipColor } = {
    new: 'info',          // Blue - new request
    viewed: 'primary',    // Purple - being reviewed
    quoted: 'primary',    // Purple - quote sent
    accepted: 'success',  // Green - customer accepted
    scheduled: 'success', // Green - job scheduled
    in_progress: 'warning', // Orange - work in progress
    completed: 'info',    // Teal - job done, ready for invoicing
    invoiced: 'info',     // Teal - invoice sent
    paid: 'success',      // Green - payment received
    overdue: 'error',     // Red - overdue invoice
    disputed: 'error',    // Red - disputed invoice
    cancelled: 'default', // Grey - cancelled
  };
  return colorMap[status] || 'default';
};

/**
 * Returns a Material UI Chip color for individual quote statuses.
 */
export const getQuoteStatusChipColor = (status: string): ChipColor => {
  const colorMap: { [key: string]: ChipColor } = {
    accepted: 'success',
    rejected: 'error',
    sent: 'default',
    change_order: 'warning',
  };
  return colorMap[status] || 'default';
};

/**
 * Returns a specific HEX color code directly from the JSON file.
 * This is used for the map pins, which require a direct color string.
 */
export const getRequestStatusPinColor = (status: string): string => {
  return statusColors[status as keyof typeof statusColors] || statusColors.default;
};

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/lib/supabaseClient.ts ---

import { createClient } from '@supabase/supabase-js';
import { logger } from './logger';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

logger.log('üîß SupabaseClient: Initializing client...');
logger.log('üåê Supabase URL:', supabaseUrl);
logger.log('üîë Supabase Anon Key (first 20 chars):', supabaseAnonKey?.substring(0, 20) + '...');

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  },
  realtime: {
    params: {
      eventsPerSecond: 20 // Further increased for reliable real-time updates
    },
    heartbeatIntervalMs: 15000, // Reduced to 15 seconds for better connection
    reconnectAfterMs: (tries: number) => Math.min(tries * 500, 10000) // Faster reconnection
  }
});

logger.log('‚úÖ SupabaseClient: Client initialized successfully');

--- END OF FILE ---

--- START OF FILE ./packages/frontend/src/main.tsx ---

// packages/frontend/src/main.tsx

import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import { HelmetProvider, Helmet } from 'react-helmet-async';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AuthProvider, useAuth } from './features/auth/AuthContext';
import AuthModal from './features/auth/components/AuthModal';
import QuoteAgentModal from './features/requests/components/QuoteAgentModal';
import ServicesSection from './features/landing/components/ServicesSection';
import ReviewsSection from './features/landing/components/ReviewsSection';
import AboutSection from './features/landing/components/AboutSection';
import ContactSection from './features/landing/components/ContactSection';
import UserMenu from './features/auth/components/UserMenu';
import ProfileModal from './features/profile/components/ProfileModal';
import Dashboard from './features/requests/components/Dashboard';
import MyRequests from './features/requests/components/MyRequests';
import { QuoteRequest } from './features/requests/types';
import { ServiceDefinition } from './lib/serviceDefinitions';
import ServiceDetailPage from './features/services/ServiceDetailPage';
import { useUserRequests, useAllRequests, useRequestById } from './hooks'; // New standardized hooks
import {
  Phone,
  Wrench,
  CheckCircle,
  Menu,
  X
} from 'lucide-react';

import { logger } from './lib/logger';

const AppContent: React.FC = () => {
  logger.log('üî• AppContent component RENDERED - Testing webhook after reconnection');
  const { user, profile, profileIncomplete, refreshProfile, loading: authLoading } = useAuth();

  // THE FIX: This logic is now robust.
  // 1. We check if a profile exists and if the role is 'admin'.
  // 2. If it's an admin, userIdForQuery is `undefined` (fetch all).
  // 3. Otherwise, it's a regular user, so we MUST pass their `user.id`.
  const userIdForQuery = profile && profile.role === 'admin' ? undefined : user?.id;

  logger.log('üîç User authentication check:', {
    userId: user?.id,
    profileRole: profile?.role,
    isAdmin: profile?.role === 'admin',
    userIdForQuery: userIdForQuery,
    profileExists: !!profile,
    authLoading,
    enabled: !authLoading && !!user
  });

  // Use the appropriate hook based on user role
  const isAdmin = profile?.role === 'admin';
  const userRequestsHook = useUserRequests(user?.id || '');
  const allRequestsHook = useAllRequests();

  // Select the appropriate hook result
  const { data: requests, loading, error, refetch } = isAdmin ? allRequestsHook : userRequestsHook;

  logger.log('üîç useUserRequests/useAllRequests result:', {
    requestsLength: requests?.length,
    loading,
    error,
    hasRefetch: !!refetch,
    isAdmin
  });

  // Log when requests data changes
  useEffect(() => {
    logger.log('üì° Main.tsx requests updated:', {
      count: requests?.length,
      statuses: requests?.map(r => ({ id: r.id, status: r.status })),
      hasQuotes: requests?.map(r => ({ id: r.id, quoteCount: r.quotes?.length || 0 }))
    });
  }, [requests]);

  // Real-time sync is now handled by individual hooks (useTableQuery, etc.)


  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [showAgentModal, setShowAgentModal] = useState(false);
  const [showProfileModal, setShowProfileModal] = useState(false);
  const [preselectedService, setPreselectedService] = useState<string | null>(null);
  const [route, setRoute] = useState(window.location.hash);
  const prevRouteRef = React.useRef<string | null>(null);

  useEffect(() => {
    const handleHashChange = () => {
      prevRouteRef.current = route; // store previous route
      setRoute(window.location.hash);
    };
    window.addEventListener('hashchange', handleHashChange);
    return () => {
      window.removeEventListener('hashchange', handleHashChange);
    };
  }, []);

  const handleOpenQuoteModal = () => {
    if (!user) {
      setShowAuthModal(true);
    } else if (profileIncomplete) {
      setShowProfileModal(true);
    } else {
      setShowAgentModal(true);
    }
  };

  const handleServiceSelect = (service: ServiceDefinition) => {
    logger.log(`Service selected: ${service.title}`);
    setPreselectedService(service.key);
    handleOpenQuoteModal(); // Reuse the existing function to open the modal
  };

  // *** THE FIX: This callback now has access to the central refresh function. ***
  const handleNewRequestSuccess = () => {
    logger.log("New request submitted. Triggering a manual refresh and redirecting to dashboard.");
    refetch();
    // Redirect to dashboard after successful quote submission
    setRoute('#/dashboard');
  };
  const renderContent = () => {
    // Check for a service page route, e.g., #/services/leak_repair
    if (route.startsWith('#/services/')) {
      const serviceKey = route.split('/')[2];
      return <ServiceDetailPage serviceKey={serviceKey} />;
    }

    // Direct request view: #/requests/<id>
    if (route.startsWith('#/requests/')) {
      const requestId = route.split('/')[2];

      // Always render the dashboard as the base and open the RequestDetailModal as an overlay.
      // The Dashboard component will handle access control (admin-only) and will render
      // MyRequests for non-admins if desired.
      const DashboardWithModal = () => (
        <>
          {isAdmin ? (
            <Dashboard requests={requests} loading={loading} error={error} refreshRequests={refetch} />
          ) : (
            <MyRequests requests={requests} loading={loading} error={error} refreshRequests={refetch} />
          )}
          <React.Suspense fallback={<div className="p-8 text-center">Loading request...</div>}>
            <RequestDetailModalLoader requestId={requestId} />
          </React.Suspense>
        </>
      );

      return <DashboardWithModal />;
    }

    // THE CORE CHANGE: The /dashboard route now handles BOTH user roles.
    if (route === '#/dashboard') {
      if (authLoading) {
        return <div className="text-center p-8"><p>Loading Dashboard...</p></div>;
      }
      if (!user) {
        // If not logged in, show a message and prompt to sign in.
        return (
          <div className="text-center p-8 max-w-lg mx-auto">
            <h2 className="text-2xl font-bold mb-4">Access Your Portal</h2>
            <p className="mb-6">Please sign in to view your quote requests or manage your business dashboard.</p>
            <button onClick={() => setShowAuthModal(true)} className="bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-700">
              Sign In
            </button>
          </div>
        );
      }
      // If user is logged in, decide which dashboard to show based on role.
      return isAdmin ? (
        <Dashboard requests={requests} loading={loading} error={error} refreshRequests={refetch} />
      ) : (
        <MyRequests requests={requests} loading={loading} error={error} refreshRequests={refetch} />
      );
    }

    // Default to the home page content
    return (
      <>
        <Helmet>
          <title>AquaFlow Plumbing | 24/7 Emergency Plumber in Victoria, BC</title>
          <meta name="description" content="Trusted, licensed plumbers in Victoria, BC. We offer 24/7 emergency services, drain cleaning, and leak repairs. Call AquaFlow for a fast, professional quote today!" />
          <script type="application/ld+json">
            {JSON.stringify({
              "@context": "https://schema.org",
              "@type": "Plumber",
              "name": "AquaFlow Plumbing",
              "image": `${window.location.origin}/plumber.jpg`,
              "@id": window.location.origin,
              "url": window.location.origin,
              "telephone": "(555) 123-4567",
              "priceRange": "$$",
              "address": {
                "@type": "PostalAddress",
                "streetAddress": "123 Main Street",
                "addressLocality": "Victoria",
                "addressRegion": "BC",
                "postalCode": "V8W 1A1",
                "addressCountry": "CA"
              },
              "geo": {
                "@type": "GeoCoordinates",
                "latitude": 48.4284,
                "longitude": -123.3656
              },
              "openingHoursSpecification": {
                "@type": "OpeningHoursSpecification",
                "dayOfWeek": [
                  "Monday",
                  "Tuesday",
                  "Wednesday",
                  "Thursday",
                  "Friday",
                  "Saturday",
                  "Sunday"
                ],
                "opens": "00:00",
                "closes": "23:59"
              },
              "sameAs": [
                "https://www.facebook.com/your-plumbing-page",
                "https://www.instagram.com/your-plumbing-page"
              ],
              "areaServed": {
                "@type": "GeoCircle",
                "geoMidpoint": {
                  "@type": "GeoCoordinates",
                  "latitude": 48.4284,
                  "longitude": -123.3656
                },
                "geoRadius": "30000"
              }
            })}
          </script>
        </Helmet>

        {user && profileIncomplete && (
          <div className="bg-amber-50 border-l-4 border-amber-400 p-4 mb-4">
            <div className="flex items-center justify-between">
              <div className="ml-3">
                <p className="text-sm text-amber-800">
                  Welcome! To request a quote, please complete your profile first.
                </p>
              </div>
              <div className="ml-auto pl-3">
                <div className="-mx-1.5 -my-1.5">
                  <button
                    onClick={() => setShowProfileModal(true)}
                    className="bg-amber-50 px-3 py-2 rounded-md text-sm font-medium text-amber-800 hover:bg-amber-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-amber-50 focus:ring-amber-600"
                  >
                    Complete Profile
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        <section className="relative pt-12 pb-20 text-white overflow-hidden">
          {/* Aurora Gradient Background */}
          <div className="absolute inset-0 bg-gradient-to-br from-blue-600 via-purple-600 to-blue-800"></div>
          <div className="absolute inset-0 bg-gradient-to-t from-blue-900/50 via-transparent to-purple-500/30"></div>
          <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-blue-400/20 via-transparent to-transparent"></div>

          <div className="relative max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 grid lg:grid-cols-2 gap-12 items-center">
            <div className="animate-fade-in-up">
              <h1 className="text-5xl font-bold leading-tight mb-6 bg-gradient-to-r from-white to-blue-100 bg-clip-text text-transparent">
                Professional Plumbing Services You Can Trust
              </h1>
              <p className="text-xl text-blue-100 mb-8 leading-relaxed">
                24/7 emergency service, licensed professionals, and guaranteed satisfaction. Serving your community for over 15 years.
              </p>
              <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                <button
                  className="group bg-white text-blue-600 px-8 py-4 rounded-lg font-semibold hover:bg-blue-50 hover:scale-105 hover:shadow-xl transition-all duration-300 text-lg shadow-lg"
                  onClick={handleOpenQuoteModal}
                >
                  <span className="group-hover:scale-105 transition-transform duration-300 inline-block">Request a Quote</span>
                </button>
                <a
                  href="tel:555-123-4567"
                  className="group border-2 border-white text-white px-8 py-4 rounded-lg font-semibold hover:bg-white hover:text-blue-600 hover:scale-105 transition-all duration-300 text-lg flex items-center justify-center space-x-2 shadow-lg"
                >
                  <Phone className="w-5 h-5 group-hover:scale-110 transition-transform duration-300" />
                  <span>Call Now</span>
                </a>
              </div>
            </div>
            <div className="relative flex justify-center lg:justify-end animate-fade-in-up animation-delay-200">
              <div className="relative">
                <img
                  src="/plumber.jpg"
                  alt="Licensed AquaFlow plumber repairing a kitchen sink in a Victoria, BC home"
                  className="rounded-lg shadow-2xl w-full max-w-md object-cover hover:scale-105 transition-transform duration-500"
                />
                <div className="absolute -bottom-8 left-8 bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300 animate-bounce-in animation-delay-500">
                  <div className="bg-green-100 p-3 rounded-full inline-flex items-center justify-center mb-2">
                    <CheckCircle className="w-6 h-6 text-green-600" />
                  </div>
                  <div>
                    <div className="font-semibold text-gray-900">Licensed & Insured</div>
                    <div className="text-gray-600 text-sm">Fully certified professionals</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Custom CSS for animations */}
          <style>{`
            @keyframes fade-in-up {
              from {
                opacity: 0;
                transform: translateY(30px);
              }
              to {
                opacity: 1;
                transform: translateY(0);
              }
            }
            @keyframes bounce-in {
              0% {
                opacity: 0;
                transform: scale(0.3);
              }
              50% {
                opacity: 1;
                transform: scale(1.05);
              }
              70% {
                transform: scale(0.9);
              }
              100% {
                opacity: 1;
                transform: scale(1);
              }
            }
            .animate-fade-in-up {
              animation: fade-in-up 0.8s ease-out forwards;
            }
            .animation-delay-200 {
              animation-delay: 0.2s;
            }
            .animation-delay-500 {
              animation-delay: 0.5s;
            }
            .animate-bounce-in {
              animation: bounce-in 0.8s ease-out forwards;
            }
          `}</style>
        </section>

        <ServicesSection onServiceSelect={handleServiceSelect} />
        <AboutSection />
        <ReviewsSection />
        <ContactSection />
      </>
    );
  };

  // Loader component: fetch request by id and render the existing RequestDetailModal
  const RequestDetailModalLoader: React.FC<{ requestId: string }> = ({ requestId }) => {
    const { data: requestArray, loading: requestLoading, error: requestError, refetch: refetchRequest } = useRequestById(requestId || '', { enabled: !!requestId });
    const request = requestArray?.[0] || null;
    const [isOpen, setIsOpen] = useState(true);

    const RequestDetailModal = React.lazy(() => import('./features/requests/components/RequestDetailModal'));

    const handleClose = () => {
      setIsOpen(false);
      // Navigate back to dashboard state when modal closes
      setTimeout(() => setRoute('#/dashboard'), 0);
      // Refresh the main requests list
      refetch();
    };

    if (requestLoading && !request) return <div className="p-8 text-center">Loading request...</div>;
    if (requestError) return <div className="p-8 text-center text-red-600">Failed to load request.</div>;
    if (!request) return null;

    return (
      <React.Suspense fallback={<div className="p-8 text-center">Loading request...</div>}>
        <RequestDetailModal isOpen={isOpen} onClose={handleClose} request={request} onUpdateRequest={() => { if (refetchRequest) refetchRequest(); }} />
      </React.Suspense>
    );
  };


  return (
    <React.Fragment>
      <div className="min-h-screen flex flex-col bg-gray-100">
        <header className="fixed top-0 left-0 w-full bg-white shadow z-40">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex items-center justify-between h-20">
            <a href="/#" className="flex items-center space-x-4">
              <Wrench className="w-8 h-8 text-blue-600" />
              <span className="text-2xl font-bold text-gray-900">AquaFlow Plumbing</span>
            </a>
            <nav className="hidden md:flex items-center space-x-6">
              <a href="/#services" className="text-gray-700 hover:text-blue-600 transition-colors">Services</a>
              <a href="/#about" className="text-gray-700 hover:text-blue-600 transition-colors">About</a>
              <a href="/#testimonials" className="text-gray-700 hover:text-blue-600 transition-colors">Reviews</a>
              <a href="/#contact" className="text-gray-700 hover:text-blue-600 transition-colors">Contact</a>
              <button
                onClick={handleOpenQuoteModal}
                className="bg-gray-100 text-blue-600 px-4 py-2 rounded-lg hover:bg-gray-200 transition-colors font-semibold"
              >
                Request a Quote
              </button>
              <a href="tel:555-123-4567" className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center space-x-2">
                <Phone className="w-4 h-4" />
                <span>Call Now</span>
              </a>
              {user ? (
                <UserMenu
                  onOpenProfile={() => setShowProfileModal(true)}
                  onNavigateToDashboard={() => {
                    logger.log('üöÄ Desktop UserMenu: Navigating to dashboard');
                    setRoute('#/dashboard');
                    logger.log('‚úÖ Desktop UserMenu: Route set to:', '#/dashboard');
                  }}
                />
              ) : (
                <button
                  className="bg-gray-900 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors flex items-center space-x-2 ml-2"
                  onClick={() => setShowAuthModal(true)}
                >
                  <span>Sign In</span>
                </button>
              )}
            </nav>
            <button
              onClick={() => setIsMenuOpen(!isMenuOpen)}
              className="md:hidden p-2 text-gray-700"
            >
              {isMenuOpen ? <X className="w-6 h-6" /> : <Menu className="w-6 h-6" />}
            </button>
          </div>
        </header>

        {/* Mobile Navigation Menu */}
        {isMenuOpen && (
          <div className="md:hidden fixed inset-0 z-30 bg-white flex flex-col items-center justify-center">
            <nav className="flex flex-col items-center space-y-6 text-xl">
              <a href="/#services" className="text-gray-700 hover:text-blue-600" onClick={() => setIsMenuOpen(false)}>Services</a>
              <a href="/#about" className="text-gray-700 hover:text-blue-600" onClick={() => setIsMenuOpen(false)}>About</a>
              <a href="/#testimonials" className="text-gray-700 hover:text-blue-600" onClick={() => setIsMenuOpen(false)}>Reviews</a>
              <a href="/#contact" className="text-gray-700 hover:text-blue-600" onClick={() => setIsMenuOpen(false)}>Contact</a>
              <button
                onClick={() => {
                  handleOpenQuoteModal();
                  setIsMenuOpen(false);
                }}
                className="bg-gray-900 text-white px-6 py-3 rounded-lg hover:bg-gray-700 w-full max-w-xs justify-center"
              >
                Request a Quote
              </button>
              <a href="tel:555-123-4567" className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 flex items-center space-x-2" onClick={() => setIsMenuOpen(false)}>
                <Phone className="w-5 h-5" />
                <span>Call Now</span>
              </a>

              {/* Authentication Section */}
              <div className="pt-6 border-t border-gray-200 w-full flex flex-col items-center space-y-4">
                {user ? (
                  <div className="w-full max-w-xs">
                    <UserMenu
                      onOpenProfile={() => {
                        setShowProfileModal(true);
                        setIsMenuOpen(false);
                      }}
                      onNavigateToDashboard={() => {
                        logger.log('üöÄ UserMenu: Navigating to dashboard');
                        // Navigate to dashboard and close mobile menu
                        setRoute('#/dashboard');
                        setIsMenuOpen(false);
                        logger.log('‚úÖ UserMenu: Route set to:', '#/dashboard');
                      }}
                    />
                  </div>
                ) : (
                  <button
                    className="bg-gray-900 text-white px-6 py-3 rounded-lg hover:bg-gray-700 flex items-center space-x-2 w-full max-w-xs justify-center"
                    onClick={() => {
                      setShowAuthModal(true);
                      setIsMenuOpen(false);
                    }}
                  >
                    <span>Sign In</span>
                  </button>
                )}
              </div>
            </nav>
          </div>
        )}

        <main className="pt-20 flex-grow">
          {renderContent()}
        </main>

        {user && !profileIncomplete && (
          <QuoteAgentModal
            isOpen={showAgentModal}
            onClose={() => {
              setShowAgentModal(false);
              setPreselectedService(null); // Clear the pre-selection when closing
            }}
            onSubmissionSuccess={handleNewRequestSuccess}
            preselectedService={preselectedService}
          />
        )}

        <footer className="bg-black text-white py-8">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex flex-col md:flex-row justify-between items-center">
            <div className="flex items-center space-x-2 mb-4 md:mb-0">
              <Wrench className="w-6 h-6 text-blue-400" />
              <span className="text-xl font-bold">AquaFlow Plumbing</span>
            </div>
            <div className="text-gray-400 text-center md:text-right">
              <p>&copy; 2025 AquaFlow Plumbing. All rights reserved.</p>
              <p className="text-sm">Licensed ‚Ä¢ Insured ‚Ä¢ Trusted</p>
            </div>
          </div>
        </footer>

        {route !== '#/dashboard' && (
            <a
                href="tel:555-123-4567"
                className="fixed bottom-6 right-6 z-50 bg-red-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-red-700 transition-colors inline-flex items-center space-x-2 shadow-lg"
            >
                <Phone className="w-5 h-5" />
                <span>Emergency Line</span>
            </a>
        )}
      </div>

      {!user && <AuthModal isOpen={showAuthModal} onClose={() => setShowAuthModal(false)} />}

      {user && showProfileModal && (
        <ProfileModal
          isClosable={true}
          onClose={() => setShowProfileModal(false)}
          onComplete={() => {
            refreshProfile();
            setShowProfileModal(false);
          }}
        />
      )}

    </React.Fragment>
  );
};

const queryClient = new QueryClient();

const App: React.FC = () => {
    return (
        <QueryClientProvider client={queryClient}>
            <AuthProvider>
                <AppContent />
            </AuthProvider>
        </QueryClientProvider>
    )
}

const root = document.getElementById('root');
if (root) {
  ReactDOM.createRoot(root).render(
    <HelmetProvider>
      <App />
    </HelmetProvider>
  );
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,

    /* Vite */
    "types": ["vite/client"]
  },
  "include": ["src"]
}

--- END OF FILE ---

--- START OF FILE ./packages/frontend/vite.config.js ---

import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path'; // Import path module

export default defineConfig(({ mode }) => {
  // Load environment variables from .env file based on the current mode
  const env = loadEnv(mode, path.resolve(process.cwd(), '..', '..'), ''); // Load from project root

  // Check if we're running under Netlify dev (which handles API routing itself)
  const isNetlifyDev = process.env.NETLIFY_DEV || process.env.NETLIFY;

  return {
    plugins: [react()],
    server: {
      proxy: isNetlifyDev ? undefined : {
        '/api': {
          target: (env.VITE_BACKEND_BASE_URL || 'http://localhost:3000').replace(/\/$/, ''),
          changeOrigin: true,
          secure: false
        }
      }
    }
  };
});

--- END OF FILE ---

--- START OF FILE ./scripts/setup-git-hooks.sh ---

#!/usr/bin/env bash
set -euo pipefail

REPO_ROOT=$(cd "$(dirname "$0")/.." && pwd)

echo "Setting git hooks path to ${REPO_ROOT}/.githooks"
git config core.hooksPath ".githooks"

echo "Done. Pre-commit hooks will run on your next commit.

--- END OF FILE ---

--- START OF FILE ./shutdown.sh ---

#!/bin/bash
# Shutdown script for PlumbingPOC: stops backend and frontend processes and closes terminal windows

# Load environment variables from .env if it exists
if [ -f ".env" ]; then
    set -a
    source .env
    set +a
fi

# Configurable ports (loaded from .env or defaults)
BACKEND_PORT=${BACKEND_PORT:-3000}
FRONTEND_PORT=${FRONTEND_PORT:-5173}

echo -e "\033[0;31müõë\033[0m Stopping PlumbingPOC services..."
echo -e "\033[0;31m‚ïê‚ïê‚ïê\033[0m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# Kill processes on the ports
echo -e "\033[0;33m‚ö°\033[0m Killing processes on ports $BACKEND_PORT and $FRONTEND_PORT..."
kill $(lsof -t -i:$BACKEND_PORT) $(lsof -t -i:$FRONTEND_PORT) 2>/dev/null || echo -e "\033[0;32m‚úì\033[0m No processes found on specified ports"

# Kill npm processes
echo -e "\033[0;33m‚ö°\033[0m Killing npm and node processes..."
pkill -f "npm run dev" 2>/dev/null || true
pkill -f "vite" 2>/dev/null || true
pkill -f "node packages/backend/api/server.js" 2>/dev/null || true

# Close Terminal windows that contain the specific processes
echo -e "\033[0;33m‚ö°\033[0m Closing associated Terminal windows..."
osascript -e '
tell application "Terminal"
    set windowList to windows
    repeat with aWindow in windowList
        try
            set tabList to tabs of aWindow
            repeat with aTab in tabList
                set tabProcesses to processes of aTab
                repeat with aProcess in tabProcesses
                    if aProcess contains "node api/server.js" or aProcess contains "npm run dev" or aProcess contains "vite" or aProcess contains "startup.sh" then
                        tell aTab to close
                        exit repeat
                    end if
                end repeat
            end repeat
        end try
    end repeat
end tell
' 2>/dev/null || echo -e "\033[0;32m‚úì\033[0m Terminal cleanup completed"

echo "Shutdown complete."

--- END OF FILE ---

--- START OF FILE ./startup.sh ---

#!/bin/bash
# Startup script for PlumbingPOC: starts both frontend and backend services
# Usage: ./startup.sh [--help]
#   --help: Show this help message

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Load environment variables from .env if it exists
if [ -f ".env" ]; then
    set -a
    source .env
    set +a
    echo -e "${BLUE}‚úì${NC} Loaded environment variables from .env"
else
    echo -e "${YELLOW}‚ö†${NC} No .env file found, using default values"
fi

# Configurable ports
BACKEND_PORT=${BACKEND_PORT:-3000}
FRONTEND_PORT=${FRONTEND_PORT:-5173}

# Parse command line arguments
USE_NETLIFY=false
if [[ "$1" == "--netlify" ]]; then
    USE_NETLIFY=true
    echo -e "${BLUE}‚Ñπ${NC} Using Netlify Dev mode (includes SMS function support)"
elif [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "PlumbingPOC Development Startup Script"
    echo "Starts both frontend (Vite) and backend (ESM Node.js) services"
    echo ""
    echo "Options:"
    echo "  --netlify    Use netlify dev for full environment (includes functions for SMS testing)"
    echo "  --help, -h   Show this help message"
    echo ""
    echo "Services:"
    echo "  Frontend: http://localhost:$FRONTEND_PORT (Vite dev server)"
    echo "  Backend:  http://localhost:$BACKEND_PORT (Pure ESM API)"
    if command -v netlify &> /dev/null; then
        echo "  Netlify:  Usually http://localhost:8888 (when using --netlify)"
    fi
    echo ""
    echo "Environment Variables:"
    echo "  BACKEND_PORT   Backend server port (default: 3000)"
    echo "  FRONTEND_PORT  Frontend dev server port (default: 5173)"
    echo ""
    exit 0
fi

echo -e "${BLUE}üöÄ${NC} Starting PlumbingPOC Development Environment"
echo -e "${BLUE}‚ïê‚ïê‚ïê${NC}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo ""

# Function to check if port is in use
is_port_in_use() {
    lsof -i :$1 >/dev/null 2>&1
}

# Function to kill process on port
kill_port() {
    local port=$1
    local pid=$(lsof -t -i:$port 2>/dev/null || echo "")
    if [ ! -z "$pid" ]; then
        echo -e "${YELLOW}‚ö°${NC} Killing process on port $port (PID: $pid)"
        kill $pid 2>/dev/null || true
        sleep 2
    fi
}

# Function to wait for service to be ready
wait_for_service() {
    local port=$1
    local service_name=$2
    local max_attempts=30
    local attempt=1

    echo -e "${BLUE}‚è≥${NC} Waiting for $service_name to be ready on port $port..."

    while [ $attempt -le $max_attempts ]; do
        if curl -s http://localhost:$port >/dev/null 2>&1; then
            echo -e "${GREEN}‚úì${NC} $service_name is ready on port $port"
            return 0
        fi
        echo -e "${BLUE}‚ãØ${NC} Attempt $attempt/$max_attempts - $service_name not ready yet..."
        sleep 2
        ((attempt++))
    done

    echo -e "${RED}‚úó${NC} $service_name failed to start within $(($max_attempts * 2)) seconds"
    return 1
}

# Clean up any existing processes
echo -e "${YELLOW}üßπ${NC} Cleaning up existing processes..."
kill_port $BACKEND_PORT
kill_port $FRONTEND_PORT

# Kill any existing npm processes
pkill -f "npm run dev" 2>/dev/null || true
pkill -f "vite" 2>/dev/null || true
pkill -f "node api/server.js" 2>/dev/null || true
sleep 3

# Verify ports are free
if is_port_in_use $BACKEND_PORT; then
    echo -e "${RED}‚úó${NC} Port $BACKEND_PORT is still in use. Please free it manually."
    exit 1
fi

if is_port_in_use $FRONTEND_PORT; then
    echo -e "${RED}‚úó${NC} Port $FRONTEND_PORT is still in use. Please free it manually."
    exit 1
fi

if [[ "$USE_NETLIFY" == true ]]; then
    # Netlify Dev mode - runs all services with Netlify for SMS testing
    echo -e "${BLUE}üöÄ${NC} Starting with Netlify Dev mode..."
    echo -e "${BLUE}‚ïê‚ïê‚ïê${NC}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

    # Kill any existing processes
    pkill -f "netlify dev" 2>/dev/null || true
    kill_port $BACKEND_PORT
    kill_port $FRONTEND_PORT
    sleep 3

    # Check if Netlify CLI is available
    if ! command -v netlify &> /dev/null; then
        echo -e "${RED}‚úó${NC} Netlify CLI not found. Install with: npm install -g netlify-cli"
        exit 1
    fi

    # Start Netlify dev (this will handle both frontend and backend routing)
    echo -e "${BLUE}‚è≥${NC} Starting Netlify Dev..."
    npx netlify dev &
    NETLIFY_PID=$!

    # Wait for Netlify to be ready
    sleep 10

    # Check if Netlify started successfully
    if ! kill -0 $NETLIFY_PID 2>/dev/null; then
        echo -e "${RED}‚úó${NC} Netlify Dev failed to start"
        exit 1
    fi

    echo ""
    echo -e "${GREEN}üéâ${NC} Netlify Dev started successfully!"
    echo -e "${GREEN}‚ïê‚ïê‚ïê${NC}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo -e "${GREEN}‚úì${NC} Netlify Dev: Check terminal output for port (usually 8888)"
    echo -e "${GREEN}‚úì${NC} SMS functions: Available for testing"
    echo ""
    echo -e "${BLUE}‚Ñπ${NC}  Netlify Dev is running in the background (PID: $NETLIFY_PID)"
    echo -e "${BLUE}‚Ñπ${NC}  Press Ctrl+C to stop Netlify Dev"
    echo ""

    # Wait for the Netlify process
    wait $NETLIFY_PID

else
    # Standard mode - unified frontend/backend startup
    echo -e "${GREEN}‚úì${NC} Ports $BACKEND_PORT and $FRONTEND_PORT are free"
    echo ""

    # Start the development environment
    echo -e "${BLUE}üöÄ${NC} Starting development services..."
    echo -e "${BLUE}‚ïê‚ïê‚ïê${NC}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

    # Start both services using npm-run-all
    echo -e "${BLUE}‚è≥${NC} Starting both frontend and backend services..."
    BACKEND_PORT=$BACKEND_PORT FRONTEND_PORT=$FRONTEND_PORT npm run dev &
    DEV_PID=$!

    # Wait a moment for services to start
    sleep 5

    # Check if the process is still running
    if ! kill -0 $DEV_PID 2>/dev/null; then
        echo -e "${RED}‚úó${NC} Development services failed to start"
        exit 1
    fi

    # Wait for backend to be ready
    if wait_for_service $BACKEND_PORT "Backend API"; then
        echo -e "${GREEN}‚úì${NC} Backend API: http://localhost:$BACKEND_PORT"
    else
        echo -e "${RED}‚úó${NC} Backend API failed to start properly"
        kill $DEV_PID 2>/dev/null || true
        exit 1
    fi

    # Wait for frontend to be ready
    if wait_for_service $FRONTEND_PORT "Frontend (Vite)"; then
        echo -e "${GREEN}‚úì${NC} Frontend: http://localhost:$FRONTEND_PORT"
    else
        echo -e "${RED}‚úó${NC} Frontend failed to start properly"
        kill $DEV_PID 2>/dev/null || true
        exit 1
    fi

    echo ""
    echo -e "${GREEN}üéâ${NC} All services started successfully!"
    echo -e "${GREEN}‚ïê‚ïê‚ïê${NC}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo -e "${GREEN}‚úì${NC} Frontend (Vite): http://localhost:$FRONTEND_PORT"
    echo -e "${GREEN}‚úì${NC} Backend (ESM):   http://localhost:$BACKEND_PORT"
    echo ""
    echo -e "${BLUE}‚Ñπ${NC}  Services are running in the foreground"
    echo -e "${BLUE}‚Ñπ${NC}  Press Ctrl+C to stop all services"
    echo ""

    # Wait for the process
    wait $DEV_PID
fi

--- END OF FILE ---

--- START OF FILE ./supabase/DeployingGeocodeInSupabase.md ---

# Deploying geocode for google in supabase
open cli in terminal
1. supabase login
2. supabase link
3. supabase functions deploy geocode
will say something like
Deployed Functions on project oxoiwzijacglgueemlva: geocode
You can inspect your deployment in the Dashboard: https://supabase.com/dashboard/project/.../functions

4. Set Google Maps API Key in Supabase Secrets
You need to add your Google Maps API key to Supabase secrets. You can do this through the Supabase Dashboard:
Go to your project dashboard
Navigate to Settings ‚Üí Edge Functions
Navigate to function secrets
https://supabase.com/dashboard/project/..../functions/secrets
Add a new secret:

5. create the external function in supabase.
code for function see supabase/supabase/functions/index.ts
call function "geocode"
note can delete with "supabase functions delete geocode" in cli
note can test new function in gui.
Go to your Supabase Dashboard: https://supabase.com/dashboard/project/.../functions
{
  "requestId": "0c4714f8-df2e-41f1-9f60-615b78613cb6"
} gives result {
  "success": true,
  "latitude": 48.4863665,
  "longitude": -123.3338452,
  "geocoded_address": "Victoria, BC V8N 2L4, Canada"
}

note can test new function via CLI curl command.
curl -X POST 'https://oxoiwzijacglgueemlva.supabase.co/functions/v1/geocode' \
  -H 'Authorization: Bearer $SUPABASE_ANON_KEY' \
  -H 'Content-Type: application/json' \
  -d '{"requestId": "d1fde28a-2742-4c3a-8678-ee1e2143c713"}'

verify was updated coordinates in supabase from the function call

SELECT id, service_address, latitude, longitude, geocoded_address
FROM requests
WHERE id = '0c4714f8-df2e-41f1-9f60-615b78613cb6';

should give something like

[
  {
    "id": "0c4714f8-df2e-41f1-9f60-615b78613cb6",
    "service_address": "1555 San Jan St, Saanich, BC V8N-2L4",
    "latitude": 48.4863665,
    "longitude": -123.3338452,
    "geocoded_address": "Victoria, BC V8N 2L4, Canada"
  }
]



6. run this sql in supabase.  enable http extension for sql batch processing
to update all the existing client coordinates from google geo api.

-- Enable http extension
CREATE EXTENSION IF NOT EXISTS http;

-- Geocode all requests without coordinates
DO $$
DECLARE
    current_id TEXT;
    service_role_key TEXT := '$SUPABASE_SERVICE_ROLE_KEY'; -- Replace with your actual service role key or use env var
BEGIN
    FOR current_id IN
        SELECT id FROM requests
        WHERE latitude IS NULL OR longitude IS NULL
        ORDER BY created_at DESC -- Process newest first
    LOOP
        -- Call geocoding function (ignore response to avoid field errors)
        PERFORM http((
            'POST',
            'https://...supabase.co/functions/v1/geocode',
            ARRAY[
                http_header('Authorization', 'Bearer ' || service_role_key),
                http_header('Content-Type', 'application/json')
            ],
            'application/json',
            json_build_object('requestId', current_id)::text
        ));

        RAISE NOTICE 'Processed request %', current_id;
        PERFORM pg_sleep(0.2); -- Rate limiting to avoid overwhelming the API
    END LOOP;

    RAISE NOTICE 'Geocoding batch complete!';
END $$;

-- Alternative: Process in smaller batches for testing
DO $$
DECLARE
    current_id TEXT;
    service_role_key TEXT := '$SUPABASE_SERVICE_ROLE_KEY'; -- Replace with your actual service role key or use env var
    counter INTEGER := 0;
BEGIN
    FOR current_id IN
        SELECT id FROM requests
        WHERE latitude IS NULL OR longitude IS NULL
        ORDER BY created_at DESC
        LIMIT 10 -- Process only 10 at a time for testing
    LOOP
        PERFORM http((
            'POST',
            'https://oxoiwzijacglgueemlva.supabase.co/functions/v1/geocode',
            ARRAY[
                http_header('Authorization', 'Bearer ' || service_role_key),
                http_header('Content-Type', 'application/json')
            ],
            'application/json',
            json_build_object('requestId', current_id)::text
        ));

        counter := counter + 1;
        RAISE NOTICE 'Processed % requests', counter;
        PERFORM pg_sleep(0.2);
    END LOOP;
END $$;

7. run this sql to geocode user profiles (not requests)
-- Enable http extension for API calls
CREATE EXTENSION IF NOT EXISTS http;

-- Geocode specific user profiles from your list
DO $$
DECLARE
    current_id TEXT;
    service_role_key TEXT := '$SUPABASE_SERVICE_ROLE_KEY'; -- Replace with your actual service role key
    profile_ids TEXT[] := ARRAY[
        'd835339e-3752-4721-b0c8-e502c7986625',
        'c544f7e9-6f7c-40d6-a499-2430716e33ce',
        '55aea5b6-7bd5-4b10-8f37-229ac912e47f',
        '142ca005-d98e-4694-a78d-ad711456cd9a',
        'd8d2fc88-1a21-4b3b-9357-73a3f3ea0be0',
        'd3d63f36-2c01-42f4-9522-081d8df4cc98',
        'c3b0be81-e8be-44f5-856f-c85522ced738'
    ];
    i INTEGER := 1;
BEGIN
    -- Loop through each profile ID
    WHILE i <= array_length(profile_ids, 1) LOOP
        current_id := profile_ids[i];

        -- Call geocoding function for this profile
        PERFORM http((
            'POST',
            'https://oxoiwzijacglgueemlva.supabase.co/functions/v1/geocode',
            ARRAY[
                http_header('Authorization', 'Bearer ' || service_role_key),
                http_header('Content-Type', 'application/json')
            ],
            'application/json',
            json_build_object('profileId', current_id)::text
        ));

        RAISE NOTICE 'Geocoded profile %: %', i, current_id;
        PERFORM pg_sleep(0.2); -- Rate limiting

        i := i + 1;
    END LOOP;

    RAISE NOTICE 'All 7 user profiles geocoded successfully!';
END $$;

-- Alternative: Geocode ALL user profiles (not just specific ones)
DO $$
DECLARE
    current_id TEXT;
    service_role_key TEXT := '$SUPABASE_SERVICE_ROLE_KEY';
BEGIN
    FOR current_id IN
        SELECT id FROM user_profiles
        WHERE latitude IS NULL OR longitude IS NULL
        ORDER BY created_at DESC
    LOOP
        PERFORM http((
            'POST',
            'https://oxoiwzijacglgueemlva.supabase.co/functions/v1/geocode',
            ARRAY[
                http_header('Authorization', 'Bearer ' || service_role_key),
                http_header('Content-Type', 'application/json')
            ],
            'application/json',
            json_build_object('profileId', current_id)::text
        ));

        RAISE NOTICE 'Geocoded profile: %', current_id;
        PERFORM pg_sleep(0.2);
    END LOOP;
END $$;

8. verify user profiles geocoding worked
After running the SQL, you can verify the geocoding worked by checking:

-- Check specific profiles from your list
SELECT id, name, address, city, postal_code, latitude, longitude, geocoded_address
FROM user_profiles
WHERE id IN (
    'd835339e-3752-4721-b0c8-e502c7986625',
    'c544f7e9-6f7c-40d6-a499-2430716e33ce',
    '55aea5b6-7bd5-4b10-8f37-229ac912e47f',
    '142ca005-d98e-4694-a78d-ad711456cd9a',
    'd8d2fc88-1a21-4b3b-9357-73a3f3ea0be0',
    'd3d63f36-2c01-42f4-9522-081d8df4cc98',
    'c3b0be81-e8be-44f5-856f-c85522ced738'
);

-- Check all geocoded profiles
SELECT id, name, address, city, postal_code, latitude, longitude, geocoded_address
FROM user_profiles
WHERE latitude IS NOT NULL
ORDER BY updated_at DESC
LIMIT 10;

--- END OF FILE ---

--- START OF FILE ./supabase/HowToGenerateSupabaseSchema.md ---

# **How to Generate a Reusable Database Schema (`schema.sql`)**

This document outlines the definitive process for generating a `schema.sql` file from a remote Supabase project. This file is a complete, data-free blueprint of your database, including all tables, columns, Row Level Security (RLS) policies, and functions. It's a critical asset for setting up new client instances or restoring a database structure.

#### **1. Prerequisites**

Before you begin, ensure your local development environment is set up correctly. This is a one-time setup.

1.  **Homebrew Installed:** Make sure you have Homebrew, the package manager for macOS. If not, you can install it from [brew.sh](https://brew.sh/).

2.  **Supabase CLI Installed & Updated:** You need the Supabase Command Line Interface.
    *   **Install:** `brew install supabase`
    *   **Verify Version:** Run `supabase --version`. Ensure you are on version `2.40.7` or newer to match the commands in this guide.
    *   **Update if needed:** `brew upgrade supabase`

3.  **Docker Desktop Installed & Running:** The Supabase CLI uses Docker in the background to ensure version consistency.
    *   **Install:** Download and install [Docker Desktop for Mac](https://www.docker.com/products/docker-desktop/).
    *   **CRITICAL:** Before running any Supabase commands, **make sure Docker Desktop is running**. You should see the whale icon in your macOS menu bar, and it should be stationary (not animating).

#### **2. The Process (To be run for each project)**

Follow these steps from your terminal.

**Step 1: Navigate to Your Project Directory**
```bash
# Example path, adjust to your own
cd ~/Projects/PlumbingPoC
```

**Step 2: Log in to the Supabase CLI**
This will open a browser window for you to authorize the CLI.
```bash
supabase login
```

**Step 3: Link Your Local Project to the Remote Supabase Project**
This command will prompt you to choose which remote project you want to work with. It will also ask for your database password.
```bash
supabase link
```

**Step 4: Pull Remote Configuration (Best Practice)**
This syncs your local `supabase/config.toml` file with the latest settings from your Supabase dashboard (like auth providers, redirect URLs, etc.).
```bash
supabase config pull
```

**Step 5: Dump the Database Schema**
This is the final command. It connects to your linked project and saves the schema blueprint to a file.
```bash
# This command dumps the schema ONLY (no data) by default.
# The output is saved to a file named 'schema.sql' inside your 'supabase' directory.
supabase db dump -f supabase/schema.sql
```

#### **3. Verification**

After the command completes, you should have a new file at `supabase/schema.sql`. Open this file to verify its contents:
*   You **SHOULD** see SQL commands like `CREATE TABLE ...`, `CREATE POLICY ...`, and `ALTER TABLE ...`.
*   You **SHOULD NOT** see any commands like `INSERT INTO ...` or `COPY ...` that contain actual user or request data.

You have now successfully created a reusable schema file. You can commit this file to your Git repository so the entire team has a version-controlled copy of the database structure.

--- END OF FILE ---

--- START OF FILE ./supabase/SUPABASE_DATABASE_AND_AUTH_SETUP.md ---

# Supabase Database and Auth Setup information

## Table of Contents

1.  [Supabase Database Configuration](#1-supabase-database-configuration)
    -   [Table Schema Overview](#1a-table-schema-overview)
    -   [Admin Role Check Function (`is_admin`)](#1b-admin-role-check-function-is_admin)
    -   [Storage Bucket: PlumbingPoCBucket](#1c-storage-bucket-plumbingpocbucket)
    -   [Row Level Security (RLS) Policies](#1d-row-level-security-rls-policies)
2.  [Database Schema Files](#2-database-schema-files)
    -   [Complete Schema Dump (`schema.sql`)](#2a-complete-schema-dump-schemasql)
    -   [Schema Generation Guide (`HowToGenerateSupabaseSchema.md`)](#2b-schema-generation-guide-howtogeneratesupabaseschemamd)
    -   [Legacy SQL Setup Scripts (Deprecated)](#2c-legacy-sql-setup-scripts-deprecated)
3.  [Master SQL Setup Script (For Manual Policy Updates)](#3-master-sql-setup-script-for-manual-policy-updates)
4.  [Authentication Provider Configuration](#4-authentication-provider-configuration)
5.  [Helpful CLI Commands & Queries](#5-helpful-cli-commands--queries)

---

## Supabase & Authentication Provider Setup Reference

This document provides a comprehensive reference for the project's Supabase database schema, security policies, and authentication provider setup.

### 1. Supabase Database Configuration

#### 1a. Table Schema Overview

The database is composed of several related tables to manage users, requests, quotes, and communications.

-   **user_profiles**
    -   Stores public-facing user data, linked one-to-one with `auth.users`.
    -   `id` (uuid, primary key, default: gen_random_uuid())
    -   `user_id` (uuid, **unique**, references `auth.users.id`)
    -   `name` (text)
    -   `email` (text)
    -   `phone` (text)
    -   `created_at` (timestamptz, default: now())
    -   `address` (text)
    -   `city` (text)
    -   `postal_code` (text)
    -   `province` (text)
    -   `role` (text, not nullable, default: 'user')

-   **requests**
    -   The core table for initial customer quote requests.
    -   `id` (uuid, primary key, default: gen_random_uuid())
    -   `created_at` (timestamptz, default: now())
    -   `is_emergency` (boolean)
    -   `customer_name` (text)
    -   `service_address` (text)
    -   `contact_info` (text)
    -   `problem_category` (text)
    -   `problem_description` (text)
    -   `property_type` (text)
    -   `is_homeowner` (boolean)
    -   `preferred_timing` (text)
    -   `additional_notes` (text)
    -   `answers` (jsonb)
    -   `status` (text)
    -   `user_id` (uuid, references `user_profiles.user_id`)
    -   `updated_at` (timestamptz)
    -   `scheduled_start_date` (timestamptz)
    -   `last_follow_up_sent_at` (timestamptz)
    -   `triage_summary` (text)
    -   `priority_score` (integer)

-   **quote_attachments**
    -   Stores records of files uploaded for a specific request.
    -   `id` (uuid, primary key, default: gen_random_uuid())
    -   `request_id` (uuid, references `requests.id`)
    -   `file_url` (text, not nullable)
    -   `file_name` (text)
    -   `mime_type` (text)
    -   `uploaded_at` (timestamptz, default: now())
    -   `quote_id` (uuid, references `quotes.id`)

-   **quotes**
    -   Stores formal quotes generated by an admin for a request.
    -   `id` (uuid, primary key, default: gen_random_uuid())
    -   `user_id` (uuid)
    -   `request_id` (uuid)
    -   `quote_amount` (numeric)
    -   `status` (text)
    -   `created_at` (timestamptz, default: now())
    -   `labor_items` (jsonb)
    -   `material_items` (jsonb)
    -   `notes` (text)
    -   `good_until` (date)
    -   `tax_details` (jsonb)
    -   `updated_at` (timestamptz, default: now())
    -   `details` (text)

-   **request_notes**
    -   A log of all communication between the customer and admin regarding a request.
    -   `id` (uuid, primary key, default: gen_random_uuid())
    -   `request_id` (uuid, not nullable, references `requests.id`)
    -   `user_id` (uuid, not nullable, references `auth.users.id`)
    -   `author_role` (text, not nullable)
    -   `note` (text, not nullable)
    -   `created_at` (timestamptz, default: now())

-   **invoices**
    -   Stores invoice data linked to an accepted quote.
    -   `id` (uuid, primary key, default: gen_random_uuid())
    -   `user_id` (uuid)
    -   `quote_id` (uuid, references `quotes.id`)
    -   `amount_due` (numeric)
    -   `due_date` (timestamptz)
    -   `status` (text)
    -   `created_at` (timestamptz, default: now())

#### 1b. Admin Role Check Function (`is_admin`)

To reliably check for administrative privileges within Row Level Security policies without causing infinite recursion, we use a `SECURITY DEFINER` function. This is the standard, most robust method.

-   **Function:** `public.is_admin()`
    -   Returns `true` if the currently authenticated user has the role of 'admin' in their `user_profiles` record, and `false` otherwise.
    -   `SECURITY DEFINER` allows it to query `user_profiles` safely from within an RLS policy on that same table, breaking the recursion loop. All RLS policies that require admin checks now call this function.

#### 1c. Storage Bucket: PlumbingPoCBucket

-   **Purpose:** Securely stores all user-uploaded files (images, PDFs) related to quote requests.
-   **Access:** This bucket is **NOT** public. All access is controlled by Storage Policies.
-   **Policies (SQL):**
    ```sql
    -- Allows any logged-in user to UPLOAD a file.
    CREATE POLICY "Allow authenticated uploads"
    ON storage.objects FOR INSERT
    TO authenticated
    WITH CHECK ( bucket_id = 'PlumbingPoCBucket' );

    -- Allows an ADMIN to view/download ANY file.
    -- This now uses our robust is_admin() function.
    CREATE POLICY "Allow admin read access"
    ON storage.objects FOR SELECT
    TO authenticated
    USING ( is_admin() );
    ```

#### 1d. Row Level Security (RLS) Policies

RLS is **ENABLED** on all public tables. The security model is straightforward:
-   **Regular users** can perform actions (create, read, update, delete) only on records they own (where `auth.uid() = user_id`).
-   **Admins** (as determined by the `is_admin()` function) have unrestricted access to all records in all tables.

### 2. Database Schema Files

#### 2a. Complete Schema Dump (`schema.sql`)

The `supabase/schema.sql` file is the authoritative, complete database schema generated using the Supabase CLI (`supabase db dump`). This file contains:

- All table definitions with columns, constraints, and indexes
- All functions, triggers, and policies
- All extensions and publications
- The complete, current state of the database structure

**To recreate the database from scratch:**
```bash
supabase db dump -f supabase/schema.sql
# Then restore with:
psql -h your-db-host -U your-username -d your-database < supabase/schema.sql
```

**Important:** This file replaces all individual SQL setup files and should be used as the single source of truth for the database schema.

#### 2b. Schema Generation Guide (`HowToGenerateSupabaseSchema.md`)

The `supabase/HowToGenerateSupabaseSchema.md` file contains step-by-step instructions for generating the `schema.sql` file using the Supabase CLI. This ensures you always have an up-to-date, version-controlled copy of your database structure.

### 3. Legacy SQL Setup Scripts (Deprecated)

**Note:** The following SQL files are now deprecated and redundant since the complete schema is available in `schema.sql`. They are kept for historical reference only.

- `SUPABASE_QUOTE_ATTACHMENTS_TABLE.sql` - Table creation for quote_attachments (now in schema.sql)
- `SUPABASE_TABLES.sql` - Policy fixes and column additions (now in schema.sql)

### 4. Master SQL Setup Script (For Manual Policy Updates)

This single, idempotent script can be run in the Supabase SQL Editor to create the `is_admin` helper function and apply all current, correct security policies for every table.

```sql
-- ========= Part 1: Create the definitive is_admin() helper function =========
-- This function is the single source of truth for checking admin status.
CREATE OR REPLACE FUNCTION is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN (
    SELECT EXISTS (
      SELECT 1 FROM public.user_profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ========= Part 2: RLS Enablement and Policy Setup for All Tables =========

-- Table: user_profiles
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
DO $$ DECLARE r RECORD; BEGIN FOR r IN (SELECT policyname FROM pg_policies WHERE tablename = 'user_profiles') LOOP EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) || ' ON public.user_profiles;'; END LOOP; END $$;
CREATE POLICY "Enable read for users and admins" ON public.user_profiles FOR SELECT USING ((auth.uid() = user_id) OR (is_admin()));
CREATE POLICY "Enable insert for own profile" ON public.user_profiles FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable update for users and admins" ON public.user_profiles FOR UPDATE USING ((auth.uid() = user_id) OR (is_admin()));
CREATE POLICY "Enable delete for admins" ON public.user_profiles FOR DELETE USING (is_admin());

-- Table: requests
ALTER TABLE public.requests ENABLE ROW LEVEL SECURITY;
DO $$ DECLARE r RECORD; BEGIN FOR r IN (SELECT policyname FROM pg_policies WHERE tablename = 'requests') LOOP EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) || ' ON public.requests;'; END LOOP; END $$;
CREATE POLICY "Enable read for users and admins" ON public.requests FOR SELECT USING ((auth.uid() = user_id) OR (is_admin()));
CREATE POLICY "Enable insert for own request" ON public.requests FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable update for users and admins" ON public.requests FOR UPDATE USING ((auth.uid() = user_id) OR (is_admin()));
CREATE POLICY "Enable delete for admins" ON public.requests FOR DELETE USING (is_admin());

-- Table: quotes
ALTER TABLE public.quotes ENABLE ROW LEVEL SECURITY;
DO $$ DECLARE r RECORD; BEGIN FOR r IN (SELECT policyname FROM pg_policies WHERE tablename = 'quotes') LOOP EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) || ' ON public.quotes;'; END LOOP; END $$;
CREATE POLICY "Enable all actions for admins" ON public.quotes FOR ALL USING (is_admin());
CREATE POLICY "Enable read for own quotes" ON public.quotes FOR SELECT USING (auth.uid() = user_id);

-- Table: quote_attachments
ALTER TABLE public.quote_attachments ENABLE ROW LEVEL SECURITY;
DO $$ DECLARE r RECORD; BEGIN FOR r IN (SELECT policyname FROM pg_policies WHERE tablename = 'quote_attachments') LOOP EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) || ' ON public.quote_attachments;'; END LOOP; END $$;
CREATE POLICY "Enable read for admins and owners" ON public.quote_attachments FOR SELECT USING ((is_admin()) OR (auth.uid() = (SELECT user_id FROM requests WHERE id = request_id)));
CREATE POLICY "Enable insert for owners" ON public.quote_attachments FOR INSERT WITH CHECK (auth.uid() = (SELECT user_id FROM requests WHERE id = request_id));
CREATE POLICY "Enable delete for admins" ON public.quote_attachments FOR DELETE USING (is_admin());

-- Table: request_notes
ALTER TABLE public.request_notes ENABLE ROW LEVEL SECURITY;
DO $$ DECLARE r RECORD; BEGIN FOR r IN (SELECT policyname FROM pg_policies WHERE tablename = 'request_notes') LOOP EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) || ' ON public.request_notes;'; END LOOP; END $$;
CREATE POLICY "Enable all actions for admins" ON public.request_notes FOR ALL USING (is_admin());
CREATE POLICY "Enable all actions for request owners" ON public.request_notes FOR ALL USING (auth.uid() = (SELECT user_id FROM requests WHERE id = request_id));

-- Table: invoices
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;
DO $$ DECLARE r RECORD; BEGIN FOR r IN (SELECT policyname FROM pg_policies WHERE tablename = 'invoices') LOOP EXECUTE 'DROP POLICY IF EXISTS ' || quote_ident(r.policyname) || ' ON public.invoices;'; END LOOP; END $$;
CREATE POLICY "Enable all actions for admins" ON public.invoices FOR ALL USING (is_admin());
CREATE POLICY "Enable read for own invoices" ON public.invoices FOR SELECT USING (auth.uid() = user_id);
```

### 4. Authentication Provider Configuration

#### 3a. Updating URLs
- Site URL: `https://your-site-name.netlify.app/` (production) or `http://your-local-frontend-url/` (local)
- Add Redirect URLs:
  - `https://your-site-name.netlify.app/*`
  - `http://your-local-frontend-url/*`
- Save changes in Supabase dashboard under Authentication ‚Üí URL Configuration.

#### 3b. Adding Authentication Providers
- Go to Supabase dashboard ‚Üí Authentication ‚Üí Providers
- Enable and configure each provider (Google, Azure)

#### 3c. Configuring Applications for OAuth

##### Google OAuth2 Client Setup (Google Cloud Console)
1. Go to Google Cloud Console ‚Üí APIs & Services ‚Üí Credentials ‚Üí Create OAuth 2.0 Client ID.
2. Choose "Web application" as the application type.
3. Set the name (e.g., PlumbingPoCClient).
4. Add Authorized redirect URI:
   - `https://<your-supabase-project>.supabase.co/auth/v1/callback`
5. (Optional) Add Authorized JavaScript origins for local development:
   - `http://your-local-backend-url/`
   - `http://your-local-frontend-url/`
6. Save and copy the Client ID and Client Secret.
7. Enter these values in Supabase dashboard under Authentication ‚Üí Providers ‚Üí Google.
8. Ensure the following scopes are enabled in Google:
   - `email`
   - `profile`
   - `openid`
9. Save changes in both Supabase and Google Cloud Console.

URL:  https://console.cloud.google.com/


##### Azure Entra App Registration (Microsoft Entra Admin Center)
1. Register a new app in Microsoft Entra admin center.
2. Set the Redirect URI:
   - Platform: Web
   - URI: `https://<your-supabase-project>.supabase.co/auth/v1/callback`
3. Certificates & Secrets:
   - Create a new client secret and copy the value.
4. API Permissions:
    - Microsoft Graph ‚Üí Delegated permissions:
       - `openid` (required for authentication)
       - `email` (required to get user's email)
       - `User.Read` (required to read user profile info)
    - Click "Grant admin consent" for your directory to ensure all permissions are active.
5. Token Configuration (Optional Claims):
    - Go to "Token configuration" in Azure portal.
    - Add an optional claim for `email` in the ID token:
       - Click "Add optional claim" ‚Üí ID token ‚Üí select `email`.
       - Confirm the claim appears in the list as shown in the Azure portal.
       - This ensures the user's email is included in the token sent to Supabase.
    - (Status: claim added as of August 21, 2025)
6. Branding & Properties:
   - Set app name and logo as desired.
7. Enter Azure Client ID and Client Secret in Supabase dashboard under Authentication ‚Üí Providers ‚Üí Azure.
8. Save changes in both Supabase and Azure portal.

URL:  https://entra.microsoft.com

### 4. Troubleshooting
- **Infinite Recursion Error:** If you see an "infinite recursion" error, use the `is_admin()` function pattern described in this document. This `SECURITY DEFINER` function is the standard way to break recursion loops in RLS policies.
- **Admin Can't See All Data:** If an admin can't see all records in a table, it means the `SELECT` policy for that table is missing the `OR is_admin()` condition.
- **After Updating Policies:** Policies using the `is_admin()` function do **not** require you to log out and back in. A simple page refresh is sufficient.
- **OAuth Issues:** Ensure permissions are granted/consented, client secrets are valid, and redirect URIs are identical in both the provider's dashboard and Supabase.

---

### 5. Helpful CLI Commands & Queries

#### supabase cli
-- npx supabase login
-- npx supabase link

#### install supabase on macos
brew install supabase/tap/supabase
supabase --version

## supabase database dump
export PGPASSWORD='<REDACTED>'
pg_dump 'postgresql://PlumbingPoC@oxoiwzijacglgueemlva.supabase.co:5432/postgres' --schema-only --file="supabase_schema_audit.sql"

#### Query 1: Table & Column Schema
SELECT
    c.table_schema,
    c.table_name,
    c.column_name,
    c.data_type,
    c.is_nullable,
    c.column_default
FROM
    information_schema.columns c
WHERE
    c.table_schema = 'public'
    AND c.table_name IN ('invoices', 'quote_attachments', 'quotes', 'request_notes', 'requests', 'user_profiles')
ORDER BY
    c.table_name,
    c.ordinal_position;

### Query 2: Row Level Security (RLS) Policies
SELECT
    p.schemaname AS schema_name,
    p.tablename AS table_name,
    p.policyname AS policy_name,
    p.permissive,
    p.cmd AS command_type,
    p.qual AS policy_expression,
    p.with_check AS with_check_expression
FROM
    pg_policies p
WHERE
    p.schemaname = 'public'
ORDER BY
    p.tablename,
    p.policyname;

#### Query 3: Storage Buckets & Policies
SELECT
    id,
    name,
    public,
    avif_autodetection,
    file_size_limit,
    allowed_mime_types
FROM
    storage.buckets;

#### Query 4: Indexes
SELECT
    tablename,
    indexname,
    indexdef
FROM
    pg_indexes
WHERE
    schemaname = 'public'
    AND tablename IN ('invoices', 'quote_attachments', 'quotes', 'request_notes', 'requests', 'user_profiles')
ORDER BY
    tablename,
    indexname;

#### Query 5: Functions
SELECT
  p.proname AS function_name,
  pg_get_function_identity_arguments(p.oid) AS function_arguments,
  pg_get_functiondef(p.oid) AS function_definition
FROM
  pg_proc p
JOIN
  pg_namespace n ON n.oid = p.pronamespace
WHERE
  n.nspname = 'public' -- Filters for your main schema
  AND p.prokind = 'f'   -- Ensures we only get functions, not procedures or aggregates
ORDER BY
  p.proname;

#### Query 6: Publications

##### Create publication

```sql
-- This script directly and explicitly adds the required tables to the real-time publication.
ALTER PUBLICATION supabase_realtime ADD TABLE public.requests;
ALTER PUBLICATION supabase_realtime ADD TABLE public.request_notes;
ALTER PUBLICATION supabase_realtime ADD TABLE public.quotes;
ALTER PUBLICATION supabase_realtime ADD TABLE public.quote_attachments;
```

##### get list of all publications

```sql
SELECT
  schemaname,
  tablename
FROM
  pg_publication_tables
WHERE
  pubname = 'supabase_realtime';
```

#### subscribers in useRequests.ts

```typescript
// From: packages/frontend/src/features/requests/hooks/useRequests.ts
const subscriptions = [
    { table: 'requests' },          // <-- For status changes, etc.
    { table: 'request_notes' },      // <-- For the communication log
    { table: 'quotes' },             // <-- For quote updates
    { table: 'quote_attachments' } // <-- For file uploads
];
```

##### How process works public subscribe pattern with supabase.

```mermaid
sequenceDiagram
    participant Admin's Browser (Client A)
    participant Customer's Browser (Client B)
    participant Supabase Realtime Server
    participant Postgres Database (request_notes table)

    Note over Admin's Browser (Client A), Customer's Browser (Client B): Pre-condition: Both users have the RequestDetailModal open.

    Admin's Browser (Client A)->>+Supabase Realtime Server: 1. Subscribe to channel: "request-notes-XYZ"
    Supabase Realtime Server-->>-Admin's Browser (Client A): 2. Subscription Confirmed (WebSocket open)

    Customer's Browser (Client B)->>+Supabase Realtime Server: 1. Subscribe to channel: "request-notes-XYZ"
    Supabase Realtime Server-->>-Customer's Browser (Client B): 2. Subscription Confirmed (WebSocket open)

    Note over Supabase Realtime Server: Realtime Server now knows that Client A and Client B are both listening to "request-notes-XYZ".

    Admin's Browser (Client A)->>+Postgres Database (request_notes table): 3. User sends message (API call -> INSERT new note)
    Postgres Database (request_notes table)-->>-Admin's Browser (Client A): API Response (OK)

    Postgres Database (request_notes table)->>+Supabase Realtime Server: 4. [Publication] A new row was inserted into request_notes for request_id = 'XYZ'

    Note over Supabase Realtime Server: The Routing Logic!
    Supabase Realtime Server->>Supabase Realtime Server: 5. Check subscribers for channel "request-notes-XYZ". Found: Client A, Client B.

    Supabase Realtime Server->>+Admin's Browser (Client A): 6. [WebSocket Push] Broadcast new note payload
    Admin's Browser (Client A)->>Admin's Browser (Client A): 8. Listener fires -> onNoteAdded() -> Re-fetch & UI Refresh
    deactivate Admin's Browser (Client A)

    Supabase Realtime Server->>+Customer's Browser (Client B): 7. [WebSocket Push] Broadcast new note payload
    Customer's Browser (Client B)->>Customer's Browser (Client B): 9. Listener fires -> onNoteAdded() -> Re-fetch & UI Refresh
    deactivate Customer's Browser (Client B)

    deactivate Supabase Realtime Server
```

#### Calling key functions
-- Replace with the actual user_id you want to clear.
SELECT delete_user_data('3efcf1bf-978f-4376-af87-8245c664c7ca');

_Last updated: August 21, 2025_

--- END OF FILE ---

--- START OF FILE ./supabase/functions/geocode/index.ts ---

// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts";

interface GeocodeRequest {
  address?: string;
  requestId?: string;x
  profileId?: string;
}

interface GeocodeResponse {
  success: boolean;
  latitude?: number;
  longitude?: number;
  formattedAddress?: string;
  error?: string;
}

console.info('Universal geocoding function started');

Deno.serve(async (req: Request) => {
  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ success: false, error: 'Method not allowed' }), {
      status: 405,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    const { address, requestId, profileId }: GeocodeRequest = await req.json();

    // Get Supabase credentials
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const apiKey = Deno.env.get('GOOGLE_MAPS_API_KEY');

    if (!apiKey) {
      return new Response(JSON.stringify({ success: false, error: 'Google Maps API key not configured' }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    let targetAddress = address;
    let updateTable = '';
    let updateId = '';

    // Determine what to geocode based on input
    if (requestId) {
      // Geocode for a request
      const fetchResponse = await fetch(`${supabaseUrl}/rest/v1/requests?id=eq.${requestId}&select=service_address`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${supabaseServiceKey}`,
          'apikey': supabaseServiceKey,
          'Content-Type': 'application/json'
        }
      });

      if (!fetchResponse.ok) {
        return new Response(JSON.stringify({ success: false, error: 'Failed to fetch request' }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      const requests = await fetchResponse.json();
      if (!requests || requests.length === 0) {
        return new Response(JSON.stringify({ success: false, error: 'Request not found' }), {
          status: 404,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      targetAddress = requests[0].service_address;
      updateTable = 'requests';
      updateId = requestId;
    } else if (profileId) {
      // Geocode for a user profile
      const fetchResponse = await fetch(`${supabaseUrl}/rest/v1/user_profiles?id=eq.${profileId}&select=address,city,province,postal_code`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${supabaseServiceKey}`,
          'apikey': supabaseServiceKey,
          'Content-Type': 'application/json'
        }
      });

      if (!fetchResponse.ok) {
        return new Response(JSON.stringify({ success: false, error: 'Failed to fetch profile' }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      const profiles = await fetchResponse.json();
      if (!profiles || profiles.length === 0) {
        return new Response(JSON.stringify({ success: false, error: 'Profile not found' }), {
          status: 404,
          headers: { 'Content-Type': 'application/json' }
        });
      }

      const profile = profiles[0];
      targetAddress = `${profile.address}, ${profile.city}, ${profile.province} ${profile.postal_code}`;
      updateTable = 'user_profiles';
      updateId = profileId;
    } else if (!address) {
      return new Response(JSON.stringify({ success: false, error: 'Either address, requestId, or profileId is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (!targetAddress) {
      return new Response(JSON.stringify({ success: false, error: 'No address found to geocode' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Call Google Maps Geocoding API
    const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(targetAddress)}&key=${apiKey}`;
    const response = await fetch(url);
    const data = await response.json();

    if (data.status !== 'OK' || !data.results || data.results.length === 0) {
      return new Response(JSON.stringify({
        success: false,
        error: `Geocoding failed: ${data.status}`
      }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const result = data.results[0];
    const location = result.geometry.location;
    const formattedAddress = result.formatted_address;

    // Update the appropriate table
    if (updateTable && updateId) {
      const updateResponse = await fetch(`${supabaseUrl}/rest/v1/${updateTable}?id=eq.${updateId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${supabaseServiceKey}`,
          'apikey': supabaseServiceKey,
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal'
        },
        body: JSON.stringify({
          latitude: location.lat,
          longitude: location.lng,
          geocoded_address: formattedAddress
        })
      });

      if (!updateResponse.ok) {
        return new Response(JSON.stringify({ success: false, error: 'Failed to update record' }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
    }

    const res: GeocodeResponse = {
      success: true,
      latitude: location.lat,
      longitude: location.lng,
      formattedAddress,
    };

    return new Response(JSON.stringify(res), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('Geocoding error:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || 'Internal server error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
});

--- END OF FILE ---

--- START OF FILE ./supabase/schema.sql ---



SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "http" WITH SCHEMA "public";






CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."accept_quote_and_update_request"("p_request_id" "uuid", "p_quote_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Step 1: Update the selected quote's status to 'accepted'
  UPDATE public.quotes
  SET status = 'accepted'
  WHERE id = p_quote_id AND request_id = p_request_id;

  -- Step 2: Update all other quotes for the same request to 'rejected'
  UPDATE public.quotes
  SET status = 'rejected'
  WHERE request_id = p_request_id AND id <> p_quote_id;

  -- Step 3: Update the parent request's status to 'accepted'
  UPDATE public.requests
  SET status = 'accepted'
  WHERE id = p_request_id;
END;
$$;


ALTER FUNCTION "public"."accept_quote_and_update_request"("p_request_id" "uuid", "p_quote_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_user_data"("target_user_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  request_ids uuid[];
  quote_ids uuid[];
BEGIN
  -- NO SECURITY CHECK HERE - This function is for direct admin use.

  -- Step 1: Gather all request IDs for the target user.
  SELECT array_agg(id) INTO request_ids FROM public.requests WHERE user_id = target_user_id;

  IF array_length(request_ids, 1) IS NULL THEN
    RETURN 'No requests found for the specified user. Nothing to delete.';
  END IF;

  -- Step 2: Gather all quote IDs associated with those requests.
  SELECT array_agg(id) INTO quote_ids FROM public.quotes WHERE request_id = ANY(request_ids);

  -- Step 3: Delete data in the correct cascading order.
  IF array_length(quote_ids, 1) IS NOT NULL THEN
    DELETE FROM public.invoices WHERE quote_id = ANY(quote_ids);
  END IF;

  DELETE FROM public.quote_attachments WHERE request_id = ANY(request_ids);
  DELETE FROM public.request_notes WHERE request_id = ANY(request_ids);

  IF array_length(quote_ids, 1) IS NOT NULL THEN
    DELETE FROM public.quotes WHERE id = ANY(quote_ids);
  END IF;

  -- Step 4: Delete the parent requests.
  DELETE FROM public.requests WHERE id = ANY(request_ids);

  RETURN 'v2: Successfully deleted all requests and related data for user ' || target_user_id;
END;
$$;


ALTER FUNCTION "public"."delete_user_data"("target_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"() RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN (
    SELECT EXISTS (
      SELECT 1 FROM public.user_profiles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );
END;
$$;


ALTER FUNCTION "public"."is_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"("user_id" "uuid") RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_profiles
    WHERE user_id = is_admin.user_id
      AND role = 'admin'
  );
$$;


ALTER FUNCTION "public"."is_admin"("user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_quote_number"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Find the highest existing quote_number for the same request_id,
  -- add 1 to it. If no quotes exist yet (the result is NULL), start at 1.
  NEW.quote_number := (
    SELECT COALESCE(MAX(quote_number), 0) + 1
    FROM public.quotes
    WHERE request_id = NEW.request_id
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_quote_number"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_invoice_status_to_request"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only update request status if invoice status changed
  IF (TG_OP = 'UPDATE' AND OLD.status IS DISTINCT FROM NEW.status) OR TG_OP = 'INSERT' THEN

    -- Update the associated request's status based on invoice status
    UPDATE public.requests
    SET status = CASE NEW.status
      WHEN 'sent' THEN 'invoiced'
      WHEN 'paid' THEN 'paid'
      WHEN 'overdue' THEN 'overdue'
      WHEN 'disputed' THEN 'disputed'
      WHEN 'cancelled' THEN 'completed'  -- Return to completed if invoice cancelled
      ELSE status  -- Keep current status for 'draft' and other states
    END
    WHERE id = (
      SELECT id FROM public.requests WHERE invoice_id = NEW.id
    );

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_invoice_status_to_request"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."sync_invoice_status_to_request"() IS 'Automatically updates request.status when invoice.status changes';



CREATE OR REPLACE FUNCTION "public"."update_requests_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_requests_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_user_role_from_profile"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Check if the role column is actually being updated to avoid unnecessary writes
  IF TG_OP = 'INSERT' OR NEW.role IS DISTINCT FROM OLD.role THEN
    UPDATE auth.users
    SET raw_user_meta_data = raw_user_meta_data || jsonb_build_object('role', NEW.role)
    WHERE id = NEW.user_id;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_user_role_from_profile"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."email_audit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "request_id" "uuid",
    "recipient" "text",
    "resend_message_id" "text",
    "provider_response" "jsonb",
    "status" "text" DEFAULT 'sent'::"text" NOT NULL
);


ALTER TABLE "public"."email_audit" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invoices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "quote_id" "uuid",
    "amount_due" numeric,
    "due_date" timestamp with time zone,
    "status" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "line_items" "jsonb",
    "subtotal" numeric(10,2),
    "tax_rate" numeric(5,2) DEFAULT 0.13,
    "tax_amount" numeric(10,2),
    "total" numeric(10,2),
    "paid_at" timestamp with time zone,
    "payment_method" "text",
    "stripe_payment_intent_id" "text",
    "notes" "text",
    "ai_generated" boolean DEFAULT false,
    "ai_variance_explanation" "text",
    "request_id" "uuid",
    CONSTRAINT "invoices_payment_method_check" CHECK (("payment_method" = ANY (ARRAY['stripe'::"text", 'check'::"text", 'cash'::"text", 'etransfer'::"text", 'other'::"text"]))),
    CONSTRAINT "invoices_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'sent'::"text", 'paid'::"text", 'overdue'::"text", 'cancelled'::"text", 'disputed'::"text", 'partially_paid'::"text"])))
);


ALTER TABLE "public"."invoices" OWNER TO "postgres";


COMMENT ON COLUMN "public"."invoices"."amount_due" IS 'DEPRECATED: Use total instead. Kept for backward compatibility.';



COMMENT ON COLUMN "public"."invoices"."status" IS 'Invoice status: draft, sent, paid, overdue, cancelled, disputed, partially_paid';



COMMENT ON COLUMN "public"."invoices"."line_items" IS 'Array of line items: [{description, quantity, unit_price, total}, ...]';



COMMENT ON COLUMN "public"."invoices"."subtotal" IS 'Sum of all line items before tax';



COMMENT ON COLUMN "public"."invoices"."tax_rate" IS 'Tax rate as decimal (e.g., 0.13 for 13% tax)';



COMMENT ON COLUMN "public"."invoices"."tax_amount" IS 'Calculated tax amount (subtotal * tax_rate)';



COMMENT ON COLUMN "public"."invoices"."total" IS 'Final amount (subtotal + tax_amount)';



COMMENT ON COLUMN "public"."invoices"."paid_at" IS 'Timestamp when payment was received';



COMMENT ON COLUMN "public"."invoices"."payment_method" IS 'How customer paid: stripe, check, cash, etransfer, other';



COMMENT ON COLUMN "public"."invoices"."stripe_payment_intent_id" IS 'Stripe Payment Intent ID for online payments';



COMMENT ON COLUMN "public"."invoices"."notes" IS 'Admin notes or additional information for customer';



COMMENT ON COLUMN "public"."invoices"."ai_generated" IS 'True if invoice was generated by AI agent';



COMMENT ON COLUMN "public"."invoices"."ai_variance_explanation" IS 'AI-generated explanation for quote-to-invoice differences';



CREATE TABLE IF NOT EXISTS "public"."quote_attachments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "request_id" "uuid",
    "file_url" "text" NOT NULL,
    "file_name" "text",
    "mime_type" "text",
    "uploaded_at" timestamp with time zone DEFAULT "now"(),
    "quote_id" "uuid"
);


ALTER TABLE "public"."quote_attachments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."quotes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "request_id" "uuid",
    "quote_amount" numeric,
    "status" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "labor_items" "jsonb",
    "material_items" "jsonb",
    "notes" "text",
    "good_until" "date",
    "tax_details" "jsonb",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "details" "text",
    "quote_number" integer
);


ALTER TABLE "public"."quotes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."request_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "request_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "author_role" "text" NOT NULL,
    "note" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."request_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "is_emergency" boolean,
    "customer_name" "text",
    "service_address" "text",
    "contact_info" "text",
    "problem_category" "text",
    "problem_description" "text",
    "property_type" "text",
    "is_homeowner" boolean,
    "preferred_timing" "text",
    "additional_notes" "text",
    "answers" "jsonb",
    "status" "text",
    "user_id" "uuid",
    "updated_at" timestamp with time zone,
    "scheduled_start_date" timestamp with time zone,
    "last_follow_up_sent_at" timestamp with time zone,
    "triage_summary" "text",
    "priority_score" integer,
    "profitability_score" integer,
    "priority_explanation" "text",
    "profitability_explanation" "text",
    "latitude" double precision,
    "longitude" double precision,
    "geocoded_address" "text",
    "actual_cost" numeric(10,2),
    "completion_notes" "text",
    "required_expertise" "jsonb",
    "invoice_id" "uuid",
    CONSTRAINT "chk_latitude_range" CHECK ((("latitude" >= ('-90'::integer)::double precision) AND ("latitude" <= (90)::double precision))),
    CONSTRAINT "chk_longitude_range" CHECK ((("longitude" >= ('-180'::integer)::double precision) AND ("longitude" <= (180)::double precision))),
    CONSTRAINT "requests_status_check" CHECK (("status" = ANY (ARRAY['new'::"text", 'viewed'::"text", 'quoted'::"text", 'accepted'::"text", 'scheduled'::"text", 'in_progress'::"text", 'completed'::"text", 'invoiced'::"text", 'paid'::"text", 'overdue'::"text", 'disputed'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."requests" OWNER TO "postgres";


COMMENT ON COLUMN "public"."requests"."status" IS 'Request lifecycle status: new ‚Üí quoted ‚Üí accepted ‚Üí scheduled ‚Üí in_progress ‚Üí completed ‚Üí invoiced ‚Üí paid/overdue/disputed';



COMMENT ON COLUMN "public"."requests"."actual_cost" IS 'The final, invoiced cost of the completed job.';



COMMENT ON COLUMN "public"."requests"."completion_notes" IS 'Internal notes logged by the admin when the job was marked as complete.';



COMMENT ON COLUMN "public"."requests"."required_expertise" IS 'AI-generated expertise requirements: skill_level (apprentice/journeyman/master), specialized_skills array, and reasoning';



COMMENT ON COLUMN "public"."requests"."invoice_id" IS 'Reference to associated invoice (if created)';



CREATE TABLE IF NOT EXISTS "public"."user_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "name" "text",
    "email" "text",
    "phone" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "address" "text",
    "city" "text",
    "postal_code" "text",
    "province" "text",
    "role" "text" DEFAULT 'user'::"text" NOT NULL,
    "latitude" numeric(10,8),
    "longitude" numeric(11,8),
    "geocoded_address" "text"
);


ALTER TABLE "public"."user_profiles" OWNER TO "postgres";


COMMENT ON COLUMN "public"."user_profiles"."latitude" IS 'Cached latitude from Google Maps geocoding';



COMMENT ON COLUMN "public"."user_profiles"."longitude" IS 'Cached longitude from Google Maps geocoding';



COMMENT ON COLUMN "public"."user_profiles"."geocoded_address" IS 'Full formatted address from Google Maps';



ALTER TABLE ONLY "public"."email_audit"
    ADD CONSTRAINT "email_audit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."quote_attachments"
    ADD CONSTRAINT "quote_attachments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."request_notes"
    ADD CONSTRAINT "request_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."requests"
    ADD CONSTRAINT "requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_id_key" UNIQUE ("user_id");



CREATE INDEX "idx_email_audit_request_id" ON "public"."email_audit" USING "btree" ("request_id");



CREATE INDEX "idx_invoices_due_date" ON "public"."invoices" USING "btree" ("due_date") WHERE ("status" = 'sent'::"text");



CREATE INDEX "idx_invoices_paid_at" ON "public"."invoices" USING "btree" ("paid_at");



CREATE INDEX "idx_invoices_request_id" ON "public"."invoices" USING "btree" ("request_id");



CREATE INDEX "idx_invoices_status" ON "public"."invoices" USING "btree" ("status");



CREATE INDEX "idx_invoices_stripe_payment_intent" ON "public"."invoices" USING "btree" ("stripe_payment_intent_id");



CREATE INDEX "idx_quote_attachments_quote_id" ON "public"."quote_attachments" USING "btree" ("quote_id");



CREATE INDEX "idx_quote_attachments_request_id" ON "public"."quote_attachments" USING "btree" ("request_id");



CREATE INDEX "idx_requests_invoice_id" ON "public"."requests" USING "btree" ("invoice_id");



CREATE INDEX "idx_requests_lat_lng" ON "public"."requests" USING "btree" ("latitude", "longitude");



CREATE INDEX "idx_requests_latitude" ON "public"."requests" USING "btree" ("latitude");



CREATE INDEX "idx_requests_longitude" ON "public"."requests" USING "btree" ("longitude");



CREATE INDEX "idx_user_profiles_coordinates" ON "public"."user_profiles" USING "btree" ("latitude", "longitude");



CREATE INDEX "requests_created_at_idx" ON "public"."requests" USING "btree" ("created_at" DESC);



CREATE OR REPLACE TRIGGER "on_profile_role_change" AFTER INSERT OR UPDATE OF "role" ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_user_role_from_profile"();



CREATE OR REPLACE TRIGGER "on_public_requests_updated" BEFORE UPDATE ON "public"."requests" FOR EACH ROW EXECUTE FUNCTION "public"."handle_updated_at"();



CREATE OR REPLACE TRIGGER "trg_set_quote_number" BEFORE INSERT ON "public"."quotes" FOR EACH ROW EXECUTE FUNCTION "public"."set_quote_number"();



CREATE OR REPLACE TRIGGER "trigger_sync_invoice_status" AFTER INSERT OR UPDATE OF "status" ON "public"."invoices" FOR EACH ROW EXECUTE FUNCTION "public"."sync_invoice_status_to_request"();



COMMENT ON TRIGGER "trigger_sync_invoice_status" ON "public"."invoices" IS 'Syncs invoice status changes to associated request status';



CREATE OR REPLACE TRIGGER "update_requests_updated_at" BEFORE UPDATE ON "public"."requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_requests_updated_at_column"();



ALTER TABLE ONLY "public"."email_audit"
    ADD CONSTRAINT "email_audit_request_id_fkey" FOREIGN KEY ("request_id") REFERENCES "public"."requests"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "fk_invoices_request" FOREIGN KEY ("request_id") REFERENCES "public"."requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."requests"
    ADD CONSTRAINT "fk_requests_invoice" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_quote_id_fkey" FOREIGN KEY ("quote_id") REFERENCES "public"."quotes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quote_attachments"
    ADD CONSTRAINT "quote_attachments_quote_id_fkey" FOREIGN KEY ("quote_id") REFERENCES "public"."quotes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quote_attachments"
    ADD CONSTRAINT "quote_attachments_request_id_fkey" FOREIGN KEY ("request_id") REFERENCES "public"."requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_request_id_fkey" FOREIGN KEY ("request_id") REFERENCES "public"."requests"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."quotes"
    ADD CONSTRAINT "quotes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."request_notes"
    ADD CONSTRAINT "request_notes_request_id_fkey" FOREIGN KEY ("request_id") REFERENCES "public"."requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."request_notes"
    ADD CONSTRAINT "request_notes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."requests"
    ADD CONSTRAINT "requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."user_profiles"("user_id");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE POLICY "Enable all actions for admins" ON "public"."invoices" USING ("public"."is_admin"());



CREATE POLICY "Enable all actions for admins" ON "public"."quotes" USING ("public"."is_admin"()) WITH CHECK ("public"."is_admin"());



CREATE POLICY "Enable all actions for admins" ON "public"."request_notes" USING ("public"."is_admin"());



CREATE POLICY "Enable all actions for request owners" ON "public"."request_notes" USING ((("auth"."uid"() = ( SELECT "requests"."user_id"
   FROM "public"."requests"
  WHERE ("requests"."id" = "request_notes"."request_id"))) OR "public"."is_admin"()));



CREATE POLICY "Enable delete for admins" ON "public"."quote_attachments" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "Enable delete for admins" ON "public"."requests" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "Enable delete for admins" ON "public"."user_profiles" FOR DELETE USING ("public"."is_admin"());



CREATE POLICY "Enable insert for own profile" ON "public"."user_profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Enable insert for own request" ON "public"."requests" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Enable insert for owners" ON "public"."quote_attachments" FOR INSERT WITH CHECK (("auth"."uid"() = ( SELECT "requests"."user_id"
   FROM "public"."requests"
  WHERE ("requests"."id" = "quote_attachments"."request_id"))));



CREATE POLICY "Enable read for admins and owners" ON "public"."requests" FOR SELECT USING ((("auth"."uid"() = "user_id") OR "public"."is_admin"()));



CREATE POLICY "Enable read for own invoices" ON "public"."invoices" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Enable read for request owners" ON "public"."quote_attachments" FOR SELECT USING ((("auth"."uid"() = ( SELECT "requests"."user_id"
   FROM "public"."requests"
  WHERE ("requests"."id" = "quote_attachments"."request_id"))) OR "public"."is_admin"()));



CREATE POLICY "Enable read for request owners" ON "public"."quotes" FOR SELECT USING (("auth"."uid"() = ( SELECT "requests"."user_id"
   FROM "public"."requests"
  WHERE ("requests"."id" = "quotes"."request_id"))));



CREATE POLICY "Enable read for users and admins" ON "public"."user_profiles" FOR SELECT USING ((("auth"."uid"() = "user_id") OR "public"."is_admin"()));



CREATE POLICY "Enable update for users and admins" ON "public"."requests" FOR UPDATE USING ((("auth"."uid"() = "user_id") OR "public"."is_admin"()));



CREATE POLICY "Enable update for users and admins" ON "public"."user_profiles" FOR UPDATE USING ((("auth"."uid"() = "user_id") OR "public"."is_admin"()));



CREATE POLICY "allow_admin_select_on_email_audit" ON "public"."email_audit" FOR SELECT USING (((("current_setting"('request.jwt.claims'::"text", true))::json ->> 'role'::"text") = 'admin'::"text"));



ALTER TABLE "public"."email_audit" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."quote_attachments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."quotes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."request_notes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_profiles" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."quote_attachments";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."quotes";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."request_notes";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."requests";



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

























































































































































GRANT ALL ON FUNCTION "public"."accept_quote_and_update_request"("p_request_id" "uuid", "p_quote_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."accept_quote_and_update_request"("p_request_id" "uuid", "p_quote_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."accept_quote_and_update_request"("p_request_id" "uuid", "p_quote_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "postgres";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "anon";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "authenticated";
GRANT ALL ON FUNCTION "public"."bytea_to_text"("data" "bytea") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_user_data"("target_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_user_data"("target_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_user_data"("target_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "postgres";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "anon";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http"("request" "public"."http_request") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_delete"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_get"("uri" character varying, "data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_head"("uri" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_header"("field" character varying, "value" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "postgres";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "anon";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_list_curlopt"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_patch"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_post"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_put"("uri" character varying, "content" character varying, "content_type" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "postgres";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "anon";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_reset_curlopt"() TO "service_role";



GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."http_set_curlopt"("curlopt" character varying, "value" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin"("user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"("user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"("user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_quote_number"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_quote_number"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_quote_number"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_invoice_status_to_request"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_invoice_status_to_request"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_invoice_status_to_request"() TO "service_role";



GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "postgres";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."text_to_bytea"("data" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_requests_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_requests_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_requests_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_user_role_from_profile"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_user_role_from_profile"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_user_role_from_profile"() TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("string" "bytea") TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("data" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "postgres";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."urlencode"("string" character varying) TO "service_role";


















GRANT ALL ON TABLE "public"."email_audit" TO "anon";
GRANT ALL ON TABLE "public"."email_audit" TO "authenticated";
GRANT ALL ON TABLE "public"."email_audit" TO "service_role";



GRANT ALL ON TABLE "public"."invoices" TO "anon";
GRANT ALL ON TABLE "public"."invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."invoices" TO "service_role";



GRANT ALL ON TABLE "public"."quote_attachments" TO "anon";
GRANT ALL ON TABLE "public"."quote_attachments" TO "authenticated";
GRANT ALL ON TABLE "public"."quote_attachments" TO "service_role";



GRANT ALL ON TABLE "public"."quotes" TO "anon";
GRANT ALL ON TABLE "public"."quotes" TO "authenticated";
GRANT ALL ON TABLE "public"."quotes" TO "service_role";



GRANT ALL ON TABLE "public"."request_notes" TO "anon";
GRANT ALL ON TABLE "public"."request_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."request_notes" TO "service_role";



GRANT ALL ON TABLE "public"."requests" TO "anon";
GRANT ALL ON TABLE "public"."requests" TO "authenticated";
GRANT ALL ON TABLE "public"."requests" TO "service_role";



GRANT ALL ON TABLE "public"."user_profiles" TO "anon";
GRANT ALL ON TABLE "public"."user_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_profiles" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






























RESET ALL;

--- END OF FILE ---

--- START OF FILE ./vitest.config.ts ---

import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['node_modules', 'dist', '.git', '.cache', 'packages/backend/**', 'tests/e2e/**', 'tests/integration/**'], // Exclude backend, E2E, and integration tests from CI runs
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        'tests/',
        '**/*.d.ts',
        '**/*.config.{js,ts}',
        'packages/backend/', // Explicitly exclude backend from coverage
        'coverage/',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './packages/frontend/src'),
    },
  },
});

--- END OF FILE ---

--- START OF FILE ./vitest.temp.config.ts ---

import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['node_modules', 'dist', '.git', '.cache', 'packages/backend/**', 'tests/e2e/**', 'tests/integration/**'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './packages/frontend/src'),
    },
  },
});

--- END OF FILE ---

